description = "USB Port 0 XHCI"
[[bank]]
  name = "USB3_0_XHCI"
  address = "0xfe200000"
[[bank]]
  name = "USB3_1_XHCI"
  address = "0xfe300000"
[[register]]
  name = "CAPLENGTH"
  type = "ro"
  width = 32
  description = "Capability Registers Length Host Controller Operational Registers = Base address + CAPLENGTH where CAPLENGTH is `DWC_USB3_HOST_CAP_REG_LEN whose default value is 20h."
  default = "0x00000000"
  offset = "0x00000000"
  [[register.field]]
    name = "HCIVERSION"
    bits = "31:16"
    type = "ro"
  [[register.field]]
    name = "RESERVED"
    bits = "15:8"
    type = "ro"
  [[register.field]]
    name = "CAPLENGTH"
    bits = "7:0"
    type = "ro"
[[register]]
  name = "HCSPARAMS1"
  type = "ro"
  width = 32
  description = "Structural Parameters 1 Register For register definitions, refer to the xHCI specification."
  default = "0x00000000"
  offset = "0x00000004"
  [[register.field]]
    name = "MAXPORTS"
    bits = "31:24"
    type = "ro"
    shortdesc = '''Number of Ports (MaxPorts) - Number of ports implemented is defined by the parameter (`DWC_USB3_HOST_NUM_U2_ROOT_PORTS + `DWC_USB3_HOST_NUM_U3_ROOT_PORTS) - Number of ports enabled is controlled by the core input signals host_num_u2_port[3:0]+host_num_u3_port[3:0] Note: In USB 2.'''
    longdesc = '''0-only mode, the host_num_u3_port signal is zero.'''
  [[register.field]]
    name = "RESERVED"
    bits = "23:19"
    type = "ro"
  [[register.field]]
    name = "MAXINTRS"
    bits = "18:8"
    type = "ro"
  [[register.field]]
    name = "MAXSLOTS"
    bits = "7:0"
    type = "ro"
[[register]]
  name = "HCSPARAMS2"
  type = "ro"
  width = 32
  description = "Structural Parameters 2 Register For register definitions, refer to the xHCI specification."
  default = "0x00000000"
  offset = "0x00000008"
  [[register.field]]
    name = "MAXSCRATCHPADBUFS"
    bits = "31:27"
    type = "ro"
    shortdesc = '''Max Scratchpad Bufs Lo The value is calculated based on chosen configuration parameter values.'''
    longdesc = '''Possible values are 1-4.'''
  [[register.field]]
    name = "SPR"
    bits = "26"
    type = "ro"
  [[register.field]]
    name = "MAXSCRATCHPADBUFS_HI"
    bits = "25:21"
    type = "ro"
  [[register.field]]
    name = "RESERVED"
    bits = "20:8"
    type = "ro"
  [[register.field]]
    name = "ERSTMAX"
    bits = "7:4"
    type = "ro"
  [[register.field]]
    name = "IST"
    bits = "3:0"
    type = "ro"
[[register]]
  name = "HCSPARAMS3"
  type = "ro"
  width = 32
  description = "Structural Parameters 3 Register For register definitions, refer to the xHCI specification."
  default = "0x00000000"
  offset = "0x0000000C"
  [[register.field]]
    name = "U2_DEVICE_EXIT_LAT"
    bits = "31:16"
    type = "ro"
  [[register.field]]
    name = "RESERVED"
    bits = "15:8"
    type = "ro"
  [[register.field]]
    name = "U1_DEVICE_EXIT_LAT"
    bits = "7:0"
    type = "ro"
[[register]]
  name = "HCCPARAMS1"
  type = "ro"
  width = 32
  description = "Capability Parameters 1 Register For register definitions, refer to the xHCI specification."
  default = "0x0238F66D"
  offset = "0x00000010"
  [[register.field]]
    name = "XECP"
    bits = "31:16"
    type = "ro"
    shortdesc = '''xHCI Extended Capabilities Pointer (xECP) Based on configuration, core automatically updates it.'''
    longdesc = '''Refer to <workspace>/src/DWC_usb3_params.v for details on DWC_USB3_HC_XECP.'''
  [[register.field]]
    name = "MAXPSASIZE"
    bits = "15:12"
    type = "ro"
    shortdesc = '''Maximum Primary Stream Array Size (MaxPSASize) For a description of this standard USB register field, see the eXtensible Host Controller Interface for Universal Serial Bus (USB) Specification 3.'''
    longdesc = '''0.'''
  [[register.field]]
    name = "CFC"
    bits = "11"
    type = "ro"
  [[register.field]]
    name = "SEC"
    bits = "10"
    type = "ro"
    shortdesc = '''Stopped EDLTA Capability (SEC) For a description of this standard USB register field, see the eXtensible Host Controller Interface for Universal Serial Bus (USB) Specification 3.'''
    longdesc = '''0.'''
  [[register.field]]
    name = "SPC"
    bits = "9"
    type = "ro"
    shortdesc = '''Short Packet Capability (SPC) For a description of this standard USB register field, see the eXtensible Host Controller Interface for Universal Serial Bus (USB) Specification 3.'''
    longdesc = '''0.'''
  [[register.field]]
    name = "PAE"
    bits = "8"
    type = "ro"
    shortdesc = '''Parse All Event Data (PAE) For a description of this standard USB register field, see the eXtensible Host Controller Interface for Universal Serial Bus (USB) Specification 3.'''
    longdesc = '''0.'''
  [[register.field]]
    name = "NSS"
    bits = "7"
    type = "ro"
    shortdesc = '''No Secondary SID Support (NSS) For a description of this standard USB register field, see the eXtensible Host Controller Interface for Universal Serial Bus (USB) Specification 3.'''
    longdesc = '''0.'''
  [[register.field]]
    name = "LTC"
    bits = "6"
    type = "ro"
    shortdesc = '''Latency Tolerance Messaging Capability (LTC) For a description of this standard USB register field, see the eXtensible Host Controller Interface for Universal Serial Bus (USB) Specification 3.'''
    longdesc = '''0.'''
  [[register.field]]
    name = "LHRC"
    bits = "5"
    type = "ro"
    shortdesc = '''Light HC Reset Capability For a description of this standard USB register field, see the eXtensible Host Controller Interface for Universal Serial Bus (USB) Specification 3.'''
    longdesc = '''0.'''
  [[register.field]]
    name = "PIND"
    bits = "4"
    type = "ro"
    shortdesc = '''Port Indicators (PIND) For a description of this standard USB register field, see the eXtensible Host Controller Interface for Universal Serial Bus (USB) Specification 3.'''
    longdesc = '''0.'''
  [[register.field]]
    name = "PPC"
    bits = "3"
    type = "ro"
    shortdesc = '''Port Power Control For a description of this standard USB register field, see the eXtensible Host Controller Interface for Universal Serial Bus (USB) Specification 3.'''
    longdesc = '''0.'''
  [[register.field]]
    name = "CSZ"
    bits = "2"
    type = "ro"
    shortdesc = '''Context Size (CSZ) For a description of this standard USB register field, see the eXtensible Host Controller Interface for Universal Serial Bus (USB) Specification 3.'''
    longdesc = '''0.'''
  [[register.field]]
    name = "BNC"
    bits = "1"
    type = "ro"
    shortdesc = '''BW Negotiation Capability (BNC) For a description of this standard USB register field, see the eXtensible Host Controller Interface for Universal Serial Bus (USB) Specification 3.'''
    longdesc = '''0.'''
  [[register.field]]
    name = "AC64"
    bits = "0"
    type = "ro"
    shortdesc = '''64-bit Addressing Capability (AC64) For a description of this standard USB register field, see the eXtensible Host Controller Interface for Universal Serial Bus (USB) Specification 3.'''
    longdesc = '''0.'''
[[register]]
  name = "DBOFF"
  type = "ro"
  width = 32
  description = "Doorbell Offset Register For register definitions, refer to the xHCI specification."
  default = "0x00000000"
  offset = "0x00000014"
  [[register.field]]
    name = "DOORBELL_ARRAY_OFFSET"
    bits = "31:2"
    type = "ro"
    shortdesc = '''Doorbell Array Offset - RO Based on configuration, core automatically updates it.'''
    longdesc = '''For a description of this standard USB register field, see the eXtensible Host Controller Interface for Universal Serial Bus (USB) Specification 3.0.'''
  [[register.field]]
    name = "RESERVED"
    bits = "1:0"
    type = "ro"
[[register]]
  name = "RTSOFF"
  type = "ro"
  width = 32
  description = "Runtime Register Space Offset Register"
  default = "0x00000000"
  offset = "0x00000018"
  [[register.field]]
    name = "RUNTIME_REG_SPACE_OFFSET"
    bits = "31:5"
    type = "ro"
    shortdesc = '''Runtime Register Space Offset Based on configuration, core automatically updates it.'''
    longdesc = '''For a description of this standard USB register field, see the eXtensible Host Controller Interface for Universal Serial Bus (USB) Specification 3.0.'''
  [[register.field]]
    name = "RESERVED"
    bits = "4:0"
    type = "ro"
[[register]]
  name = "HCCPARAMS2"
  type = "ro"
  width = 32
  description = "Host Controller Capability Parameters 2 For register definitions, refer to the xHCI specification."
  default = "0x0000000B"
  offset = "0x0000001C"
  [[register.field]]
    name = "RESERVED"
    bits = "31:6"
    type = "ro"
  [[register.field]]
    name = "CIC"
    bits = "5"
    type = "ro"
    shortdesc = '''Configuration Information Capability (CIC) For a description of this standard USB register field, see the eXtensible Host Controller I nterface for Universal Serial Bus (USB) Specification 3.'''
    longdesc = '''0.'''
  [[register.field]]
    name = "LEC"
    bits = "4"
    type = "ro"
    shortdesc = '''Large ESIT Payload Capability (LEC) For a description of this standard USB register field, see the eXtensible Host Controller I nterface for Universal Serial Bus (USB) Specification 3.'''
    longdesc = '''0.'''
  [[register.field]]
    name = "CTC"
    bits = "3"
    type = "ro"
    shortdesc = '''Compliance Transition Capability (CTC) For a description of this standard USB register field, see the eXtensible Host Controller I nterface for Universal Serial Bus (USB) Specification 3.'''
    longdesc = '''0.'''
  [[register.field]]
    name = "FSC"
    bits = "2"
    type = "ro"
    shortdesc = '''Force Save Context Capability (FSC) For a description of this standard USB register field, see the eXtensible Host Controller I nterface for Universal Serial Bus (USB) Specification 3.'''
    longdesc = '''0.'''
  [[register.field]]
    name = "CMC"
    bits = "1"
    type = "ro"
    shortdesc = '''Configure Endpoint Command Max Exit Latency Too Large Capability (CMC) For a description of this standard USB register field, see the eXtensible Host Controller I nterface for Universal Serial Bus (USB) Specification 3.'''
    longdesc = '''0.'''
  [[register.field]]
    name = "U3C"
    bits = "0"
    type = "ro"
    shortdesc = '''U3 Entry Capability (U3C) For a description of this standard USB register field, see the eXtensible Host Controller I nterface for Universal Serial Bus (USB) Specification 3.'''
    longdesc = '''0.'''
[[register]]
  name = "USBCMD"
  type = "mixed"
  width = 32
  description = "USB Command Register For a description of this standard USB register field see the eXtensible Host Controller Interface for Universal Serial Bus (USB) Specification 3.0."
  default = "0x00000000"
  offset = "0x00000020"
  [[register.field]]
    name = "RESERVED"
    bits = "31:14"
    type = "ro"
  [[register.field]]
    name = "CME"
    bits = "13"
    type = "rw"
    shortdesc = '''CEM Enable For a description of this standard USB register field, see the eXtensible Host Controller Interface for Universal Serial Bus (USB) Specification 3.'''
    longdesc = '''0.'''
  [[register.field]]
    name = "RESERVED"
    bits = "12"
    type = "ro"
  [[register.field]]
    name = "EU3S"
    bits = "11"
    type = "rw"
    shortdesc = '''EU3S For a description of this standard USB register field, see the eXtensible Host Controller Interface for Universal Serial Bus (USB) Specification 3.'''
    longdesc = '''0.'''
  [[register.field]]
    name = "EWE"
    bits = "10"
    type = "rw"
    shortdesc = '''EWE For a description of this standard USB register field, see the eXtensible Host Controller Interface for Universal Serial Bus (USB) Specification 3.'''
    longdesc = '''0.'''
  [[register.field]]
    name = "CRS"
    bits = "9"
    type = "rw"
    shortdesc = '''Controller Restore State This command is similar to the USBCMD.'''
    longdesc = '''CRS bit in host mode and initiates the restore process. When software sets this bit to '1', the controller immediately sets DSTS.RSS to '1'. When the controller has finished the restore process, it sets DSTS.RSS to '0'. Note: When read, this field always returns '0'.'''
  [[register.field]]
    name = "CSS"
    bits = "8"
    type = "rw"
    shortdesc = '''Controller Save State This command is similar to the USBCMD.'''
    longdesc = '''CSS bit in host mode and initiates the save process. When software sets this bit to '1', the controller immediately sets DSTS.SSS to '1'. When the controller has finished the save process, it sets DSTS.SSS to '0'. Note: When read, this field always returns '0'.'''
  [[register.field]]
    name = "LHCRST"
    bits = "7"
    type = "rw"
    shortdesc = '''Light Host Controller Reset For a description of this standard USB register field, see the eXtensible Host Controller Interface for Universal Serial Bus (USB) Specification 3.'''
    longdesc = '''0. The following bits reset the internal logic of the host controller. Under soft reset, some CSR accesses may fail (Timeout). - HCRST - LHCRST Bit Bash register testing is not recommended.'''
  [[register.field]]
    name = "RESERVED"
    bits = "6:4"
    type = "ro"
  [[register.field]]
    name = "HSEE"
    bits = "3"
    type = "rw"
    shortdesc = '''HSEE For a description of this standard USB register field, see the eXtensible Host Controller Interface for Universal Serial Bus (USB) Specification 3.'''
    longdesc = '''0.'''
  [[register.field]]
    name = "INTE"
    bits = "2"
    type = "rw"
    shortdesc = '''INTE For a description of this standard USB register field, see the eXtensible Host Controller Interface for Universal Serial Bus (USB) Specification 3.'''
    longdesc = '''0.'''
  [[register.field]]
    name = "HCRST"
    bits = "1"
    type = "rw"
    shortdesc = '''HCRST The following bits reset the internal logic of the host controller.'''
    longdesc = '''Under soft reset, some CSR accesses may fail (Timeout). - HCRST - LHCRST Bit Bash register testing is not recommended.'''
  [[register.field]]
    name = "R_S"
    bits = "0"
    type = "rw"
    shortdesc = '''R_S For a description of this standard USB register field, see the eXtensible Host Controller Interface for Universal Serial Bus (USB) Specification 3.'''
    longdesc = '''0. Due to side-effects this reguster field is not recommended for Bit-Bash testing.'''
[[register]]
  name = "USBSTS"
  type = "mixed"
  width = 32
  description = "USB Status Register Bit Definitions For a description of this standard USB register field, see the eXtensible Host Controller Interface for Universal Serial Bus (USB) Specification 3.0."
  default = "0x00000000"
  offset = "0x00000024"
  [[register.field]]
    name = "RESERVED"
    bits = "31:13"
    type = "ro"
  [[register.field]]
    name = "HCE"
    bits = "12"
    type = "ro"
    shortdesc = '''Host Controller Error (HCE) - RO Default = 0.'''
    longdesc = ''''0' = No internal xHC error conditions exist and '1' = Internal xHC error condition. This flag must be set to indicate that an internal error condition has been detected which requires software to reset and reinitialize the xHC.'''
  [[register.field]]
    name = "CNR"
    bits = "11"
    type = "ro"
    shortdesc = '''Controller Not Ready (CNR) - RO Default = '1'.'''
    longdesc = ''''0' = Ready and'1' = Not Ready. Software must not write to thes Doorbell or Operational register of the xHC, other than the USBSTS register, until CNR = '0'. This flag is set by the xHC after a Chip Hardware Reset and cleared when the xHC is ready to begin accepting register writes. This flag remains cleared ('0') until the next Chip Hardware Reset.'''
  [[register.field]]
    name = "SRE"
    bits = "10"
    type = "wtc"
  [[register.field]]
    name = "RSS"
    bits = "9"
    type = "ro"
    shortdesc = '''Restore State Status This bit is similar to the USBSTS.'''
    longdesc = '''RSS in host mode. When the controller has finished the restore process, it completes the command by setting DSTS.RSS to '0'.'''
  [[register.field]]
    name = "SSS"
    bits = "8"
    type = "ro"
    shortdesc = '''Save State Status This bit is similar to the USBSTS.'''
    longdesc = '''SSS in host mode. When the controller has finished the save process, it completes the command by setting DSTS.SSS to '0'.'''
  [[register.field]]
    name = "RESERVED"
    bits = "7:5"
    type = "ro"
  [[register.field]]
    name = "PCD"
    bits = "4"
    type = "wtc"
  [[register.field]]
    name = "EINT"
    bits = "3"
    type = "wtc"
  [[register.field]]
    name = "HSE"
    bits = "2"
    type = "wtc"
    shortdesc = '''HSE For a description of this standard USB register field, see the eXtensible Host Controller Interface for Universal Serial Bus (USB) Specification 3.'''
    longdesc = '''0.'''
  [[register.field]]
    name = "RESERVED"
    bits = "1"
    type = "ro"
  [[register.field]]
    name = "HCH"
    bits = "0"
    type = "ro"
    shortdesc = '''HCH For a description of this standard USB register field, see the eXtensible Host Controller Interface for Universal Serial Bus (USB) Specification 3.'''
    longdesc = '''0.'''
[[register]]
  name = "PAGESIZE"
  type = "ro"
  width = 32
  description = "Page Size Register Bit Definitions Use this register to enable or disable the reporting of specific USB Device Notification Transaction Packets being received. A Notification Enable (Nx, where x = 0 to 15) flag is defined for each of the 16 possible device notification types. If a flag is set for a specific notification type, a Device Notification Event is generated when the respective notification packet is received. After reset, all notifications are disabled. This register is written as a Dword. Byte writes produce undefined results."
  default = "0x00000000"
  offset = "0x00000028"
  [[register.field]]
    name = "RESERVED"
    bits = "31:16"
    type = "ro"
  [[register.field]]
    name = "PAGE_SIZE"
    bits = "15:0"
    type = "ro"
[[register]]
  name = "DNCTRL"
  type = "mixed"
  width = 32
  description = "Device Notification Register Bit Definitions For a description of this standard USB register field see the eXtensible Host Controller Interface for Universal Serial Bus (USB) Specification 3.0."
  default = "0x00000000"
  offset = "0x00000034"
  [[register.field]]
    name = "RESERVED"
    bits = "31:16"
    type = "ro"
  [[register.field]]
    name = "N0_N15"
    bits = "15:0"
    type = "rw"
    shortdesc = '''N0_N15 For a description of this standard USB register field see the eXtensible Host Controller Interface for Universal Serial Bus (USB) Specification 3.'''
    longdesc = '''0.'''
[[register]]
  name = "CRCR_LO"
  type = "mixed"
  width = 32
  description = "CRCR_LO For a description of this standard USB register field, see the eXtensible Host Controller Interface for Universal Serial Bus (USB) Specification 3.0."
  default = "0x00000000"
  offset = "0x00000038"
  [[register.field]]
    name = "CMD_RING_PNTR"
    bits = "31:6"
    type = "rw"
    shortdesc = '''CMD_RING_PNTR For a description of this standard USB register field, see the eXtensible Host Controller Interface for Universal Serial Bus (USB) Specification 3.'''
    longdesc = '''0.'''
  [[register.field]]
    name = "RESERVED"
    bits = "5:4"
    type = "ro"
  [[register.field]]
    name = "CRR"
    bits = "3"
    type = "ro"
    shortdesc = '''CRR For a description of this standard USB register field, see the eXtensible Host Controller Interface for Universal Serial Bus (USB) Specification 3.'''
    longdesc = '''0.'''
  [[register.field]]
    name = "CA"
    bits = "2"
    type = "rw"
    shortdesc = '''CA For a description of this standard USB register field, see the eXtensible Host Controller Interface for Universal Serial Bus (USB) Specification 3.'''
    longdesc = '''0.'''
  [[register.field]]
    name = "CS"
    bits = "1"
    type = "rw"
    shortdesc = '''CS For a description of this standard USB register field, see the eXtensible Host Controller Interface for Universal Serial Bus (USB) Specification 3.'''
    longdesc = '''0.'''
  [[register.field]]
    name = "RCS"
    bits = "0"
    type = "rw"
    shortdesc = '''RCS For a description of this standard USB register field, see the eXtensible Host Controller Interface for Universal Serial Bus (USB) Specification 3.'''
    longdesc = '''0.'''
[[register]]
  name = "CRCR_HI"
  type = "rw"
  width = 32
  description = "CRCR_HI"
  default = "0x00000000"
  offset = "0x0000003C"
  [[register.field]]
    name = "CMD_RING_PNTR"
    bits = "31:0"
    type = "rw"
    shortdesc = '''COMMAND_RING_POINTER Reading this field always returns '0'.'''
    longdesc = '''For a description of this standard USB register field, see the eXtensible Host Controller Interface for Universal Serial Bus (USB) Specification 3.0.'''
[[register]]
  name = "DCBAAP_LO"
  type = "mixed"
  width = 32
  description = "DCBAAP_LO"
  default = "0x00000000"
  offset = "0x00000050"
  [[register.field]]
    name = "DEVICE_CONTEXT_BAAP"
    bits = "31:6"
    type = "rw"
    shortdesc = '''DEVICE_CONTEXT_BAAP For a description of this standard USB register field, see the eXtensible Host Controller Interface for Universal Serial Bus (USB) Specification 3.'''
    longdesc = '''0.'''
  [[register.field]]
    name = "RESERVED"
    bits = "5:0"
    type = "ro"
[[register]]
  name = "DCBAAP_HI"
  type = "rw"
  width = 32
  description = "DCBAAP_HI For a description of this standard USB register field, see the eXtensible Host Controller Interface for Universal Serial Bus (USB) Specification 3.0."
  default = "0x00000000"
  offset = "0x00000054"
  [[register.field]]
    name = "DEVICE_CONTEXT_BAAP"
    bits = "31:0"
    type = "rw"
[[register]]
  name = "CONFIG"
  type = "mixed"
  width = 32
  description = "Configure Register Bit Definitions This register is in the Aux Power well. It is only reset by platform hardware during a cold reset or in response to a Host Controller Reset (HCRST). The initial conditions of a port are described in section 4.19 of the DWC Cores SuperSpeed USB 3.0 Controller Databook."
  default = "0x00000000"
  offset = "0x00000058"
  [[register.field]]
    name = "RESERVED"
    bits = "31:10"
    type = "ro"
  [[register.field]]
    name = "CIE"
    bits = "9"
    type = "rw"
    shortdesc = '''U3 Entry Enable For a description of this standard USB register field, see the eXtensible Host Controller Interface for Universal Serial Bus (USB) Specification 3.'''
    longdesc = '''0.'''
  [[register.field]]
    name = "U3E"
    bits = "8"
    type = "rw"
    shortdesc = '''U3 Entry Enable For a description of this standard USB register field, see the eXtensible Host Controller Interface for Universal Serial Bus (USB) Specification 3.'''
    longdesc = '''0.'''
  [[register.field]]
    name = "MAXSLOTSEN"
    bits = "7:0"
    type = "rw"
    shortdesc = '''MAXSLOTSEN For a description of this standard USB register field, see the eXtensible Host Controller Interface for Universal Serial Bus (USB) Specification 3.'''
    longdesc = '''0.'''
[[register]]
  name = "PORTSC_20"
  type = "mixed"
  width = 32
  description = "Port Status and Control Register Bit Definitions The PORTSC Register Access fails (Timeout) if the UTMI/ULPI clock is not running or one of the following bits is asserted. - PR - ORC"
  default = "0x000002A0"
  offset = "0x00000420"
  [[register.field]]
    name = "RESERVED"
    bits = "31"
    type = "ro"
    shortdesc = '''Reserved For a description of this standard USB register field, see the eXtensible Host Controller Interface for Universal Serial Bus (USB) Specification 3.'''
    longdesc = '''0. Programming this field with random data will cause side effect i.e. Register Access will fail (Timeout) if the pipe clock is not running or reset is asserted. Bit Bash register testing is not recommended.'''
  [[register.field]]
    name = "DR"
    bits = "30"
    type = "ro"
    shortdesc = '''Reset Value For a description of this standard USB register field, see the eXtensible Host Controller Interface for Universal Serial Bus (USB) Specification 3.'''
    longdesc = '''0.'''
  [[register.field]]
    name = "RESERVED"
    bits = "29:28"
    type = "ro"
  [[register.field]]
    name = "WOE"
    bits = "27"
    type = "rw"
    shortdesc = '''WOE For a description of this standard USB register field, see the eXtensible Host Controller Interface for Universal Serial Bus (USB) Specification 3.'''
    longdesc = '''0.'''
  [[register.field]]
    name = "WDE"
    bits = "26"
    type = "rw"
    shortdesc = '''WDE For a description of this standard USB register field, see the eXtensible Host Controller Interface for Universal Serial Bus (USB) Specification 3.'''
    longdesc = '''0.'''
  [[register.field]]
    name = "WCE"
    bits = "25"
    type = "rw"
    shortdesc = '''WCE For a description of this standard USB register field, see the eXtensible Host Controller Interface for Universal Serial Bus (USB) Specification 3.'''
    longdesc = '''0.'''
  [[register.field]]
    name = "CAS"
    bits = "24"
    type = "ro"
    shortdesc = '''Cold Attach Status For a description of this standard USB register field, see the eXtensible Host Controller Interface for Universal Serial Bus (USB) Specification 3.'''
    longdesc = '''0.'''
  [[register.field]]
    name = "RESERVED"
    bits = "23"
    type = "ro"
    shortdesc = '''Reserved For a description of this standard USB register field, see the eXtensible Host Controller Interface for Universal Serial Bus (USB) Specification 3.'''
    longdesc = '''0.'''
  [[register.field]]
    name = "PLC"
    bits = "22"
    type = "wtc"
    shortdesc = '''PLC For a description of this standard USB register field, see the eXtensible Host Controller Interface for Universal Serial Bus (USB) Specification 3.'''
    longdesc = '''0.'''
  [[register.field]]
    name = "PRC"
    bits = "21"
    type = "wtc"
    shortdesc = '''PRC For a description of this standard USB register field, see the eXtensible Host Controller Interface for Universal Serial Bus (USB) Specification 3.'''
    longdesc = '''0. Programming this field with random data will cause side effect. Bit Bash register testing is not recommended.'''
  [[register.field]]
    name = "OCC"
    bits = "20"
    type = "wtc"
    shortdesc = '''OCC For a description of this standard USB register field, see the eXtensible Host Controller Interface for Universal Serial Bus (USB) Specification 3.'''
    longdesc = '''0.'''
  [[register.field]]
    name = "RESERVED"
    bits = "19"
    type = "wtc"
    shortdesc = '''WRC For a description of this standard USB register field, see the eXtensible Host Controller Interface for Universal Serial Bus (USB) Specification 3.'''
    longdesc = '''0.'''
  [[register.field]]
    name = "PEC"
    bits = "18"
    type = "wtc"
    shortdesc = '''PEC For a description of this standard USB register field, see the eXtensible Host Controller Interface for Universal Serial Bus (USB) Specification 3.'''
    longdesc = '''0.'''
  [[register.field]]
    name = "CSC"
    bits = "17"
    type = "wtc"
    shortdesc = '''CSC For a description of this standard USB register field, see the eXtensible Host Controller Interface for Universal Serial Bus (USB) Specification 3.'''
    longdesc = '''0.'''
  [[register.field]]
    name = "LWS"
    bits = "16"
    type = "rw"
    shortdesc = '''LWS For a description of this standard USB register field, see the eXtensible Host Controller Interface for Universal Serial Bus (USB) Specification 3.'''
    longdesc = '''0.'''
  [[register.field]]
    name = "PIC"
    bits = "15:14"
    type = "rw"
    shortdesc = '''PIC #The write has no effect if Port Indicators (PIND) bit in the HCCPARAMS1 register is a 0 set_register_field_attribute DWC_usb3_map/DWC_usb3_block_Host_Cntrl_Port_Reg_Set/PORTSC_20_REGS/PORTSC_20/PIC VolatileMemory 1 For a description of this standard USB register field, see the eXtensible Host Controller Interface for Universal Serial Bus (USB) Specification 3.'''
    longdesc = '''0.'''
  [[register.field]]
    name = "PORTSPEED"
    bits = "13:10"
    type = "ro"
    shortdesc = '''PORTSPEED For a description of this standard USB register field, see the eXtensible Host Controller Interface for Universal Serial Bus (USB) Specification 3.'''
    longdesc = '''0.'''
  [[register.field]]
    name = "PP"
    bits = "9"
    type = "rw"
    shortdesc = '''PP For a description of this standard USB register field, see the eXtensible Host Controller Interface for Universal Serial Bus (USB) Specification 3.'''
    longdesc = '''0.'''
  [[register.field]]
    name = "PLS"
    bits = "8:5"
    type = "rw"
    shortdesc = '''PLS For a description of this standard USB register field, see the eXtensible Host Controller Interface for Universal Serial Bus (USB) Specification 3.'''
    longdesc = '''0.'''
  [[register.field]]
    name = "PR"
    bits = "4"
    type = "rw"
    shortdesc = '''PR set_register_field_attribute DWC_usb3_map/DWC_usb3_block_Host_Cntrl_Port_Reg_Set/PORTSC_20_REGS/PORTSC_20/PR VolatileMemory 1 Programming this field with random data will cause side effect.'''
    longdesc = '''Bit Bash register testing is not recommended.'''
  [[register.field]]
    name = "OCA"
    bits = "3"
    type = "ro"
    shortdesc = '''OCA For a description of this standard USB register field, see the eXtensible Host Controller Interface for Universal Serial Bus (USB) Specification 3.'''
    longdesc = '''0.'''
  [[register.field]]
    name = "RESERVED"
    bits = "2"
    type = "ro"
  [[register.field]]
    name = "PED"
    bits = "1"
    type = "wtc"
    shortdesc = '''PED For a description of this standard USB register field, see the eXtensible Host Controller Interface for Universal Serial Bus (USB) Specification 3.'''
    longdesc = '''0.'''
  [[register.field]]
    name = "CCS"
    bits = "0"
    type = "ro"
    shortdesc = '''CCS For a description of this standard USB register field, see the eXtensible Host Controller Interface for Universal Serial Bus (USB) Specification 3.'''
    longdesc = '''0.'''
[[register]]
  name = "PORTPMSC_20"
  type = "mixed"
  width = 32
  description = "USB3 Port Power Management Status and Control Register Bit Definitions This register is in the Aux Power well. It is only reset by platform hardware during a cold reset or in response to a Host Controller Reset (HCRST). Programming this field with random data will cause side effect i.e. Register Access will fail (Timeout) if the pipe clock is not running or reset is asserted. Bit Bash register testing is not recommended."
  default = "0x00000000"
  offset = "0x00000424"
  [[register.field]]
    name = "PRTTSTCTRL"
    bits = "31:28"
    type = "rw"
    shortdesc = '''Port Test Control For a description of this standard USB register field, see the eXtensible Host Controller Interface for Universal Serial Bus (USB) Specification 3.'''
    longdesc = '''0.'''
  [[register.field]]
    name = "RESERVED"
    bits = "27:17"
    type = "ro"
  [[register.field]]
    name = "HLE"
    bits = "16"
    type = "rw"
    shortdesc = '''Port Test Control For a description of this standard USB register field, see the eXtensible Host Controller Interface for Universal Serial Bus (USB) Specification 3.'''
    longdesc = '''0.'''
  [[register.field]]
    name = "L1DSLOT"
    bits = "15:8"
    type = "rw"
    shortdesc = '''L1DSLOT For a description of this standard USB register field, see the eXtensible Host Controller Interface for Universal Serial Bus (USB) Specification 3.'''
    longdesc = '''0.'''
  [[register.field]]
    name = "HIRD"
    bits = "7:4"
    type = "rw"
    shortdesc = '''Host Initiated Resume Duration (HIRD) - RW.'''
    longdesc = '''Default = '0'. System software sets this field to indicate to the recipient device how long the xHC will drive resume if it (the xHC) initiates an exit from L1. The HIRD value is encoded as follows: Value Description 0h 50us. (default) 1h 125us. 2h 200us. Fh 1.175 ms. The value of 0000b is interpreted as 50us. Each incrementing value up adds 75us. to the previous value. For example, 0001b is 125us, 0010b is 200us and so on. Based on this rule, the maximum value resume drive time is at encoding value 1111b which represents 1.2ms. Note that the HIRD field is used by both software and hardware controlled LPM. Refer to section 4.23.5.1.1 for more information on HIRD use. Refer to Section 4.1 of the USB2 LPM spec for more information on the use of the HIRD field.'''
  [[register.field]]
    name = "RWE"
    bits = "3"
    type = "rw"
    shortdesc = '''Port Test Control For a description of this standard USB register field, see the eXtensible Host Controller Interface for Universal Serial Bus (USB) Specification 3.'''
    longdesc = '''0.'''
  [[register.field]]
    name = "L1S"
    bits = "2:0"
    type = "ro"
    shortdesc = '''L1 Status (L1S) - RO.'''
    longdesc = '''Default = 0. This field is used by software to determine whether an L1-based suspend request (LMP transaction) was successful, specifically: Value Meaning 0 Invalid - This field is ignored by software. - 1 Success - Port successfully transitioned to L1 (ACK) - 2 Not Yet - Device is unable to enter L1 at this time (NYET) - 3 Not Supported -Device does not support L1 transitions (STALL) - 4 Timeout/Error -Device failed to respond to the LPM Transaction or an error occurred - 5-7 Reserved The value of this field is only valid when the port resides in the L0 or L1 state (PLS = '0' or '2'). Refer to section 4.23.5.1.1 for more information.'''
[[register]]
  name = "PORTLI_20"
  type = "ro"
  width = 32
  description = "Port Link Info Register Programming this field with random data will cause side effect i.e. Register Access will fail (Timeout) if the pipe clock is not running or reset is asserted. Bit Bash register testing is not recommended."
  default = "0x00000000"
  offset = "0x00000428"
  [[register.field]]
    name = "RESERVED"
    bits = "31:16"
    type = "ro"
  [[register.field]]
    name = "RESERVED"
    bits = "15:0"
    type = "ro"
    shortdesc = '''Reserved For a description of this standard USB register field, see the eXtensible Host Controller Interface for Universal Serial Bus (USB) Specification 3.'''
    longdesc = '''0.'''
[[register]]
  name = "PORTHLPMC_20"
  type = "mixed"
  width = 32
  description = "USB2 Port Hardware LPM Control Register Bit Definitions For a description of this standard USB register field, see the eXtensible Host Controller Interface for Universal Serial Bus (USB) Specification 3.0."
  default = "0x00000000"
  offset = "0x0000042C"
  [[register.field]]
    name = "RESERVED"
    bits = "31:14"
    type = "ro"
    shortdesc = '''Reserved For a description of this standard USB register field, see the eXtensible Host Controller Interface for Universal Serial Bus (USB) Specification 3.'''
    longdesc = '''0.'''
  [[register.field]]
    name = "HIRDD"
    bits = "13:10"
    type = "rw"
  [[register.field]]
    name = "L1_TIMEOUT"
    bits = "9:2"
    type = "rw"
    shortdesc = '''PORTHLPMC_20 L1_TIMEOUT.'''
    longdesc = '''For a description of this standard USB register field, see the eXtensible Host Controller Interface for Universal Serial Bus (USB) Specification 3.0.'''
  [[register.field]]
    name = "HIRDM"
    bits = "1:0"
    type = "rw"
    shortdesc = '''Host Initiated Resume Duration Mode (HIRDM) - RWS.'''
    longdesc = '''Default = 0h. Indicates which HIRD value must be used. The following are permissible values: Value Description 0 Initiate L1 using HIRD only on timeout. (default) 1 Initiate L1 using HIRDD on timeout. If rejected by device, initiate L1 using HIRD. 3-2 Reserved.'''
[[register]]
  name = "PORTSC_30"
  type = "mixed"
  width = 32
  description = "Port Status and Control Register Bit Definitions The PORTSC Register Access fails (Timeout) if the UTMI/ULPI clock is not running or one of the following bits is asserted. - PR - ORC - WPR"
  default = "0x000002A0"
  offset = "0x00000430"
  [[register.field]]
    name = "WPR"
    bits = "31"
    type = "rw"
    shortdesc = '''Reset Value For a description of this standard USB register field, see the eXtensible Host Controller Interface for Universal Serial Bus (USB) Specification 3.'''
    longdesc = '''0. Programming this field with random data will cause side effect i.e. Register Access will fail (Timeout) if the pipe clock is not running or reset is asserted. Bit Bash register testing is not recommended.'''
  [[register.field]]
    name = "DR"
    bits = "30"
    type = "ro"
    shortdesc = '''Reset Value For a description of this standard USB register field, see the eXtensible Host Controller Interface for Universal Serial Bus (USB) Specification 3.'''
    longdesc = '''0.'''
  [[register.field]]
    name = "RESERVED"
    bits = "29:28"
    type = "ro"
  [[register.field]]
    name = "WOE"
    bits = "27"
    type = "rw"
    shortdesc = '''WOE For a description of this standard USB register field, see the eXtensible Host Controller Interface for Universal Serial Bus (USB) Specification 3.'''
    longdesc = '''0.'''
  [[register.field]]
    name = "WDE"
    bits = "26"
    type = "rw"
    shortdesc = '''WDE For a description of this standard USB register field, see the eXtensible Host Controller Interface for Universal Serial Bus (USB) Specification 3.'''
    longdesc = '''0.'''
  [[register.field]]
    name = "WCE"
    bits = "25"
    type = "rw"
    shortdesc = '''WCE For a description of this standard USB register field, see the eXtensible Host Controller Interface for Universal Serial Bus (USB) Specification 3.'''
    longdesc = '''0.'''
  [[register.field]]
    name = "CAS"
    bits = "24"
    type = "ro"
    shortdesc = '''Cold Attach Status For a description of this standard USB register field, see the eXtensible Host Controller Interface for Universal Serial Bus (USB) Specification 3.'''
    longdesc = '''0.'''
  [[register.field]]
    name = "CEC"
    bits = "23"
    type = "wtc"
    shortdesc = '''CEC For a description of this standard USB register field, see the eXtensible Host Controller Interface for Universal Serial Bus (USB) Specification 3.'''
    longdesc = '''0.'''
  [[register.field]]
    name = "PLC"
    bits = "22"
    type = "wtc"
    shortdesc = '''PLC For a description of this standard USB register field, see the eXtensible Host Controller Interface for Universal Serial Bus (USB) Specification 3.'''
    longdesc = '''0.'''
  [[register.field]]
    name = "PRC"
    bits = "21"
    type = "wtc"
    shortdesc = '''PRC For a description of this standard USB register field, see the eXtensible Host Controller Interface for Universal Serial Bus (USB) Specification 3.'''
    longdesc = '''0. Programming this field with random data will cause side effect. Bit Bash register testing is not recommended.'''
  [[register.field]]
    name = "OCC"
    bits = "20"
    type = "wtc"
    shortdesc = '''OCC For a description of this standard USB register field, see the eXtensible Host Controller Interface for Universal Serial Bus (USB) Specification 3.'''
    longdesc = '''0.'''
  [[register.field]]
    name = "WRC"
    bits = "19"
    type = "wtc"
    shortdesc = '''WRC For a description of this standard USB register field, see the eXtensible Host Controller Interface for Universal Serial Bus (USB) Specification 3.'''
    longdesc = '''0.'''
  [[register.field]]
    name = "PEC"
    bits = "18"
    type = "wtc"
    shortdesc = '''PEC For a description of this standard USB register field, see the eXtensible Host Controller Interface for Universal Serial Bus (USB) Specification 3.'''
    longdesc = '''0.'''
  [[register.field]]
    name = "CSC"
    bits = "17"
    type = "wtc"
    shortdesc = '''CSC For a description of this standard USB register field, see the eXtensible Host Controller Interface for Universal Serial Bus (USB) Specification 3.'''
    longdesc = '''0.'''
  [[register.field]]
    name = "LWS"
    bits = "16"
    type = "rw"
    shortdesc = '''LWS For a description of this standard USB register field, see the eXtensible Host Controller Interface for Universal Serial Bus (USB) Specification 3.'''
    longdesc = '''0.'''
  [[register.field]]
    name = "PIC"
    bits = "15:14"
    type = "rw"
    shortdesc = '''PIC #The write has no effect if Port Indicators (PIND) bit in the HCCPARAMS1 register is a 0 set_register_field_attribute DWC_usb3_map/DWC_usb3_block_Host_Cntrl_Port_Reg_Set/PORTSC_30_REGS/PORTSC_30/PIC VolatileMemory 1 For a description of this standard USB register field, see the eXtensible Host Controller Interface for Universal Serial Bus (USB) Specification 3.'''
    longdesc = '''0.'''
  [[register.field]]
    name = "PORTSPEED"
    bits = "13:10"
    type = "ro"
    shortdesc = '''PORTSPEED For a description of this standard USB register field, see the eXtensible Host Controller Interface for Universal Serial Bus (USB) Specification 3.'''
    longdesc = '''0.'''
  [[register.field]]
    name = "PP"
    bits = "9"
    type = "rw"
    shortdesc = '''PP For a description of this standard USB register field, see the eXtensible Host Controller Interface for Universal Serial Bus (USB) Specification 3.'''
    longdesc = '''0.'''
  [[register.field]]
    name = "PLS"
    bits = "8:5"
    type = "rw"
    shortdesc = '''PLS For a description of this standard USB register field, see the eXtensible Host Controller Interface for Universal Serial Bus (USB) Specification 3.'''
    longdesc = '''0.'''
  [[register.field]]
    name = "PR"
    bits = "4"
    type = "rw"
    shortdesc = '''PR set_register_field_attribute DWC_usb3_map/DWC_usb3_block_Host_Cntrl_Port_Reg_Set/PORTSC_30_REGS/PORTSC_30/PR VolatileMemory 1 Programming this field with random data will cause side effect.'''
    longdesc = '''Bit Bash register testing is not recommended.'''
  [[register.field]]
    name = "OCA"
    bits = "3"
    type = "ro"
    shortdesc = '''OCA For a description of this standard USB register field, see the eXtensible Host Controller Interface for Universal Serial Bus (USB) Specification 3.'''
    longdesc = '''0.'''
  [[register.field]]
    name = "RESERVED"
    bits = "2"
    type = "ro"
  [[register.field]]
    name = "PED"
    bits = "1"
    type = "wtc"
    shortdesc = '''PED For a description of this standard USB register field, see the eXtensible Host Controller Interface for Universal Serial Bus (USB) Specification 3.'''
    longdesc = '''0.'''
  [[register.field]]
    name = "CCS"
    bits = "0"
    type = "ro"
    shortdesc = '''CCS For a description of this standard USB register field, see the eXtensible Host Controller Interface for Universal Serial Bus (USB) Specification 3.'''
    longdesc = '''0.'''
[[register]]
  name = "PORTPMSC_30"
  type = "mixed"
  width = 32
  description = "USB3 Port Power Management Status and Control Register Bit Definitions This register is in the Aux Power well. It is only reset by platform hardware during a cold reset or in response to a Host Controller Reset (HCRST). Programming this field with random data will cause side effect i.e. Register Access will fail (Timeout) if the pipe clock is not running or reset is asserted. Bit Bash register testing is not recommended."
  default = "0x00000000"
  offset = "0x00000434"
  [[register.field]]
    name = "RESERVED"
    bits = "31:17"
    type = "ro"
  [[register.field]]
    name = "FLA"
    bits = "16"
    type = "rw"
    shortdesc = '''FLA For a description of this standard USB register field, see the eXtensible Host Controller Interface for Universal Serial Bus (USB) Specification 3.'''
    longdesc = '''0.'''
  [[register.field]]
    name = "U2_TIMEOUT"
    bits = "15:8"
    type = "rw"
    shortdesc = '''U2_TIMEOUT For a description of this standard USB register field, see the eXtensible Host Controller Interface for Universal Serial Bus (USB) Specification 3.'''
    longdesc = '''0.'''
  [[register.field]]
    name = "U1_TIMEOUT"
    bits = "7:0"
    type = "rw"
    shortdesc = '''U1_TIMEOUT For a description of this standard USB register field, see the eXtensible Host Controller Interface for Universal Serial Bus (USB) Specification 3.'''
    longdesc = '''0.'''
[[register]]
  name = "PORTLI_30"
  type = "ro"
  width = 32
  description = "Port Link Info Register Programming this field with random data will cause side effect i.e. Register Access will fail (Timeout) if the pipe clock is not running or reset is asserted. Bit Bash register testing is not recommended."
  default = "0x00000000"
  offset = "0x00000438"
  [[register.field]]
    name = "RESERVED"
    bits = "31:16"
    type = "ro"
  [[register.field]]
    name = "LINK_ERROR_COUNT"
    bits = "15:0"
    type = "ro"
    shortdesc = '''LINK_ERROR_COUNT For a description of this standard USB register field, see the eXtensible Host Controller Interface for Universal Serial Bus (USB) Specification 3.'''
    longdesc = '''0.'''
[[register]]
  name = "PORTHLPMC_30"
  type = "ro"
  width = 32
  description = "USB2 Port Hardware LPM Control Register Bit Definitions For a description of this standard USB register field, see the eXtensible Host Controller Interface for Universal Serial Bus (USB) Specification 3.0."
  default = "0x00000000"
  offset = "0x0000043C"
  [[register.field]]
    name = "RESERVED"
    bits = "31:0"
    type = "ro"
    shortdesc = '''Reserved For a description of this standard USB register field, see the eXtensible Host Controller Interface for Universal Serial Bus (USB) Specification 3.'''
    longdesc = '''0.'''
[[register]]
  name = "MFINDEX"
  type = "ro"
  width = 32
  description = "Microframe Index Register Bit Definitions For a description of this standard USB register field, see the eXtensible Host Controller Interface for Universal Serial Bus (USB) Specification 3.0."
  default = "0x00000000"
  offset = "0x00000440"
  [[register.field]]
    name = "RESERVED"
    bits = "31:14"
    type = "ro"
  [[register.field]]
    name = "MICROFRAME_INDEX"
    bits = "13:0"
    type = "ro"
    shortdesc = '''MICROFRAME_INDEX For a description of this standard USB register field, see the eXtensible Host Controller Interface for Universal Serial Bus (USB) Specification 3.'''
    longdesc = '''0.'''
[[register]]
  name = "RSVDZ"
  type = "ro"
  width = 32
  description = "RsvdZ For a description of this standard USB register field, see the eXtensible Host Controller Interface for Universal Serial Bus (USB) Specification 3.0."
  default = "0x00000000"
  offset = "0x00000444"
  [[register.field]]
    name = "RESERVED"
    bits = "31:0"
    type = "ro"
[[register]]
  name = "IMAN_0"
  type = "mixed"
  width = 32
  description = "Interrupter Management Register Bit Definitions For a description of this standard USB register field, see the eXtensible Host Controller Interface for Universal Serial Bus (USB) Specification 3.0. Instance 0 of an array of 4."
  default = "0x00000000"
  offset = "0x00000460"
  [[register.field]]
    name = "RESERVED"
    bits = "31:2"
    type = "ro"
  [[register.field]]
    name = "IE"
    bits = "1"
    type = "rw"
    shortdesc = '''IE For a description of this standard USB register field, see the eXtensible Host Controller Interface for Universal Serial Bus (USB) Specification 3.'''
    longdesc = '''0.'''
  [[register.field]]
    name = "IP"
    bits = "0"
    type = "wtc"
    shortdesc = '''IP Interrupt Pending For a description of this standard USB register field, see the eXtensible Host Controller Interface for Universal Serial Bus (USB) Specification 3.'''
    longdesc = '''0.'''
[[register]]
  name = "IMOD_0"
  type = "rw"
  width = 32
  description = "Interrupter Moderation Register The software may use this register to pace (or even out) the delivery of interrupts to the host CPU. This register provides a guaranteed inter-interrupt delay between interrupts asserted by the xHC, regardless of USB traffic conditions. To independently validate configuration settings, software may use the following algorithm to convert the inter-interrupt Interval value to the common 'interrupts/sec' performance metric. Instance 0 of an array of 4."
  default = "0x00000FA0"
  offset = "0x00000464"
  [[register.field]]
    name = "IMODC"
    bits = "31:16"
    type = "rw"
    shortdesc = '''Interrupt Moderation Counter (IMODC) - RW.'''
    longdesc = '''Default = undefined. Down counter. Loaded with the IMODI value whenever IP is cleared to '0', counts down to '0', and stops. The associated interrupt is signaled whenever this counter is '0', the Event Ring is not empty, the IE and IP flags = '1', and EHB = '0'. This counter may be directly written by software at any time to alter the interrupt rate.'''
  [[register.field]]
    name = "IMODI"
    bits = "15:0"
    type = "rw"
    shortdesc = '''Interrupt Moderation Interval (IMODI) - RW.'''
    longdesc = '''Default = '4000' (~1ms). Minimum inter-interrupt interval. The interval is specified in 250ns increments. A value of '0' disables interrupt throttling logic and interrupts is generated immediately if IP = '0', EHB = '0', and the Event Ring is not empty.'''
[[register]]
  name = "ERSTSZ_0"
  type = "mixed"
  width = 32
  description = "Event Ring Segment Table Size Register Bit Definitions For a description of this standard USB register field, see the eXtensible Host Controller Interface for Universal Serial Bus (USB) Specification 3.0. Instance 0 of an array of 4."
  default = "0x00000000"
  offset = "0x00000468"
  [[register.field]]
    name = "RESERVED"
    bits = "31:16"
    type = "ro"
  [[register.field]]
    name = "ERS_TABLE_SIZE"
    bits = "15:0"
    type = "rw"
    shortdesc = '''ERS_TABLE_SIZE For a description of this standard USB register field, see the eXtensible Host Controller Interface for Universal Serial Bus (USB) Specification 3.'''
    longdesc = '''0.'''
[[register]]
  name = "RSVDP_0"
  type = "ro"
  width = 32
  description = "RsvdP Instance 0 of an array of 4."
  default = "0x00000000"
  offset = "0x0000046C"
  [[register.field]]
    name = "RESERVED"
    bits = "31:0"
    type = "ro"
[[register]]
  name = "ERSTBA_LO_0"
  type = "mixed"
  width = 32
  description = "ERSTBA_LO Instance 0 of an array of 4."
  default = "0x00000000"
  offset = "0x00000470"
  [[register.field]]
    name = "ERS_TABLE_BAR"
    bits = "31:6"
    type = "rw"
  [[register.field]]
    name = "RESERVED"
    bits = "5:0"
    type = "ro"
[[register]]
  name = "ERSTBA_HI_0"
  type = "rw"
  width = 32
  description = "ERSTBA_HI Instance 0 of an array of 4."
  default = "0x00000000"
  offset = "0x00000474"
  [[register.field]]
    name = "ERS_TABLE_BAR"
    bits = "31:0"
    type = "rw"
    shortdesc = '''ERS_TABLE_BAR For a description of this standard USB register field, see the eXtensible Host Controller Interface for Universal Serial Bus (USB) Specification 3.'''
    longdesc = '''0.'''
[[register]]
  name = "ERDP_LO_0"
  type = "mixed"
  width = 32
  description = "ERDP_LO For a description of this standard USB register field, see the eXtensible Host Controller Interface for Universal Serial Bus (USB) Specification 3.0. Instance 0 of an array of 4."
  default = "0x00000000"
  offset = "0x00000478"
  [[register.field]]
    name = "ERD_PNTR"
    bits = "31:4"
    type = "rw"
    shortdesc = '''ERD_PNTR For a description of this standard USB register field, see the eXtensible Host Controller Interface for Universal Serial Bus (USB) Specification 3.'''
    longdesc = '''0.'''
  [[register.field]]
    name = "EHB"
    bits = "3"
    type = "wtc"
  [[register.field]]
    name = "DESI"
    bits = "2:0"
    type = "rw"
    shortdesc = '''DESI - For a description of this standard USB register field, see the eXtensible Host Controller Interface for Universal Serial Bus (USB) Specification 3.'''
    longdesc = '''0.'''
[[register]]
  name = "ERDP_HI_0"
  type = "rw"
  width = 32
  description = "ERDP_HI Instance 0 of an array of 4."
  default = "0x00000000"
  offset = "0x0000047C"
  [[register.field]]
    name = "ERD_PNTR"
    bits = "31:0"
    type = "rw"
    shortdesc = '''ERD_PNTR For a description of this standard USB register field, see the eXtensible Host Controller Interface for Universal Serial Bus (USB) Specification 3.'''
    longdesc = '''0.'''
[[register]]
  name = "IMAN_1"
  type = "mixed"
  width = 32
  description = "Interrupter Management Register Bit Definitions For a description of this standard USB register field, see the eXtensible Host Controller Interface for Universal Serial Bus (USB) Specification 3.0. Instance 1 of an array of 4."
  default = "0x00000000"
  offset = "0x00000480"
  [[register.field]]
    name = "RESERVED"
    bits = "31:2"
    type = "ro"
  [[register.field]]
    name = "IE"
    bits = "1"
    type = "rw"
    shortdesc = '''IE For a description of this standard USB register field, see the eXtensible Host Controller Interface for Universal Serial Bus (USB) Specification 3.'''
    longdesc = '''0.'''
  [[register.field]]
    name = "IP"
    bits = "0"
    type = "wtc"
    shortdesc = '''IP Interrupt Pending For a description of this standard USB register field, see the eXtensible Host Controller Interface for Universal Serial Bus (USB) Specification 3.'''
    longdesc = '''0.'''
[[register]]
  name = "IMOD_1"
  type = "rw"
  width = 32
  description = "Interrupter Moderation Register The software may use this register to pace (or even out) the delivery of interrupts to the host CPU. This register provides a guaranteed inter-interrupt delay between interrupts asserted by the xHC, regardless of USB traffic conditions. To independently validate configuration settings, software may use the following algorithm to convert the inter-interrupt Interval value to the common 'interrupts/sec' performance metric. Instance 1 of an array of 4."
  default = "0x00000FA0"
  offset = "0x00000484"
  [[register.field]]
    name = "IMODC"
    bits = "31:16"
    type = "rw"
    shortdesc = '''Interrupt Moderation Counter (IMODC) - RW.'''
    longdesc = '''Default = undefined. Down counter. Loaded with the IMODI value whenever IP is cleared to '0', counts down to '0', and stops. The associated interrupt is signaled whenever this counter is '0', the Event Ring is not empty, the IE and IP flags = '1', and EHB = '0'. This counter may be directly written by software at any time to alter the interrupt rate.'''
  [[register.field]]
    name = "IMODI"
    bits = "15:0"
    type = "rw"
    shortdesc = '''Interrupt Moderation Interval (IMODI) - RW.'''
    longdesc = '''Default = '4000' (~1ms). Minimum inter-interrupt interval. The interval is specified in 250ns increments. A value of '0' disables interrupt throttling logic and interrupts is generated immediately if IP = '0', EHB = '0', and the Event Ring is not empty.'''
[[register]]
  name = "ERSTSZ_1"
  type = "mixed"
  width = 32
  description = "Event Ring Segment Table Size Register Bit Definitions For a description of this standard USB register field, see the eXtensible Host Controller Interface for Universal Serial Bus (USB) Specification 3.0. Instance 1 of an array of 4."
  default = "0x00000000"
  offset = "0x00000488"
  [[register.field]]
    name = "RESERVED"
    bits = "31:16"
    type = "ro"
  [[register.field]]
    name = "ERS_TABLE_SIZE"
    bits = "15:0"
    type = "rw"
    shortdesc = '''ERS_TABLE_SIZE For a description of this standard USB register field, see the eXtensible Host Controller Interface for Universal Serial Bus (USB) Specification 3.'''
    longdesc = '''0.'''
[[register]]
  name = "RSVDP_1"
  type = "ro"
  width = 32
  description = "RsvdP Instance 1 of an array of 4."
  default = "0x00000000"
  offset = "0x0000048C"
  [[register.field]]
    name = "RESERVED"
    bits = "31:0"
    type = "ro"
[[register]]
  name = "ERSTBA_LO_1"
  type = "mixed"
  width = 32
  description = "ERSTBA_LO Instance 1 of an array of 4."
  default = "0x00000000"
  offset = "0x00000490"
  [[register.field]]
    name = "ERS_TABLE_BAR"
    bits = "31:6"
    type = "rw"
  [[register.field]]
    name = "RESERVED"
    bits = "5:0"
    type = "ro"
[[register]]
  name = "ERSTBA_HI_1"
  type = "rw"
  width = 32
  description = "ERSTBA_HI Instance 1 of an array of 4."
  default = "0x00000000"
  offset = "0x00000494"
  [[register.field]]
    name = "ERS_TABLE_BAR"
    bits = "31:0"
    type = "rw"
    shortdesc = '''ERS_TABLE_BAR For a description of this standard USB register field, see the eXtensible Host Controller Interface for Universal Serial Bus (USB) Specification 3.'''
    longdesc = '''0.'''
[[register]]
  name = "ERDP_LO_1"
  type = "mixed"
  width = 32
  description = "ERDP_LO For a description of this standard USB register field, see the eXtensible Host Controller Interface for Universal Serial Bus (USB) Specification 3.0. Instance 1 of an array of 4."
  default = "0x00000000"
  offset = "0x00000498"
  [[register.field]]
    name = "ERD_PNTR"
    bits = "31:4"
    type = "rw"
    shortdesc = '''ERD_PNTR For a description of this standard USB register field, see the eXtensible Host Controller Interface for Universal Serial Bus (USB) Specification 3.'''
    longdesc = '''0.'''
  [[register.field]]
    name = "EHB"
    bits = "3"
    type = "wtc"
  [[register.field]]
    name = "DESI"
    bits = "2:0"
    type = "rw"
    shortdesc = '''DESI - For a description of this standard USB register field, see the eXtensible Host Controller Interface for Universal Serial Bus (USB) Specification 3.'''
    longdesc = '''0.'''
[[register]]
  name = "ERDP_HI_1"
  type = "rw"
  width = 32
  description = "ERDP_HI Instance 1 of an array of 4."
  default = "0x00000000"
  offset = "0x0000049C"
  [[register.field]]
    name = "ERD_PNTR"
    bits = "31:0"
    type = "rw"
    shortdesc = '''ERD_PNTR For a description of this standard USB register field, see the eXtensible Host Controller Interface for Universal Serial Bus (USB) Specification 3.'''
    longdesc = '''0.'''
[[register]]
  name = "IMAN_2"
  type = "mixed"
  width = 32
  description = "Interrupter Management Register Bit Definitions For a description of this standard USB register field, see the eXtensible Host Controller Interface for Universal Serial Bus (USB) Specification 3.0. Instance 2 of an array of 4."
  default = "0x00000000"
  offset = "0x000004A0"
  [[register.field]]
    name = "RESERVED"
    bits = "31:2"
    type = "ro"
  [[register.field]]
    name = "IE"
    bits = "1"
    type = "rw"
    shortdesc = '''IE For a description of this standard USB register field, see the eXtensible Host Controller Interface for Universal Serial Bus (USB) Specification 3.'''
    longdesc = '''0.'''
  [[register.field]]
    name = "IP"
    bits = "0"
    type = "wtc"
    shortdesc = '''IP Interrupt Pending For a description of this standard USB register field, see the eXtensible Host Controller Interface for Universal Serial Bus (USB) Specification 3.'''
    longdesc = '''0.'''
[[register]]
  name = "IMOD_2"
  type = "rw"
  width = 32
  description = "Interrupter Moderation Register The software may use this register to pace (or even out) the delivery of interrupts to the host CPU. This register provides a guaranteed inter-interrupt delay between interrupts asserted by the xHC, regardless of USB traffic conditions. To independently validate configuration settings, software may use the following algorithm to convert the inter-interrupt Interval value to the common 'interrupts/sec' performance metric. Instance 2 of an array of 4."
  default = "0x00000FA0"
  offset = "0x000004A4"
  [[register.field]]
    name = "IMODC"
    bits = "31:16"
    type = "rw"
    shortdesc = '''Interrupt Moderation Counter (IMODC) - RW.'''
    longdesc = '''Default = undefined. Down counter. Loaded with the IMODI value whenever IP is cleared to '0', counts down to '0', and stops. The associated interrupt is signaled whenever this counter is '0', the Event Ring is not empty, the IE and IP flags = '1', and EHB = '0'. This counter may be directly written by software at any time to alter the interrupt rate.'''
  [[register.field]]
    name = "IMODI"
    bits = "15:0"
    type = "rw"
    shortdesc = '''Interrupt Moderation Interval (IMODI) - RW.'''
    longdesc = '''Default = '4000' (~1ms). Minimum inter-interrupt interval. The interval is specified in 250ns increments. A value of '0' disables interrupt throttling logic and interrupts is generated immediately if IP = '0', EHB = '0', and the Event Ring is not empty.'''
[[register]]
  name = "ERSTSZ_2"
  type = "mixed"
  width = 32
  description = "Event Ring Segment Table Size Register Bit Definitions For a description of this standard USB register field, see the eXtensible Host Controller Interface for Universal Serial Bus (USB) Specification 3.0. Instance 2 of an array of 4."
  default = "0x00000000"
  offset = "0x000004A8"
  [[register.field]]
    name = "RESERVED"
    bits = "31:16"
    type = "ro"
  [[register.field]]
    name = "ERS_TABLE_SIZE"
    bits = "15:0"
    type = "rw"
    shortdesc = '''ERS_TABLE_SIZE For a description of this standard USB register field, see the eXtensible Host Controller Interface for Universal Serial Bus (USB) Specification 3.'''
    longdesc = '''0.'''
[[register]]
  name = "RSVDP_2"
  type = "ro"
  width = 32
  description = "RsvdP Instance 2 of an array of 4."
  default = "0x00000000"
  offset = "0x000004AC"
  [[register.field]]
    name = "RESERVED"
    bits = "31:0"
    type = "ro"
[[register]]
  name = "ERSTBA_LO_2"
  type = "mixed"
  width = 32
  description = "ERSTBA_LO Instance 2 of an array of 4."
  default = "0x00000000"
  offset = "0x000004B0"
  [[register.field]]
    name = "ERS_TABLE_BAR"
    bits = "31:6"
    type = "rw"
  [[register.field]]
    name = "RESERVED"
    bits = "5:0"
    type = "ro"
[[register]]
  name = "ERSTBA_HI_2"
  type = "rw"
  width = 32
  description = "ERSTBA_HI Instance 2 of an array of 4."
  default = "0x00000000"
  offset = "0x000004B4"
  [[register.field]]
    name = "ERS_TABLE_BAR"
    bits = "31:0"
    type = "rw"
    shortdesc = '''ERS_TABLE_BAR For a description of this standard USB register field, see the eXtensible Host Controller Interface for Universal Serial Bus (USB) Specification 3.'''
    longdesc = '''0.'''
[[register]]
  name = "ERDP_LO_2"
  type = "mixed"
  width = 32
  description = "ERDP_LO For a description of this standard USB register field, see the eXtensible Host Controller Interface for Universal Serial Bus (USB) Specification 3.0. Instance 2 of an array of 4."
  default = "0x00000000"
  offset = "0x000004B8"
  [[register.field]]
    name = "ERD_PNTR"
    bits = "31:4"
    type = "rw"
    shortdesc = '''ERD_PNTR For a description of this standard USB register field, see the eXtensible Host Controller Interface for Universal Serial Bus (USB) Specification 3.'''
    longdesc = '''0.'''
  [[register.field]]
    name = "EHB"
    bits = "3"
    type = "wtc"
  [[register.field]]
    name = "DESI"
    bits = "2:0"
    type = "rw"
    shortdesc = '''DESI - For a description of this standard USB register field, see the eXtensible Host Controller Interface for Universal Serial Bus (USB) Specification 3.'''
    longdesc = '''0.'''
[[register]]
  name = "ERDP_HI_2"
  type = "rw"
  width = 32
  description = "ERDP_HI Instance 2 of an array of 4."
  default = "0x00000000"
  offset = "0x000004BC"
  [[register.field]]
    name = "ERD_PNTR"
    bits = "31:0"
    type = "rw"
    shortdesc = '''ERD_PNTR For a description of this standard USB register field, see the eXtensible Host Controller Interface for Universal Serial Bus (USB) Specification 3.'''
    longdesc = '''0.'''
[[register]]
  name = "IMAN_3"
  type = "mixed"
  width = 32
  description = "Interrupter Management Register Bit Definitions For a description of this standard USB register field, see the eXtensible Host Controller Interface for Universal Serial Bus (USB) Specification 3.0. Instance 3 of an array of 4."
  default = "0x00000000"
  offset = "0x000004C0"
  [[register.field]]
    name = "RESERVED"
    bits = "31:2"
    type = "ro"
  [[register.field]]
    name = "IE"
    bits = "1"
    type = "rw"
    shortdesc = '''IE For a description of this standard USB register field, see the eXtensible Host Controller Interface for Universal Serial Bus (USB) Specification 3.'''
    longdesc = '''0.'''
  [[register.field]]
    name = "IP"
    bits = "0"
    type = "wtc"
    shortdesc = '''IP Interrupt Pending For a description of this standard USB register field, see the eXtensible Host Controller Interface for Universal Serial Bus (USB) Specification 3.'''
    longdesc = '''0.'''
[[register]]
  name = "IMOD_3"
  type = "rw"
  width = 32
  description = "Interrupter Moderation Register The software may use this register to pace (or even out) the delivery of interrupts to the host CPU. This register provides a guaranteed inter-interrupt delay between interrupts asserted by the xHC, regardless of USB traffic conditions. To independently validate configuration settings, software may use the following algorithm to convert the inter-interrupt Interval value to the common 'interrupts/sec' performance metric. Instance 3 of an array of 4."
  default = "0x00000FA0"
  offset = "0x000004C4"
  [[register.field]]
    name = "IMODC"
    bits = "31:16"
    type = "rw"
    shortdesc = '''Interrupt Moderation Counter (IMODC) - RW.'''
    longdesc = '''Default = undefined. Down counter. Loaded with the IMODI value whenever IP is cleared to '0', counts down to '0', and stops. The associated interrupt is signaled whenever this counter is '0', the Event Ring is not empty, the IE and IP flags = '1', and EHB = '0'. This counter may be directly written by software at any time to alter the interrupt rate.'''
  [[register.field]]
    name = "IMODI"
    bits = "15:0"
    type = "rw"
    shortdesc = '''Interrupt Moderation Interval (IMODI) - RW.'''
    longdesc = '''Default = '4000' (~1ms). Minimum inter-interrupt interval. The interval is specified in 250ns increments. A value of '0' disables interrupt throttling logic and interrupts is generated immediately if IP = '0', EHB = '0', and the Event Ring is not empty.'''
[[register]]
  name = "ERSTSZ_3"
  type = "mixed"
  width = 32
  description = "Event Ring Segment Table Size Register Bit Definitions For a description of this standard USB register field, see the eXtensible Host Controller Interface for Universal Serial Bus (USB) Specification 3.0. Instance 3 of an array of 4."
  default = "0x00000000"
  offset = "0x000004C8"
  [[register.field]]
    name = "RESERVED"
    bits = "31:16"
    type = "ro"
  [[register.field]]
    name = "ERS_TABLE_SIZE"
    bits = "15:0"
    type = "rw"
    shortdesc = '''ERS_TABLE_SIZE For a description of this standard USB register field, see the eXtensible Host Controller Interface for Universal Serial Bus (USB) Specification 3.'''
    longdesc = '''0.'''
[[register]]
  name = "RSVDP_3"
  type = "ro"
  width = 32
  description = "RsvdP Instance 3 of an array of 4."
  default = "0x00000000"
  offset = "0x000004CC"
  [[register.field]]
    name = "RESERVED"
    bits = "31:0"
    type = "ro"
[[register]]
  name = "ERSTBA_LO_3"
  type = "mixed"
  width = 32
  description = "ERSTBA_LO Instance 3 of an array of 4."
  default = "0x00000000"
  offset = "0x000004D0"
  [[register.field]]
    name = "ERS_TABLE_BAR"
    bits = "31:6"
    type = "rw"
  [[register.field]]
    name = "RESERVED"
    bits = "5:0"
    type = "ro"
[[register]]
  name = "ERSTBA_HI_3"
  type = "rw"
  width = 32
  description = "ERSTBA_HI Instance 3 of an array of 4."
  default = "0x00000000"
  offset = "0x000004D4"
  [[register.field]]
    name = "ERS_TABLE_BAR"
    bits = "31:0"
    type = "rw"
    shortdesc = '''ERS_TABLE_BAR For a description of this standard USB register field, see the eXtensible Host Controller Interface for Universal Serial Bus (USB) Specification 3.'''
    longdesc = '''0.'''
[[register]]
  name = "ERDP_LO_3"
  type = "mixed"
  width = 32
  description = "ERDP_LO For a description of this standard USB register field, see the eXtensible Host Controller Interface for Universal Serial Bus (USB) Specification 3.0. Instance 3 of an array of 4."
  default = "0x00000000"
  offset = "0x000004D8"
  [[register.field]]
    name = "ERD_PNTR"
    bits = "31:4"
    type = "rw"
    shortdesc = '''ERD_PNTR For a description of this standard USB register field, see the eXtensible Host Controller Interface for Universal Serial Bus (USB) Specification 3.'''
    longdesc = '''0.'''
  [[register.field]]
    name = "EHB"
    bits = "3"
    type = "wtc"
  [[register.field]]
    name = "DESI"
    bits = "2:0"
    type = "rw"
    shortdesc = '''DESI - For a description of this standard USB register field, see the eXtensible Host Controller Interface for Universal Serial Bus (USB) Specification 3.'''
    longdesc = '''0.'''
[[register]]
  name = "ERDP_HI_3"
  type = "rw"
  width = 32
  description = "ERDP_HI Instance 3 of an array of 4."
  default = "0x00000000"
  offset = "0x000004DC"
  [[register.field]]
    name = "ERD_PNTR"
    bits = "31:0"
    type = "rw"
    shortdesc = '''ERD_PNTR For a description of this standard USB register field, see the eXtensible Host Controller Interface for Universal Serial Bus (USB) Specification 3.'''
    longdesc = '''0.'''
[[register]]
  name = "DB0"
  type = "mixed"
  width = 32
  description = "Doorbell Register Bit Field Definitions For a description of this standard USB register field, see the eXtensible Host Controller Interface for Universal Serial Bus (USB) Specification 3.0. Programming this field with random data will cause side effect i.e. Register Access will fail (Timeout) if the pipe clock is not running or reset is asserted. Bit Bash register testing is not recommended."
  default = "0x00000000"
  offset = "0x000004E0"
  [[register.field]]
    name = "DB_STREAM_ID"
    bits = "31:16"
    type = "rw"
    shortdesc = '''DB_STREAM_ID For a description of this standard USB register field, see the eXtensible Host Controller Interface for Universal Serial Bus (USB) Specification 3.'''
    longdesc = '''0.'''
  [[register.field]]
    name = "RESERVED"
    bits = "15:8"
    type = "ro"
  [[register.field]]
    name = "DB_TARGET"
    bits = "7:0"
    type = "rw"
    shortdesc = '''DB_TARGET For a description of this standard USB register field, see the eXtensible Host Controller Interface for Universal Serial Bus (USB) Specification 3.'''
    longdesc = '''0.'''
[[register]]
  name = "DB1"
  type = "mixed"
  width = 32
  description = "Doorbell Register Bit Field Definitions For a description of this standard USB register field, see the eXtensible Host Controller Interface for Universal Serial Bus (USB) Specification 3.0. Programming this field with random data will cause side effect i.e. Register Access will fail (Timeout) if the pipe clock is not running or reset is asserted. Bit Bash register testing is not recommended."
  default = "0x00000000"
  offset = "0x000004E4"
  [[register.field]]
    name = "DB_STREAM_ID"
    bits = "31:16"
    type = "rw"
    shortdesc = '''DB_STREAM_ID For a description of this standard USB register field, see the eXtensible Host Controller Interface for Universal Serial Bus (USB) Specification 3.'''
    longdesc = '''0.'''
  [[register.field]]
    name = "RESERVED"
    bits = "15:8"
    type = "ro"
  [[register.field]]
    name = "DB_TARGET"
    bits = "7:0"
    type = "rw"
    shortdesc = '''DB_TARGET For a description of this standard USB register field, see the eXtensible Host Controller Interface for Universal Serial Bus (USB) Specification 3.'''
    longdesc = '''0.'''
[[register]]
  name = "DB2"
  type = "mixed"
  width = 32
  description = "Doorbell Register Bit Field Definitions For a description of this standard USB register field, see the eXtensible Host Controller Interface for Universal Serial Bus (USB) Specification 3.0. Programming this field with random data will cause side effect i.e. Register Access will fail (Timeout) if the pipe clock is not running or reset is asserted. Bit Bash register testing is not recommended."
  default = "0x00000000"
  offset = "0x000004E8"
  [[register.field]]
    name = "DB_STREAM_ID"
    bits = "31:16"
    type = "rw"
    shortdesc = '''DB_STREAM_ID For a description of this standard USB register field, see the eXtensible Host Controller Interface for Universal Serial Bus (USB) Specification 3.'''
    longdesc = '''0.'''
  [[register.field]]
    name = "RESERVED"
    bits = "15:8"
    type = "ro"
  [[register.field]]
    name = "DB_TARGET"
    bits = "7:0"
    type = "rw"
    shortdesc = '''DB_TARGET For a description of this standard USB register field, see the eXtensible Host Controller Interface for Universal Serial Bus (USB) Specification 3.'''
    longdesc = '''0.'''
[[register]]
  name = "DB3"
  type = "mixed"
  width = 32
  description = "Doorbell Register Bit Field Definitions For a description of this standard USB register field, see the eXtensible Host Controller Interface for Universal Serial Bus (USB) Specification 3.0. Programming this field with random data will cause side effect i.e. Register Access will fail (Timeout) if the pipe clock is not running or reset is asserted. Bit Bash register testing is not recommended."
  default = "0x00000000"
  offset = "0x000004EC"
  [[register.field]]
    name = "DB_STREAM_ID"
    bits = "31:16"
    type = "rw"
    shortdesc = '''DB_STREAM_ID For a description of this standard USB register field, see the eXtensible Host Controller Interface for Universal Serial Bus (USB) Specification 3.'''
    longdesc = '''0.'''
  [[register.field]]
    name = "RESERVED"
    bits = "15:8"
    type = "ro"
  [[register.field]]
    name = "DB_TARGET"
    bits = "7:0"
    type = "rw"
    shortdesc = '''DB_TARGET For a description of this standard USB register field, see the eXtensible Host Controller Interface for Universal Serial Bus (USB) Specification 3.'''
    longdesc = '''0.'''
[[register]]
  name = "DB4"
  type = "mixed"
  width = 32
  description = "Doorbell Register Bit Field Definitions For a description of this standard USB register field, see the eXtensible Host Controller Interface for Universal Serial Bus (USB) Specification 3.0. Programming this field with random data will cause side effect i.e. Register Access will fail (Timeout) if the pipe clock is not running or reset is asserted. Bit Bash register testing is not recommended."
  default = "0x00000000"
  offset = "0x000004F0"
  [[register.field]]
    name = "DB_STREAM_ID"
    bits = "31:16"
    type = "rw"
    shortdesc = '''DB_STREAM_ID For a description of this standard USB register field, see the eXtensible Host Controller Interface for Universal Serial Bus (USB) Specification 3.'''
    longdesc = '''0.'''
  [[register.field]]
    name = "RESERVED"
    bits = "15:8"
    type = "ro"
  [[register.field]]
    name = "DB_TARGET"
    bits = "7:0"
    type = "rw"
    shortdesc = '''DB_TARGET For a description of this standard USB register field, see the eXtensible Host Controller Interface for Universal Serial Bus (USB) Specification 3.'''
    longdesc = '''0.'''
[[register]]
  name = "DB5"
  type = "mixed"
  width = 32
  description = "Doorbell Register Bit Field Definitions For a description of this standard USB register field, see the eXtensible Host Controller Interface for Universal Serial Bus (USB) Specification 3.0. Programming this field with random data will cause side effect i.e. Register Access will fail (Timeout) if the pipe clock is not running or reset is asserted. Bit Bash register testing is not recommended."
  default = "0x00000000"
  offset = "0x000004F4"
  [[register.field]]
    name = "DB_STREAM_ID"
    bits = "31:16"
    type = "rw"
    shortdesc = '''DB_STREAM_ID For a description of this standard USB register field, see the eXtensible Host Controller Interface for Universal Serial Bus (USB) Specification 3.'''
    longdesc = '''0.'''
  [[register.field]]
    name = "RESERVED"
    bits = "15:8"
    type = "ro"
  [[register.field]]
    name = "DB_TARGET"
    bits = "7:0"
    type = "rw"
    shortdesc = '''DB_TARGET For a description of this standard USB register field, see the eXtensible Host Controller Interface for Universal Serial Bus (USB) Specification 3.'''
    longdesc = '''0.'''
[[register]]
  name = "DB6"
  type = "mixed"
  width = 32
  description = "Doorbell Register Bit Field Definitions For a description of this standard USB register field, see the eXtensible Host Controller Interface for Universal Serial Bus (USB) Specification 3.0. Programming this field with random data will cause side effect i.e. Register Access will fail (Timeout) if the pipe clock is not running or reset is asserted. Bit Bash register testing is not recommended."
  default = "0x00000000"
  offset = "0x000004F8"
  [[register.field]]
    name = "DB_STREAM_ID"
    bits = "31:16"
    type = "rw"
    shortdesc = '''DB_STREAM_ID For a description of this standard USB register field, see the eXtensible Host Controller Interface for Universal Serial Bus (USB) Specification 3.'''
    longdesc = '''0.'''
  [[register.field]]
    name = "RESERVED"
    bits = "15:8"
    type = "ro"
  [[register.field]]
    name = "DB_TARGET"
    bits = "7:0"
    type = "rw"
    shortdesc = '''DB_TARGET For a description of this standard USB register field, see the eXtensible Host Controller Interface for Universal Serial Bus (USB) Specification 3.'''
    longdesc = '''0.'''
[[register]]
  name = "DB7"
  type = "mixed"
  width = 32
  description = "Doorbell Register Bit Field Definitions For a description of this standard USB register field, see the eXtensible Host Controller Interface for Universal Serial Bus (USB) Specification 3.0. Programming this field with random data will cause side effect i.e. Register Access will fail (Timeout) if the pipe clock is not running or reset is asserted. Bit Bash register testing is not recommended."
  default = "0x00000000"
  offset = "0x000004FC"
  [[register.field]]
    name = "DB_STREAM_ID"
    bits = "31:16"
    type = "rw"
    shortdesc = '''DB_STREAM_ID For a description of this standard USB register field, see the eXtensible Host Controller Interface for Universal Serial Bus (USB) Specification 3.'''
    longdesc = '''0.'''
  [[register.field]]
    name = "RESERVED"
    bits = "15:8"
    type = "ro"
  [[register.field]]
    name = "DB_TARGET"
    bits = "7:0"
    type = "rw"
    shortdesc = '''DB_TARGET For a description of this standard USB register field, see the eXtensible Host Controller Interface for Universal Serial Bus (USB) Specification 3.'''
    longdesc = '''0.'''
[[register]]
  name = "DB8"
  type = "mixed"
  width = 32
  description = "Doorbell Register Bit Field Definitions For a description of this standard USB register field, see the eXtensible Host Controller Interface for Universal Serial Bus (USB) Specification 3.0. Programming this field with random data will cause side effect i.e. Register Access will fail (Timeout) if the pipe clock is not running or reset is asserted. Bit Bash register testing is not recommended."
  default = "0x00000000"
  offset = "0x00000500"
  [[register.field]]
    name = "DB_STREAM_ID"
    bits = "31:16"
    type = "rw"
    shortdesc = '''DB_STREAM_ID For a description of this standard USB register field, see the eXtensible Host Controller Interface for Universal Serial Bus (USB) Specification 3.'''
    longdesc = '''0.'''
  [[register.field]]
    name = "RESERVED"
    bits = "15:8"
    type = "ro"
  [[register.field]]
    name = "DB_TARGET"
    bits = "7:0"
    type = "rw"
    shortdesc = '''DB_TARGET For a description of this standard USB register field, see the eXtensible Host Controller Interface for Universal Serial Bus (USB) Specification 3.'''
    longdesc = '''0.'''
[[register]]
  name = "DB9"
  type = "mixed"
  width = 32
  description = "Doorbell Register Bit Field Definitions For a description of this standard USB register field, see the eXtensible Host Controller Interface for Universal Serial Bus (USB) Specification 3.0. Programming this field with random data will cause side effect i.e. Register Access will fail (Timeout) if the pipe clock is not running or reset is asserted. Bit Bash register testing is not recommended."
  default = "0x00000000"
  offset = "0x00000504"
  [[register.field]]
    name = "DB_STREAM_ID"
    bits = "31:16"
    type = "rw"
    shortdesc = '''DB_STREAM_ID For a description of this standard USB register field, see the eXtensible Host Controller Interface for Universal Serial Bus (USB) Specification 3.'''
    longdesc = '''0.'''
  [[register.field]]
    name = "RESERVED"
    bits = "15:8"
    type = "ro"
  [[register.field]]
    name = "DB_TARGET"
    bits = "7:0"
    type = "rw"
    shortdesc = '''DB_TARGET For a description of this standard USB register field, see the eXtensible Host Controller Interface for Universal Serial Bus (USB) Specification 3.'''
    longdesc = '''0.'''
[[register]]
  name = "DB10"
  type = "mixed"
  width = 32
  description = "Doorbell Register Bit Field Definitions For a description of this standard USB register field, see the eXtensible Host Controller Interface for Universal Serial Bus (USB) Specification 3.0. Programming this field with random data will cause side effect i.e. Register Access will fail (Timeout) if the pipe clock is not running or reset is asserted. Bit Bash register testing is not recommended."
  default = "0x00000000"
  offset = "0x00000508"
  [[register.field]]
    name = "DB_STREAM_ID"
    bits = "31:16"
    type = "rw"
    shortdesc = '''DB_STREAM_ID For a description of this standard USB register field, see the eXtensible Host Controller Interface for Universal Serial Bus (USB) Specification 3.'''
    longdesc = '''0.'''
  [[register.field]]
    name = "RESERVED"
    bits = "15:8"
    type = "ro"
  [[register.field]]
    name = "DB_TARGET"
    bits = "7:0"
    type = "rw"
    shortdesc = '''DB_TARGET For a description of this standard USB register field, see the eXtensible Host Controller Interface for Universal Serial Bus (USB) Specification 3.'''
    longdesc = '''0.'''
[[register]]
  name = "DB11"
  type = "mixed"
  width = 32
  description = "Doorbell Register Bit Field Definitions For a description of this standard USB register field, see the eXtensible Host Controller Interface for Universal Serial Bus (USB) Specification 3.0. Programming this field with random data will cause side effect i.e. Register Access will fail (Timeout) if the pipe clock is not running or reset is asserted. Bit Bash register testing is not recommended."
  default = "0x00000000"
  offset = "0x0000050C"
  [[register.field]]
    name = "DB_STREAM_ID"
    bits = "31:16"
    type = "rw"
    shortdesc = '''DB_STREAM_ID For a description of this standard USB register field, see the eXtensible Host Controller Interface for Universal Serial Bus (USB) Specification 3.'''
    longdesc = '''0.'''
  [[register.field]]
    name = "RESERVED"
    bits = "15:8"
    type = "ro"
  [[register.field]]
    name = "DB_TARGET"
    bits = "7:0"
    type = "rw"
    shortdesc = '''DB_TARGET For a description of this standard USB register field, see the eXtensible Host Controller Interface for Universal Serial Bus (USB) Specification 3.'''
    longdesc = '''0.'''
[[register]]
  name = "DB12"
  type = "mixed"
  width = 32
  description = "Doorbell Register Bit Field Definitions For a description of this standard USB register field, see the eXtensible Host Controller Interface for Universal Serial Bus (USB) Specification 3.0. Programming this field with random data will cause side effect i.e. Register Access will fail (Timeout) if the pipe clock is not running or reset is asserted. Bit Bash register testing is not recommended."
  default = "0x00000000"
  offset = "0x00000510"
  [[register.field]]
    name = "DB_STREAM_ID"
    bits = "31:16"
    type = "rw"
    shortdesc = '''DB_STREAM_ID For a description of this standard USB register field, see the eXtensible Host Controller Interface for Universal Serial Bus (USB) Specification 3.'''
    longdesc = '''0.'''
  [[register.field]]
    name = "RESERVED"
    bits = "15:8"
    type = "ro"
  [[register.field]]
    name = "DB_TARGET"
    bits = "7:0"
    type = "rw"
    shortdesc = '''DB_TARGET For a description of this standard USB register field, see the eXtensible Host Controller Interface for Universal Serial Bus (USB) Specification 3.'''
    longdesc = '''0.'''
[[register]]
  name = "DB13"
  type = "mixed"
  width = 32
  description = "Doorbell Register Bit Field Definitions For a description of this standard USB register field, see the eXtensible Host Controller Interface for Universal Serial Bus (USB) Specification 3.0. Programming this field with random data will cause side effect i.e. Register Access will fail (Timeout) if the pipe clock is not running or reset is asserted. Bit Bash register testing is not recommended."
  default = "0x00000000"
  offset = "0x00000514"
  [[register.field]]
    name = "DB_STREAM_ID"
    bits = "31:16"
    type = "rw"
    shortdesc = '''DB_STREAM_ID For a description of this standard USB register field, see the eXtensible Host Controller Interface for Universal Serial Bus (USB) Specification 3.'''
    longdesc = '''0.'''
  [[register.field]]
    name = "RESERVED"
    bits = "15:8"
    type = "ro"
  [[register.field]]
    name = "DB_TARGET"
    bits = "7:0"
    type = "rw"
    shortdesc = '''DB_TARGET For a description of this standard USB register field, see the eXtensible Host Controller Interface for Universal Serial Bus (USB) Specification 3.'''
    longdesc = '''0.'''
[[register]]
  name = "DB14"
  type = "mixed"
  width = 32
  description = "Doorbell Register Bit Field Definitions For a description of this standard USB register field, see the eXtensible Host Controller Interface for Universal Serial Bus (USB) Specification 3.0. Programming this field with random data will cause side effect i.e. Register Access will fail (Timeout) if the pipe clock is not running or reset is asserted. Bit Bash register testing is not recommended."
  default = "0x00000000"
  offset = "0x00000518"
  [[register.field]]
    name = "DB_STREAM_ID"
    bits = "31:16"
    type = "rw"
    shortdesc = '''DB_STREAM_ID For a description of this standard USB register field, see the eXtensible Host Controller Interface for Universal Serial Bus (USB) Specification 3.'''
    longdesc = '''0.'''
  [[register.field]]
    name = "RESERVED"
    bits = "15:8"
    type = "ro"
  [[register.field]]
    name = "DB_TARGET"
    bits = "7:0"
    type = "rw"
    shortdesc = '''DB_TARGET For a description of this standard USB register field, see the eXtensible Host Controller Interface for Universal Serial Bus (USB) Specification 3.'''
    longdesc = '''0.'''
[[register]]
  name = "DB15"
  type = "mixed"
  width = 32
  description = "Doorbell Register Bit Field Definitions For a description of this standard USB register field, see the eXtensible Host Controller Interface for Universal Serial Bus (USB) Specification 3.0. Programming this field with random data will cause side effect i.e. Register Access will fail (Timeout) if the pipe clock is not running or reset is asserted. Bit Bash register testing is not recommended."
  default = "0x00000000"
  offset = "0x0000051C"
  [[register.field]]
    name = "DB_STREAM_ID"
    bits = "31:16"
    type = "rw"
    shortdesc = '''DB_STREAM_ID For a description of this standard USB register field, see the eXtensible Host Controller Interface for Universal Serial Bus (USB) Specification 3.'''
    longdesc = '''0.'''
  [[register.field]]
    name = "RESERVED"
    bits = "15:8"
    type = "ro"
  [[register.field]]
    name = "DB_TARGET"
    bits = "7:0"
    type = "rw"
    shortdesc = '''DB_TARGET For a description of this standard USB register field, see the eXtensible Host Controller Interface for Universal Serial Bus (USB) Specification 3.'''
    longdesc = '''0.'''
[[register]]
  name = "DB16"
  type = "mixed"
  width = 32
  description = "Doorbell Register Bit Field Definitions For a description of this standard USB register field, see the eXtensible Host Controller Interface for Universal Serial Bus (USB) Specification 3.0. Programming this field with random data will cause side effect i.e. Register Access will fail (Timeout) if the pipe clock is not running or reset is asserted. Bit Bash register testing is not recommended."
  default = "0x00000000"
  offset = "0x00000520"
  [[register.field]]
    name = "DB_STREAM_ID"
    bits = "31:16"
    type = "rw"
    shortdesc = '''DB_STREAM_ID For a description of this standard USB register field, see the eXtensible Host Controller Interface for Universal Serial Bus (USB) Specification 3.'''
    longdesc = '''0.'''
  [[register.field]]
    name = "RESERVED"
    bits = "15:8"
    type = "ro"
  [[register.field]]
    name = "DB_TARGET"
    bits = "7:0"
    type = "rw"
    shortdesc = '''DB_TARGET For a description of this standard USB register field, see the eXtensible Host Controller Interface for Universal Serial Bus (USB) Specification 3.'''
    longdesc = '''0.'''
[[register]]
  name = "DB17"
  type = "mixed"
  width = 32
  description = "Doorbell Register Bit Field Definitions For a description of this standard USB register field, see the eXtensible Host Controller Interface for Universal Serial Bus (USB) Specification 3.0. Programming this field with random data will cause side effect i.e. Register Access will fail (Timeout) if the pipe clock is not running or reset is asserted. Bit Bash register testing is not recommended."
  default = "0x00000000"
  offset = "0x00000524"
  [[register.field]]
    name = "DB_STREAM_ID"
    bits = "31:16"
    type = "rw"
    shortdesc = '''DB_STREAM_ID For a description of this standard USB register field, see the eXtensible Host Controller Interface for Universal Serial Bus (USB) Specification 3.'''
    longdesc = '''0.'''
  [[register.field]]
    name = "RESERVED"
    bits = "15:8"
    type = "ro"
  [[register.field]]
    name = "DB_TARGET"
    bits = "7:0"
    type = "rw"
    shortdesc = '''DB_TARGET For a description of this standard USB register field, see the eXtensible Host Controller Interface for Universal Serial Bus (USB) Specification 3.'''
    longdesc = '''0.'''
[[register]]
  name = "DB18"
  type = "mixed"
  width = 32
  description = "Doorbell Register Bit Field Definitions For a description of this standard USB register field, see the eXtensible Host Controller Interface for Universal Serial Bus (USB) Specification 3.0. Programming this field with random data will cause side effect i.e. Register Access will fail (Timeout) if the pipe clock is not running or reset is asserted. Bit Bash register testing is not recommended."
  default = "0x00000000"
  offset = "0x00000528"
  [[register.field]]
    name = "DB_STREAM_ID"
    bits = "31:16"
    type = "rw"
    shortdesc = '''DB_STREAM_ID For a description of this standard USB register field, see the eXtensible Host Controller Interface for Universal Serial Bus (USB) Specification 3.'''
    longdesc = '''0.'''
  [[register.field]]
    name = "RESERVED"
    bits = "15:8"
    type = "ro"
  [[register.field]]
    name = "DB_TARGET"
    bits = "7:0"
    type = "rw"
    shortdesc = '''DB_TARGET For a description of this standard USB register field, see the eXtensible Host Controller Interface for Universal Serial Bus (USB) Specification 3.'''
    longdesc = '''0.'''
[[register]]
  name = "DB19"
  type = "mixed"
  width = 32
  description = "Doorbell Register Bit Field Definitions For a description of this standard USB register field, see the eXtensible Host Controller Interface for Universal Serial Bus (USB) Specification 3.0. Programming this field with random data will cause side effect i.e. Register Access will fail (Timeout) if the pipe clock is not running or reset is asserted. Bit Bash register testing is not recommended."
  default = "0x00000000"
  offset = "0x0000052C"
  [[register.field]]
    name = "DB_STREAM_ID"
    bits = "31:16"
    type = "rw"
    shortdesc = '''DB_STREAM_ID For a description of this standard USB register field, see the eXtensible Host Controller Interface for Universal Serial Bus (USB) Specification 3.'''
    longdesc = '''0.'''
  [[register.field]]
    name = "RESERVED"
    bits = "15:8"
    type = "ro"
  [[register.field]]
    name = "DB_TARGET"
    bits = "7:0"
    type = "rw"
    shortdesc = '''DB_TARGET For a description of this standard USB register field, see the eXtensible Host Controller Interface for Universal Serial Bus (USB) Specification 3.'''
    longdesc = '''0.'''
[[register]]
  name = "DB20"
  type = "mixed"
  width = 32
  description = "Doorbell Register Bit Field Definitions For a description of this standard USB register field, see the eXtensible Host Controller Interface for Universal Serial Bus (USB) Specification 3.0. Programming this field with random data will cause side effect i.e. Register Access will fail (Timeout) if the pipe clock is not running or reset is asserted. Bit Bash register testing is not recommended."
  default = "0x00000000"
  offset = "0x00000530"
  [[register.field]]
    name = "DB_STREAM_ID"
    bits = "31:16"
    type = "rw"
    shortdesc = '''DB_STREAM_ID For a description of this standard USB register field, see the eXtensible Host Controller Interface for Universal Serial Bus (USB) Specification 3.'''
    longdesc = '''0.'''
  [[register.field]]
    name = "RESERVED"
    bits = "15:8"
    type = "ro"
  [[register.field]]
    name = "DB_TARGET"
    bits = "7:0"
    type = "rw"
    shortdesc = '''DB_TARGET For a description of this standard USB register field, see the eXtensible Host Controller Interface for Universal Serial Bus (USB) Specification 3.'''
    longdesc = '''0.'''
[[register]]
  name = "DB21"
  type = "mixed"
  width = 32
  description = "Doorbell Register Bit Field Definitions For a description of this standard USB register field, see the eXtensible Host Controller Interface for Universal Serial Bus (USB) Specification 3.0. Programming this field with random data will cause side effect i.e. Register Access will fail (Timeout) if the pipe clock is not running or reset is asserted. Bit Bash register testing is not recommended."
  default = "0x00000000"
  offset = "0x00000534"
  [[register.field]]
    name = "DB_STREAM_ID"
    bits = "31:16"
    type = "rw"
    shortdesc = '''DB_STREAM_ID For a description of this standard USB register field, see the eXtensible Host Controller Interface for Universal Serial Bus (USB) Specification 3.'''
    longdesc = '''0.'''
  [[register.field]]
    name = "RESERVED"
    bits = "15:8"
    type = "ro"
  [[register.field]]
    name = "DB_TARGET"
    bits = "7:0"
    type = "rw"
    shortdesc = '''DB_TARGET For a description of this standard USB register field, see the eXtensible Host Controller Interface for Universal Serial Bus (USB) Specification 3.'''
    longdesc = '''0.'''
[[register]]
  name = "DB22"
  type = "mixed"
  width = 32
  description = "Doorbell Register Bit Field Definitions For a description of this standard USB register field, see the eXtensible Host Controller Interface for Universal Serial Bus (USB) Specification 3.0. Programming this field with random data will cause side effect i.e. Register Access will fail (Timeout) if the pipe clock is not running or reset is asserted. Bit Bash register testing is not recommended."
  default = "0x00000000"
  offset = "0x00000538"
  [[register.field]]
    name = "DB_STREAM_ID"
    bits = "31:16"
    type = "rw"
    shortdesc = '''DB_STREAM_ID For a description of this standard USB register field, see the eXtensible Host Controller Interface for Universal Serial Bus (USB) Specification 3.'''
    longdesc = '''0.'''
  [[register.field]]
    name = "RESERVED"
    bits = "15:8"
    type = "ro"
  [[register.field]]
    name = "DB_TARGET"
    bits = "7:0"
    type = "rw"
    shortdesc = '''DB_TARGET For a description of this standard USB register field, see the eXtensible Host Controller Interface for Universal Serial Bus (USB) Specification 3.'''
    longdesc = '''0.'''
[[register]]
  name = "DB23"
  type = "mixed"
  width = 32
  description = "Doorbell Register Bit Field Definitions For a description of this standard USB register field, see the eXtensible Host Controller Interface for Universal Serial Bus (USB) Specification 3.0. Programming this field with random data will cause side effect i.e. Register Access will fail (Timeout) if the pipe clock is not running or reset is asserted. Bit Bash register testing is not recommended."
  default = "0x00000000"
  offset = "0x0000053C"
  [[register.field]]
    name = "DB_STREAM_ID"
    bits = "31:16"
    type = "rw"
    shortdesc = '''DB_STREAM_ID For a description of this standard USB register field, see the eXtensible Host Controller Interface for Universal Serial Bus (USB) Specification 3.'''
    longdesc = '''0.'''
  [[register.field]]
    name = "RESERVED"
    bits = "15:8"
    type = "ro"
  [[register.field]]
    name = "DB_TARGET"
    bits = "7:0"
    type = "rw"
    shortdesc = '''DB_TARGET For a description of this standard USB register field, see the eXtensible Host Controller Interface for Universal Serial Bus (USB) Specification 3.'''
    longdesc = '''0.'''
[[register]]
  name = "DB24"
  type = "mixed"
  width = 32
  description = "Doorbell Register Bit Field Definitions For a description of this standard USB register field, see the eXtensible Host Controller Interface for Universal Serial Bus (USB) Specification 3.0. Programming this field with random data will cause side effect i.e. Register Access will fail (Timeout) if the pipe clock is not running or reset is asserted. Bit Bash register testing is not recommended."
  default = "0x00000000"
  offset = "0x00000540"
  [[register.field]]
    name = "DB_STREAM_ID"
    bits = "31:16"
    type = "rw"
    shortdesc = '''DB_STREAM_ID For a description of this standard USB register field, see the eXtensible Host Controller Interface for Universal Serial Bus (USB) Specification 3.'''
    longdesc = '''0.'''
  [[register.field]]
    name = "RESERVED"
    bits = "15:8"
    type = "ro"
  [[register.field]]
    name = "DB_TARGET"
    bits = "7:0"
    type = "rw"
    shortdesc = '''DB_TARGET For a description of this standard USB register field, see the eXtensible Host Controller Interface for Universal Serial Bus (USB) Specification 3.'''
    longdesc = '''0.'''
[[register]]
  name = "DB25"
  type = "mixed"
  width = 32
  description = "Doorbell Register Bit Field Definitions For a description of this standard USB register field, see the eXtensible Host Controller Interface for Universal Serial Bus (USB) Specification 3.0. Programming this field with random data will cause side effect i.e. Register Access will fail (Timeout) if the pipe clock is not running or reset is asserted. Bit Bash register testing is not recommended."
  default = "0x00000000"
  offset = "0x00000544"
  [[register.field]]
    name = "DB_STREAM_ID"
    bits = "31:16"
    type = "rw"
    shortdesc = '''DB_STREAM_ID For a description of this standard USB register field, see the eXtensible Host Controller Interface for Universal Serial Bus (USB) Specification 3.'''
    longdesc = '''0.'''
  [[register.field]]
    name = "RESERVED"
    bits = "15:8"
    type = "ro"
  [[register.field]]
    name = "DB_TARGET"
    bits = "7:0"
    type = "rw"
    shortdesc = '''DB_TARGET For a description of this standard USB register field, see the eXtensible Host Controller Interface for Universal Serial Bus (USB) Specification 3.'''
    longdesc = '''0.'''
[[register]]
  name = "DB26"
  type = "mixed"
  width = 32
  description = "Doorbell Register Bit Field Definitions For a description of this standard USB register field, see the eXtensible Host Controller Interface for Universal Serial Bus (USB) Specification 3.0. Programming this field with random data will cause side effect i.e. Register Access will fail (Timeout) if the pipe clock is not running or reset is asserted. Bit Bash register testing is not recommended."
  default = "0x00000000"
  offset = "0x00000548"
  [[register.field]]
    name = "DB_STREAM_ID"
    bits = "31:16"
    type = "rw"
    shortdesc = '''DB_STREAM_ID For a description of this standard USB register field, see the eXtensible Host Controller Interface for Universal Serial Bus (USB) Specification 3.'''
    longdesc = '''0.'''
  [[register.field]]
    name = "RESERVED"
    bits = "15:8"
    type = "ro"
  [[register.field]]
    name = "DB_TARGET"
    bits = "7:0"
    type = "rw"
    shortdesc = '''DB_TARGET For a description of this standard USB register field, see the eXtensible Host Controller Interface for Universal Serial Bus (USB) Specification 3.'''
    longdesc = '''0.'''
[[register]]
  name = "DB27"
  type = "mixed"
  width = 32
  description = "Doorbell Register Bit Field Definitions For a description of this standard USB register field, see the eXtensible Host Controller Interface for Universal Serial Bus (USB) Specification 3.0. Programming this field with random data will cause side effect i.e. Register Access will fail (Timeout) if the pipe clock is not running or reset is asserted. Bit Bash register testing is not recommended."
  default = "0x00000000"
  offset = "0x0000054C"
  [[register.field]]
    name = "DB_STREAM_ID"
    bits = "31:16"
    type = "rw"
    shortdesc = '''DB_STREAM_ID For a description of this standard USB register field, see the eXtensible Host Controller Interface for Universal Serial Bus (USB) Specification 3.'''
    longdesc = '''0.'''
  [[register.field]]
    name = "RESERVED"
    bits = "15:8"
    type = "ro"
  [[register.field]]
    name = "DB_TARGET"
    bits = "7:0"
    type = "rw"
    shortdesc = '''DB_TARGET For a description of this standard USB register field, see the eXtensible Host Controller Interface for Universal Serial Bus (USB) Specification 3.'''
    longdesc = '''0.'''
[[register]]
  name = "DB28"
  type = "mixed"
  width = 32
  description = "Doorbell Register Bit Field Definitions For a description of this standard USB register field, see the eXtensible Host Controller Interface for Universal Serial Bus (USB) Specification 3.0. Programming this field with random data will cause side effect i.e. Register Access will fail (Timeout) if the pipe clock is not running or reset is asserted. Bit Bash register testing is not recommended."
  default = "0x00000000"
  offset = "0x00000550"
  [[register.field]]
    name = "DB_STREAM_ID"
    bits = "31:16"
    type = "rw"
    shortdesc = '''DB_STREAM_ID For a description of this standard USB register field, see the eXtensible Host Controller Interface for Universal Serial Bus (USB) Specification 3.'''
    longdesc = '''0.'''
  [[register.field]]
    name = "RESERVED"
    bits = "15:8"
    type = "ro"
  [[register.field]]
    name = "DB_TARGET"
    bits = "7:0"
    type = "rw"
    shortdesc = '''DB_TARGET For a description of this standard USB register field, see the eXtensible Host Controller Interface for Universal Serial Bus (USB) Specification 3.'''
    longdesc = '''0.'''
[[register]]
  name = "DB29"
  type = "mixed"
  width = 32
  description = "Doorbell Register Bit Field Definitions For a description of this standard USB register field, see the eXtensible Host Controller Interface for Universal Serial Bus (USB) Specification 3.0. Programming this field with random data will cause side effect i.e. Register Access will fail (Timeout) if the pipe clock is not running or reset is asserted. Bit Bash register testing is not recommended."
  default = "0x00000000"
  offset = "0x00000554"
  [[register.field]]
    name = "DB_STREAM_ID"
    bits = "31:16"
    type = "rw"
    shortdesc = '''DB_STREAM_ID For a description of this standard USB register field, see the eXtensible Host Controller Interface for Universal Serial Bus (USB) Specification 3.'''
    longdesc = '''0.'''
  [[register.field]]
    name = "RESERVED"
    bits = "15:8"
    type = "ro"
  [[register.field]]
    name = "DB_TARGET"
    bits = "7:0"
    type = "rw"
    shortdesc = '''DB_TARGET For a description of this standard USB register field, see the eXtensible Host Controller Interface for Universal Serial Bus (USB) Specification 3.'''
    longdesc = '''0.'''
[[register]]
  name = "DB30"
  type = "mixed"
  width = 32
  description = "Doorbell Register Bit Field Definitions For a description of this standard USB register field, see the eXtensible Host Controller Interface for Universal Serial Bus (USB) Specification 3.0. Programming this field with random data will cause side effect i.e. Register Access will fail (Timeout) if the pipe clock is not running or reset is asserted. Bit Bash register testing is not recommended."
  default = "0x00000000"
  offset = "0x00000558"
  [[register.field]]
    name = "DB_STREAM_ID"
    bits = "31:16"
    type = "rw"
    shortdesc = '''DB_STREAM_ID For a description of this standard USB register field, see the eXtensible Host Controller Interface for Universal Serial Bus (USB) Specification 3.'''
    longdesc = '''0.'''
  [[register.field]]
    name = "RESERVED"
    bits = "15:8"
    type = "ro"
  [[register.field]]
    name = "DB_TARGET"
    bits = "7:0"
    type = "rw"
    shortdesc = '''DB_TARGET For a description of this standard USB register field, see the eXtensible Host Controller Interface for Universal Serial Bus (USB) Specification 3.'''
    longdesc = '''0.'''
[[register]]
  name = "DB31"
  type = "mixed"
  width = 32
  description = "Doorbell Register Bit Field Definitions For a description of this standard USB register field, see the eXtensible Host Controller Interface for Universal Serial Bus (USB) Specification 3.0. Programming this field with random data will cause side effect i.e. Register Access will fail (Timeout) if the pipe clock is not running or reset is asserted. Bit Bash register testing is not recommended."
  default = "0x00000000"
  offset = "0x0000055C"
  [[register.field]]
    name = "DB_STREAM_ID"
    bits = "31:16"
    type = "rw"
    shortdesc = '''DB_STREAM_ID For a description of this standard USB register field, see the eXtensible Host Controller Interface for Universal Serial Bus (USB) Specification 3.'''
    longdesc = '''0.'''
  [[register.field]]
    name = "RESERVED"
    bits = "15:8"
    type = "ro"
  [[register.field]]
    name = "DB_TARGET"
    bits = "7:0"
    type = "rw"
    shortdesc = '''DB_TARGET For a description of this standard USB register field, see the eXtensible Host Controller Interface for Universal Serial Bus (USB) Specification 3.'''
    longdesc = '''0.'''
[[register]]
  name = "DB32"
  type = "mixed"
  width = 32
  description = "Doorbell Register Bit Field Definitions For a description of this standard USB register field, see the eXtensible Host Controller Interface for Universal Serial Bus (USB) Specification 3.0. Programming this field with random data will cause side effect i.e. Register Access will fail (Timeout) if the pipe clock is not running or reset is asserted. Bit Bash register testing is not recommended."
  default = "0x00000000"
  offset = "0x00000560"
  [[register.field]]
    name = "DB_STREAM_ID"
    bits = "31:16"
    type = "rw"
    shortdesc = '''DB_STREAM_ID For a description of this standard USB register field, see the eXtensible Host Controller Interface for Universal Serial Bus (USB) Specification 3.'''
    longdesc = '''0.'''
  [[register.field]]
    name = "RESERVED"
    bits = "15:8"
    type = "ro"
  [[register.field]]
    name = "DB_TARGET"
    bits = "7:0"
    type = "rw"
    shortdesc = '''DB_TARGET For a description of this standard USB register field, see the eXtensible Host Controller Interface for Universal Serial Bus (USB) Specification 3.'''
    longdesc = '''0.'''
[[register]]
  name = "DB33"
  type = "mixed"
  width = 32
  description = "Doorbell Register Bit Field Definitions For a description of this standard USB register field, see the eXtensible Host Controller Interface for Universal Serial Bus (USB) Specification 3.0. Programming this field with random data will cause side effect i.e. Register Access will fail (Timeout) if the pipe clock is not running or reset is asserted. Bit Bash register testing is not recommended."
  default = "0x00000000"
  offset = "0x00000564"
  [[register.field]]
    name = "DB_STREAM_ID"
    bits = "31:16"
    type = "rw"
    shortdesc = '''DB_STREAM_ID For a description of this standard USB register field, see the eXtensible Host Controller Interface for Universal Serial Bus (USB) Specification 3.'''
    longdesc = '''0.'''
  [[register.field]]
    name = "RESERVED"
    bits = "15:8"
    type = "ro"
  [[register.field]]
    name = "DB_TARGET"
    bits = "7:0"
    type = "rw"
    shortdesc = '''DB_TARGET For a description of this standard USB register field, see the eXtensible Host Controller Interface for Universal Serial Bus (USB) Specification 3.'''
    longdesc = '''0.'''
[[register]]
  name = "DB34"
  type = "mixed"
  width = 32
  description = "Doorbell Register Bit Field Definitions For a description of this standard USB register field, see the eXtensible Host Controller Interface for Universal Serial Bus (USB) Specification 3.0. Programming this field with random data will cause side effect i.e. Register Access will fail (Timeout) if the pipe clock is not running or reset is asserted. Bit Bash register testing is not recommended."
  default = "0x00000000"
  offset = "0x00000568"
  [[register.field]]
    name = "DB_STREAM_ID"
    bits = "31:16"
    type = "rw"
    shortdesc = '''DB_STREAM_ID For a description of this standard USB register field, see the eXtensible Host Controller Interface for Universal Serial Bus (USB) Specification 3.'''
    longdesc = '''0.'''
  [[register.field]]
    name = "RESERVED"
    bits = "15:8"
    type = "ro"
  [[register.field]]
    name = "DB_TARGET"
    bits = "7:0"
    type = "rw"
    shortdesc = '''DB_TARGET For a description of this standard USB register field, see the eXtensible Host Controller Interface for Universal Serial Bus (USB) Specification 3.'''
    longdesc = '''0.'''
[[register]]
  name = "DB35"
  type = "mixed"
  width = 32
  description = "Doorbell Register Bit Field Definitions For a description of this standard USB register field, see the eXtensible Host Controller Interface for Universal Serial Bus (USB) Specification 3.0. Programming this field with random data will cause side effect i.e. Register Access will fail (Timeout) if the pipe clock is not running or reset is asserted. Bit Bash register testing is not recommended."
  default = "0x00000000"
  offset = "0x0000056C"
  [[register.field]]
    name = "DB_STREAM_ID"
    bits = "31:16"
    type = "rw"
    shortdesc = '''DB_STREAM_ID For a description of this standard USB register field, see the eXtensible Host Controller Interface for Universal Serial Bus (USB) Specification 3.'''
    longdesc = '''0.'''
  [[register.field]]
    name = "RESERVED"
    bits = "15:8"
    type = "ro"
  [[register.field]]
    name = "DB_TARGET"
    bits = "7:0"
    type = "rw"
    shortdesc = '''DB_TARGET For a description of this standard USB register field, see the eXtensible Host Controller Interface for Universal Serial Bus (USB) Specification 3.'''
    longdesc = '''0.'''
[[register]]
  name = "DB36"
  type = "mixed"
  width = 32
  description = "Doorbell Register Bit Field Definitions For a description of this standard USB register field, see the eXtensible Host Controller Interface for Universal Serial Bus (USB) Specification 3.0. Programming this field with random data will cause side effect i.e. Register Access will fail (Timeout) if the pipe clock is not running or reset is asserted. Bit Bash register testing is not recommended."
  default = "0x00000000"
  offset = "0x00000570"
  [[register.field]]
    name = "DB_STREAM_ID"
    bits = "31:16"
    type = "rw"
    shortdesc = '''DB_STREAM_ID For a description of this standard USB register field, see the eXtensible Host Controller Interface for Universal Serial Bus (USB) Specification 3.'''
    longdesc = '''0.'''
  [[register.field]]
    name = "RESERVED"
    bits = "15:8"
    type = "ro"
  [[register.field]]
    name = "DB_TARGET"
    bits = "7:0"
    type = "rw"
    shortdesc = '''DB_TARGET For a description of this standard USB register field, see the eXtensible Host Controller Interface for Universal Serial Bus (USB) Specification 3.'''
    longdesc = '''0.'''
[[register]]
  name = "DB37"
  type = "mixed"
  width = 32
  description = "Doorbell Register Bit Field Definitions For a description of this standard USB register field, see the eXtensible Host Controller Interface for Universal Serial Bus (USB) Specification 3.0. Programming this field with random data will cause side effect i.e. Register Access will fail (Timeout) if the pipe clock is not running or reset is asserted. Bit Bash register testing is not recommended."
  default = "0x00000000"
  offset = "0x00000574"
  [[register.field]]
    name = "DB_STREAM_ID"
    bits = "31:16"
    type = "rw"
    shortdesc = '''DB_STREAM_ID For a description of this standard USB register field, see the eXtensible Host Controller Interface for Universal Serial Bus (USB) Specification 3.'''
    longdesc = '''0.'''
  [[register.field]]
    name = "RESERVED"
    bits = "15:8"
    type = "ro"
  [[register.field]]
    name = "DB_TARGET"
    bits = "7:0"
    type = "rw"
    shortdesc = '''DB_TARGET For a description of this standard USB register field, see the eXtensible Host Controller Interface for Universal Serial Bus (USB) Specification 3.'''
    longdesc = '''0.'''
[[register]]
  name = "DB38"
  type = "mixed"
  width = 32
  description = "Doorbell Register Bit Field Definitions For a description of this standard USB register field, see the eXtensible Host Controller Interface for Universal Serial Bus (USB) Specification 3.0. Programming this field with random data will cause side effect i.e. Register Access will fail (Timeout) if the pipe clock is not running or reset is asserted. Bit Bash register testing is not recommended."
  default = "0x00000000"
  offset = "0x00000578"
  [[register.field]]
    name = "DB_STREAM_ID"
    bits = "31:16"
    type = "rw"
    shortdesc = '''DB_STREAM_ID For a description of this standard USB register field, see the eXtensible Host Controller Interface for Universal Serial Bus (USB) Specification 3.'''
    longdesc = '''0.'''
  [[register.field]]
    name = "RESERVED"
    bits = "15:8"
    type = "ro"
  [[register.field]]
    name = "DB_TARGET"
    bits = "7:0"
    type = "rw"
    shortdesc = '''DB_TARGET For a description of this standard USB register field, see the eXtensible Host Controller Interface for Universal Serial Bus (USB) Specification 3.'''
    longdesc = '''0.'''
[[register]]
  name = "DB39"
  type = "mixed"
  width = 32
  description = "Doorbell Register Bit Field Definitions For a description of this standard USB register field, see the eXtensible Host Controller Interface for Universal Serial Bus (USB) Specification 3.0. Programming this field with random data will cause side effect i.e. Register Access will fail (Timeout) if the pipe clock is not running or reset is asserted. Bit Bash register testing is not recommended."
  default = "0x00000000"
  offset = "0x0000057C"
  [[register.field]]
    name = "DB_STREAM_ID"
    bits = "31:16"
    type = "rw"
    shortdesc = '''DB_STREAM_ID For a description of this standard USB register field, see the eXtensible Host Controller Interface for Universal Serial Bus (USB) Specification 3.'''
    longdesc = '''0.'''
  [[register.field]]
    name = "RESERVED"
    bits = "15:8"
    type = "ro"
  [[register.field]]
    name = "DB_TARGET"
    bits = "7:0"
    type = "rw"
    shortdesc = '''DB_TARGET For a description of this standard USB register field, see the eXtensible Host Controller Interface for Universal Serial Bus (USB) Specification 3.'''
    longdesc = '''0.'''
[[register]]
  name = "DB40"
  type = "mixed"
  width = 32
  description = "Doorbell Register Bit Field Definitions For a description of this standard USB register field, see the eXtensible Host Controller Interface for Universal Serial Bus (USB) Specification 3.0. Programming this field with random data will cause side effect i.e. Register Access will fail (Timeout) if the pipe clock is not running or reset is asserted. Bit Bash register testing is not recommended."
  default = "0x00000000"
  offset = "0x00000580"
  [[register.field]]
    name = "DB_STREAM_ID"
    bits = "31:16"
    type = "rw"
    shortdesc = '''DB_STREAM_ID For a description of this standard USB register field, see the eXtensible Host Controller Interface for Universal Serial Bus (USB) Specification 3.'''
    longdesc = '''0.'''
  [[register.field]]
    name = "RESERVED"
    bits = "15:8"
    type = "ro"
  [[register.field]]
    name = "DB_TARGET"
    bits = "7:0"
    type = "rw"
    shortdesc = '''DB_TARGET For a description of this standard USB register field, see the eXtensible Host Controller Interface for Universal Serial Bus (USB) Specification 3.'''
    longdesc = '''0.'''
[[register]]
  name = "DB41"
  type = "mixed"
  width = 32
  description = "Doorbell Register Bit Field Definitions For a description of this standard USB register field, see the eXtensible Host Controller Interface for Universal Serial Bus (USB) Specification 3.0. Programming this field with random data will cause side effect i.e. Register Access will fail (Timeout) if the pipe clock is not running or reset is asserted. Bit Bash register testing is not recommended."
  default = "0x00000000"
  offset = "0x00000584"
  [[register.field]]
    name = "DB_STREAM_ID"
    bits = "31:16"
    type = "rw"
    shortdesc = '''DB_STREAM_ID For a description of this standard USB register field, see the eXtensible Host Controller Interface for Universal Serial Bus (USB) Specification 3.'''
    longdesc = '''0.'''
  [[register.field]]
    name = "RESERVED"
    bits = "15:8"
    type = "ro"
  [[register.field]]
    name = "DB_TARGET"
    bits = "7:0"
    type = "rw"
    shortdesc = '''DB_TARGET For a description of this standard USB register field, see the eXtensible Host Controller Interface for Universal Serial Bus (USB) Specification 3.'''
    longdesc = '''0.'''
[[register]]
  name = "DB42"
  type = "mixed"
  width = 32
  description = "Doorbell Register Bit Field Definitions For a description of this standard USB register field, see the eXtensible Host Controller Interface for Universal Serial Bus (USB) Specification 3.0. Programming this field with random data will cause side effect i.e. Register Access will fail (Timeout) if the pipe clock is not running or reset is asserted. Bit Bash register testing is not recommended."
  default = "0x00000000"
  offset = "0x00000588"
  [[register.field]]
    name = "DB_STREAM_ID"
    bits = "31:16"
    type = "rw"
    shortdesc = '''DB_STREAM_ID For a description of this standard USB register field, see the eXtensible Host Controller Interface for Universal Serial Bus (USB) Specification 3.'''
    longdesc = '''0.'''
  [[register.field]]
    name = "RESERVED"
    bits = "15:8"
    type = "ro"
  [[register.field]]
    name = "DB_TARGET"
    bits = "7:0"
    type = "rw"
    shortdesc = '''DB_TARGET For a description of this standard USB register field, see the eXtensible Host Controller Interface for Universal Serial Bus (USB) Specification 3.'''
    longdesc = '''0.'''
[[register]]
  name = "DB43"
  type = "mixed"
  width = 32
  description = "Doorbell Register Bit Field Definitions For a description of this standard USB register field, see the eXtensible Host Controller Interface for Universal Serial Bus (USB) Specification 3.0. Programming this field with random data will cause side effect i.e. Register Access will fail (Timeout) if the pipe clock is not running or reset is asserted. Bit Bash register testing is not recommended."
  default = "0x00000000"
  offset = "0x0000058C"
  [[register.field]]
    name = "DB_STREAM_ID"
    bits = "31:16"
    type = "rw"
    shortdesc = '''DB_STREAM_ID For a description of this standard USB register field, see the eXtensible Host Controller Interface for Universal Serial Bus (USB) Specification 3.'''
    longdesc = '''0.'''
  [[register.field]]
    name = "RESERVED"
    bits = "15:8"
    type = "ro"
  [[register.field]]
    name = "DB_TARGET"
    bits = "7:0"
    type = "rw"
    shortdesc = '''DB_TARGET For a description of this standard USB register field, see the eXtensible Host Controller Interface for Universal Serial Bus (USB) Specification 3.'''
    longdesc = '''0.'''
[[register]]
  name = "DB44"
  type = "mixed"
  width = 32
  description = "Doorbell Register Bit Field Definitions For a description of this standard USB register field, see the eXtensible Host Controller Interface for Universal Serial Bus (USB) Specification 3.0. Programming this field with random data will cause side effect i.e. Register Access will fail (Timeout) if the pipe clock is not running or reset is asserted. Bit Bash register testing is not recommended."
  default = "0x00000000"
  offset = "0x00000590"
  [[register.field]]
    name = "DB_STREAM_ID"
    bits = "31:16"
    type = "rw"
    shortdesc = '''DB_STREAM_ID For a description of this standard USB register field, see the eXtensible Host Controller Interface for Universal Serial Bus (USB) Specification 3.'''
    longdesc = '''0.'''
  [[register.field]]
    name = "RESERVED"
    bits = "15:8"
    type = "ro"
  [[register.field]]
    name = "DB_TARGET"
    bits = "7:0"
    type = "rw"
    shortdesc = '''DB_TARGET For a description of this standard USB register field, see the eXtensible Host Controller Interface for Universal Serial Bus (USB) Specification 3.'''
    longdesc = '''0.'''
[[register]]
  name = "DB45"
  type = "mixed"
  width = 32
  description = "Doorbell Register Bit Field Definitions For a description of this standard USB register field, see the eXtensible Host Controller Interface for Universal Serial Bus (USB) Specification 3.0. Programming this field with random data will cause side effect i.e. Register Access will fail (Timeout) if the pipe clock is not running or reset is asserted. Bit Bash register testing is not recommended."
  default = "0x00000000"
  offset = "0x00000594"
  [[register.field]]
    name = "DB_STREAM_ID"
    bits = "31:16"
    type = "rw"
    shortdesc = '''DB_STREAM_ID For a description of this standard USB register field, see the eXtensible Host Controller Interface for Universal Serial Bus (USB) Specification 3.'''
    longdesc = '''0.'''
  [[register.field]]
    name = "RESERVED"
    bits = "15:8"
    type = "ro"
  [[register.field]]
    name = "DB_TARGET"
    bits = "7:0"
    type = "rw"
    shortdesc = '''DB_TARGET For a description of this standard USB register field, see the eXtensible Host Controller Interface for Universal Serial Bus (USB) Specification 3.'''
    longdesc = '''0.'''
[[register]]
  name = "DB46"
  type = "mixed"
  width = 32
  description = "Doorbell Register Bit Field Definitions For a description of this standard USB register field, see the eXtensible Host Controller Interface for Universal Serial Bus (USB) Specification 3.0. Programming this field with random data will cause side effect i.e. Register Access will fail (Timeout) if the pipe clock is not running or reset is asserted. Bit Bash register testing is not recommended."
  default = "0x00000000"
  offset = "0x00000598"
  [[register.field]]
    name = "DB_STREAM_ID"
    bits = "31:16"
    type = "rw"
    shortdesc = '''DB_STREAM_ID For a description of this standard USB register field, see the eXtensible Host Controller Interface for Universal Serial Bus (USB) Specification 3.'''
    longdesc = '''0.'''
  [[register.field]]
    name = "RESERVED"
    bits = "15:8"
    type = "ro"
  [[register.field]]
    name = "DB_TARGET"
    bits = "7:0"
    type = "rw"
    shortdesc = '''DB_TARGET For a description of this standard USB register field, see the eXtensible Host Controller Interface for Universal Serial Bus (USB) Specification 3.'''
    longdesc = '''0.'''
[[register]]
  name = "DB47"
  type = "mixed"
  width = 32
  description = "Doorbell Register Bit Field Definitions For a description of this standard USB register field, see the eXtensible Host Controller Interface for Universal Serial Bus (USB) Specification 3.0. Programming this field with random data will cause side effect i.e. Register Access will fail (Timeout) if the pipe clock is not running or reset is asserted. Bit Bash register testing is not recommended."
  default = "0x00000000"
  offset = "0x0000059C"
  [[register.field]]
    name = "DB_STREAM_ID"
    bits = "31:16"
    type = "rw"
    shortdesc = '''DB_STREAM_ID For a description of this standard USB register field, see the eXtensible Host Controller Interface for Universal Serial Bus (USB) Specification 3.'''
    longdesc = '''0.'''
  [[register.field]]
    name = "RESERVED"
    bits = "15:8"
    type = "ro"
  [[register.field]]
    name = "DB_TARGET"
    bits = "7:0"
    type = "rw"
    shortdesc = '''DB_TARGET For a description of this standard USB register field, see the eXtensible Host Controller Interface for Universal Serial Bus (USB) Specification 3.'''
    longdesc = '''0.'''
[[register]]
  name = "DB48"
  type = "mixed"
  width = 32
  description = "Doorbell Register Bit Field Definitions For a description of this standard USB register field, see the eXtensible Host Controller Interface for Universal Serial Bus (USB) Specification 3.0. Programming this field with random data will cause side effect i.e. Register Access will fail (Timeout) if the pipe clock is not running or reset is asserted. Bit Bash register testing is not recommended."
  default = "0x00000000"
  offset = "0x000005A0"
  [[register.field]]
    name = "DB_STREAM_ID"
    bits = "31:16"
    type = "rw"
    shortdesc = '''DB_STREAM_ID For a description of this standard USB register field, see the eXtensible Host Controller Interface for Universal Serial Bus (USB) Specification 3.'''
    longdesc = '''0.'''
  [[register.field]]
    name = "RESERVED"
    bits = "15:8"
    type = "ro"
  [[register.field]]
    name = "DB_TARGET"
    bits = "7:0"
    type = "rw"
    shortdesc = '''DB_TARGET For a description of this standard USB register field, see the eXtensible Host Controller Interface for Universal Serial Bus (USB) Specification 3.'''
    longdesc = '''0.'''
[[register]]
  name = "DB49"
  type = "mixed"
  width = 32
  description = "Doorbell Register Bit Field Definitions For a description of this standard USB register field, see the eXtensible Host Controller Interface for Universal Serial Bus (USB) Specification 3.0. Programming this field with random data will cause side effect i.e. Register Access will fail (Timeout) if the pipe clock is not running or reset is asserted. Bit Bash register testing is not recommended."
  default = "0x00000000"
  offset = "0x000005A4"
  [[register.field]]
    name = "DB_STREAM_ID"
    bits = "31:16"
    type = "rw"
    shortdesc = '''DB_STREAM_ID For a description of this standard USB register field, see the eXtensible Host Controller Interface for Universal Serial Bus (USB) Specification 3.'''
    longdesc = '''0.'''
  [[register.field]]
    name = "RESERVED"
    bits = "15:8"
    type = "ro"
  [[register.field]]
    name = "DB_TARGET"
    bits = "7:0"
    type = "rw"
    shortdesc = '''DB_TARGET For a description of this standard USB register field, see the eXtensible Host Controller Interface for Universal Serial Bus (USB) Specification 3.'''
    longdesc = '''0.'''
[[register]]
  name = "DB50"
  type = "mixed"
  width = 32
  description = "Doorbell Register Bit Field Definitions For a description of this standard USB register field, see the eXtensible Host Controller Interface for Universal Serial Bus (USB) Specification 3.0. Programming this field with random data will cause side effect i.e. Register Access will fail (Timeout) if the pipe clock is not running or reset is asserted. Bit Bash register testing is not recommended."
  default = "0x00000000"
  offset = "0x000005A8"
  [[register.field]]
    name = "DB_STREAM_ID"
    bits = "31:16"
    type = "rw"
    shortdesc = '''DB_STREAM_ID For a description of this standard USB register field, see the eXtensible Host Controller Interface for Universal Serial Bus (USB) Specification 3.'''
    longdesc = '''0.'''
  [[register.field]]
    name = "RESERVED"
    bits = "15:8"
    type = "ro"
  [[register.field]]
    name = "DB_TARGET"
    bits = "7:0"
    type = "rw"
    shortdesc = '''DB_TARGET For a description of this standard USB register field, see the eXtensible Host Controller Interface for Universal Serial Bus (USB) Specification 3.'''
    longdesc = '''0.'''
[[register]]
  name = "DB51"
  type = "mixed"
  width = 32
  description = "Doorbell Register Bit Field Definitions For a description of this standard USB register field, see the eXtensible Host Controller Interface for Universal Serial Bus (USB) Specification 3.0. Programming this field with random data will cause side effect i.e. Register Access will fail (Timeout) if the pipe clock is not running or reset is asserted. Bit Bash register testing is not recommended."
  default = "0x00000000"
  offset = "0x000005AC"
  [[register.field]]
    name = "DB_STREAM_ID"
    bits = "31:16"
    type = "rw"
    shortdesc = '''DB_STREAM_ID For a description of this standard USB register field, see the eXtensible Host Controller Interface for Universal Serial Bus (USB) Specification 3.'''
    longdesc = '''0.'''
  [[register.field]]
    name = "RESERVED"
    bits = "15:8"
    type = "ro"
  [[register.field]]
    name = "DB_TARGET"
    bits = "7:0"
    type = "rw"
    shortdesc = '''DB_TARGET For a description of this standard USB register field, see the eXtensible Host Controller Interface for Universal Serial Bus (USB) Specification 3.'''
    longdesc = '''0.'''
[[register]]
  name = "DB52"
  type = "mixed"
  width = 32
  description = "Doorbell Register Bit Field Definitions For a description of this standard USB register field, see the eXtensible Host Controller Interface for Universal Serial Bus (USB) Specification 3.0. Programming this field with random data will cause side effect i.e. Register Access will fail (Timeout) if the pipe clock is not running or reset is asserted. Bit Bash register testing is not recommended."
  default = "0x00000000"
  offset = "0x000005B0"
  [[register.field]]
    name = "DB_STREAM_ID"
    bits = "31:16"
    type = "rw"
    shortdesc = '''DB_STREAM_ID For a description of this standard USB register field, see the eXtensible Host Controller Interface for Universal Serial Bus (USB) Specification 3.'''
    longdesc = '''0.'''
  [[register.field]]
    name = "RESERVED"
    bits = "15:8"
    type = "ro"
  [[register.field]]
    name = "DB_TARGET"
    bits = "7:0"
    type = "rw"
    shortdesc = '''DB_TARGET For a description of this standard USB register field, see the eXtensible Host Controller Interface for Universal Serial Bus (USB) Specification 3.'''
    longdesc = '''0.'''
[[register]]
  name = "DB53"
  type = "mixed"
  width = 32
  description = "Doorbell Register Bit Field Definitions For a description of this standard USB register field, see the eXtensible Host Controller Interface for Universal Serial Bus (USB) Specification 3.0. Programming this field with random data will cause side effect i.e. Register Access will fail (Timeout) if the pipe clock is not running or reset is asserted. Bit Bash register testing is not recommended."
  default = "0x00000000"
  offset = "0x000005B4"
  [[register.field]]
    name = "DB_STREAM_ID"
    bits = "31:16"
    type = "rw"
    shortdesc = '''DB_STREAM_ID For a description of this standard USB register field, see the eXtensible Host Controller Interface for Universal Serial Bus (USB) Specification 3.'''
    longdesc = '''0.'''
  [[register.field]]
    name = "RESERVED"
    bits = "15:8"
    type = "ro"
  [[register.field]]
    name = "DB_TARGET"
    bits = "7:0"
    type = "rw"
    shortdesc = '''DB_TARGET For a description of this standard USB register field, see the eXtensible Host Controller Interface for Universal Serial Bus (USB) Specification 3.'''
    longdesc = '''0.'''
[[register]]
  name = "DB54"
  type = "mixed"
  width = 32
  description = "Doorbell Register Bit Field Definitions For a description of this standard USB register field, see the eXtensible Host Controller Interface for Universal Serial Bus (USB) Specification 3.0. Programming this field with random data will cause side effect i.e. Register Access will fail (Timeout) if the pipe clock is not running or reset is asserted. Bit Bash register testing is not recommended."
  default = "0x00000000"
  offset = "0x000005B8"
  [[register.field]]
    name = "DB_STREAM_ID"
    bits = "31:16"
    type = "rw"
    shortdesc = '''DB_STREAM_ID For a description of this standard USB register field, see the eXtensible Host Controller Interface for Universal Serial Bus (USB) Specification 3.'''
    longdesc = '''0.'''
  [[register.field]]
    name = "RESERVED"
    bits = "15:8"
    type = "ro"
  [[register.field]]
    name = "DB_TARGET"
    bits = "7:0"
    type = "rw"
    shortdesc = '''DB_TARGET For a description of this standard USB register field, see the eXtensible Host Controller Interface for Universal Serial Bus (USB) Specification 3.'''
    longdesc = '''0.'''
[[register]]
  name = "DB55"
  type = "mixed"
  width = 32
  description = "Doorbell Register Bit Field Definitions For a description of this standard USB register field, see the eXtensible Host Controller Interface for Universal Serial Bus (USB) Specification 3.0. Programming this field with random data will cause side effect i.e. Register Access will fail (Timeout) if the pipe clock is not running or reset is asserted. Bit Bash register testing is not recommended."
  default = "0x00000000"
  offset = "0x000005BC"
  [[register.field]]
    name = "DB_STREAM_ID"
    bits = "31:16"
    type = "rw"
    shortdesc = '''DB_STREAM_ID For a description of this standard USB register field, see the eXtensible Host Controller Interface for Universal Serial Bus (USB) Specification 3.'''
    longdesc = '''0.'''
  [[register.field]]
    name = "RESERVED"
    bits = "15:8"
    type = "ro"
  [[register.field]]
    name = "DB_TARGET"
    bits = "7:0"
    type = "rw"
    shortdesc = '''DB_TARGET For a description of this standard USB register field, see the eXtensible Host Controller Interface for Universal Serial Bus (USB) Specification 3.'''
    longdesc = '''0.'''
[[register]]
  name = "DB56"
  type = "mixed"
  width = 32
  description = "Doorbell Register Bit Field Definitions For a description of this standard USB register field, see the eXtensible Host Controller Interface for Universal Serial Bus (USB) Specification 3.0. Programming this field with random data will cause side effect i.e. Register Access will fail (Timeout) if the pipe clock is not running or reset is asserted. Bit Bash register testing is not recommended."
  default = "0x00000000"
  offset = "0x000005C0"
  [[register.field]]
    name = "DB_STREAM_ID"
    bits = "31:16"
    type = "rw"
    shortdesc = '''DB_STREAM_ID For a description of this standard USB register field, see the eXtensible Host Controller Interface for Universal Serial Bus (USB) Specification 3.'''
    longdesc = '''0.'''
  [[register.field]]
    name = "RESERVED"
    bits = "15:8"
    type = "ro"
  [[register.field]]
    name = "DB_TARGET"
    bits = "7:0"
    type = "rw"
    shortdesc = '''DB_TARGET For a description of this standard USB register field, see the eXtensible Host Controller Interface for Universal Serial Bus (USB) Specification 3.'''
    longdesc = '''0.'''
[[register]]
  name = "DB57"
  type = "mixed"
  width = 32
  description = "Doorbell Register Bit Field Definitions For a description of this standard USB register field, see the eXtensible Host Controller Interface for Universal Serial Bus (USB) Specification 3.0. Programming this field with random data will cause side effect i.e. Register Access will fail (Timeout) if the pipe clock is not running or reset is asserted. Bit Bash register testing is not recommended."
  default = "0x00000000"
  offset = "0x000005C4"
  [[register.field]]
    name = "DB_STREAM_ID"
    bits = "31:16"
    type = "rw"
    shortdesc = '''DB_STREAM_ID For a description of this standard USB register field, see the eXtensible Host Controller Interface for Universal Serial Bus (USB) Specification 3.'''
    longdesc = '''0.'''
  [[register.field]]
    name = "RESERVED"
    bits = "15:8"
    type = "ro"
  [[register.field]]
    name = "DB_TARGET"
    bits = "7:0"
    type = "rw"
    shortdesc = '''DB_TARGET For a description of this standard USB register field, see the eXtensible Host Controller Interface for Universal Serial Bus (USB) Specification 3.'''
    longdesc = '''0.'''
[[register]]
  name = "DB58"
  type = "mixed"
  width = 32
  description = "Doorbell Register Bit Field Definitions For a description of this standard USB register field, see the eXtensible Host Controller Interface for Universal Serial Bus (USB) Specification 3.0. Programming this field with random data will cause side effect i.e. Register Access will fail (Timeout) if the pipe clock is not running or reset is asserted. Bit Bash register testing is not recommended."
  default = "0x00000000"
  offset = "0x000005C8"
  [[register.field]]
    name = "DB_STREAM_ID"
    bits = "31:16"
    type = "rw"
    shortdesc = '''DB_STREAM_ID For a description of this standard USB register field, see the eXtensible Host Controller Interface for Universal Serial Bus (USB) Specification 3.'''
    longdesc = '''0.'''
  [[register.field]]
    name = "RESERVED"
    bits = "15:8"
    type = "ro"
  [[register.field]]
    name = "DB_TARGET"
    bits = "7:0"
    type = "rw"
    shortdesc = '''DB_TARGET For a description of this standard USB register field, see the eXtensible Host Controller Interface for Universal Serial Bus (USB) Specification 3.'''
    longdesc = '''0.'''
[[register]]
  name = "DB59"
  type = "mixed"
  width = 32
  description = "Doorbell Register Bit Field Definitions For a description of this standard USB register field, see the eXtensible Host Controller Interface for Universal Serial Bus (USB) Specification 3.0. Programming this field with random data will cause side effect i.e. Register Access will fail (Timeout) if the pipe clock is not running or reset is asserted. Bit Bash register testing is not recommended."
  default = "0x00000000"
  offset = "0x000005CC"
  [[register.field]]
    name = "DB_STREAM_ID"
    bits = "31:16"
    type = "rw"
    shortdesc = '''DB_STREAM_ID For a description of this standard USB register field, see the eXtensible Host Controller Interface for Universal Serial Bus (USB) Specification 3.'''
    longdesc = '''0.'''
  [[register.field]]
    name = "RESERVED"
    bits = "15:8"
    type = "ro"
  [[register.field]]
    name = "DB_TARGET"
    bits = "7:0"
    type = "rw"
    shortdesc = '''DB_TARGET For a description of this standard USB register field, see the eXtensible Host Controller Interface for Universal Serial Bus (USB) Specification 3.'''
    longdesc = '''0.'''
[[register]]
  name = "DB60"
  type = "mixed"
  width = 32
  description = "Doorbell Register Bit Field Definitions For a description of this standard USB register field, see the eXtensible Host Controller Interface for Universal Serial Bus (USB) Specification 3.0. Programming this field with random data will cause side effect i.e. Register Access will fail (Timeout) if the pipe clock is not running or reset is asserted. Bit Bash register testing is not recommended."
  default = "0x00000000"
  offset = "0x000005D0"
  [[register.field]]
    name = "DB_STREAM_ID"
    bits = "31:16"
    type = "rw"
    shortdesc = '''DB_STREAM_ID For a description of this standard USB register field, see the eXtensible Host Controller Interface for Universal Serial Bus (USB) Specification 3.'''
    longdesc = '''0.'''
  [[register.field]]
    name = "RESERVED"
    bits = "15:8"
    type = "ro"
  [[register.field]]
    name = "DB_TARGET"
    bits = "7:0"
    type = "rw"
    shortdesc = '''DB_TARGET For a description of this standard USB register field, see the eXtensible Host Controller Interface for Universal Serial Bus (USB) Specification 3.'''
    longdesc = '''0.'''
[[register]]
  name = "DB61"
  type = "mixed"
  width = 32
  description = "Doorbell Register Bit Field Definitions For a description of this standard USB register field, see the eXtensible Host Controller Interface for Universal Serial Bus (USB) Specification 3.0. Programming this field with random data will cause side effect i.e. Register Access will fail (Timeout) if the pipe clock is not running or reset is asserted. Bit Bash register testing is not recommended."
  default = "0x00000000"
  offset = "0x000005D4"
  [[register.field]]
    name = "DB_STREAM_ID"
    bits = "31:16"
    type = "rw"
    shortdesc = '''DB_STREAM_ID For a description of this standard USB register field, see the eXtensible Host Controller Interface for Universal Serial Bus (USB) Specification 3.'''
    longdesc = '''0.'''
  [[register.field]]
    name = "RESERVED"
    bits = "15:8"
    type = "ro"
  [[register.field]]
    name = "DB_TARGET"
    bits = "7:0"
    type = "rw"
    shortdesc = '''DB_TARGET For a description of this standard USB register field, see the eXtensible Host Controller Interface for Universal Serial Bus (USB) Specification 3.'''
    longdesc = '''0.'''
[[register]]
  name = "DB62"
  type = "mixed"
  width = 32
  description = "Doorbell Register Bit Field Definitions For a description of this standard USB register field, see the eXtensible Host Controller Interface for Universal Serial Bus (USB) Specification 3.0. Programming this field with random data will cause side effect i.e. Register Access will fail (Timeout) if the pipe clock is not running or reset is asserted. Bit Bash register testing is not recommended."
  default = "0x00000000"
  offset = "0x000005D8"
  [[register.field]]
    name = "DB_STREAM_ID"
    bits = "31:16"
    type = "rw"
    shortdesc = '''DB_STREAM_ID For a description of this standard USB register field, see the eXtensible Host Controller Interface for Universal Serial Bus (USB) Specification 3.'''
    longdesc = '''0.'''
  [[register.field]]
    name = "RESERVED"
    bits = "15:8"
    type = "ro"
  [[register.field]]
    name = "DB_TARGET"
    bits = "7:0"
    type = "rw"
    shortdesc = '''DB_TARGET For a description of this standard USB register field, see the eXtensible Host Controller Interface for Universal Serial Bus (USB) Specification 3.'''
    longdesc = '''0.'''
[[register]]
  name = "DB63"
  type = "mixed"
  width = 32
  description = "Doorbell Register Bit Field Definitions For a description of this standard USB register field, see the eXtensible Host Controller Interface for Universal Serial Bus (USB) Specification 3.0. Programming this field with random data will cause side effect i.e. Register Access will fail (Timeout) if the pipe clock is not running or reset is asserted. Bit Bash register testing is not recommended."
  default = "0x00000000"
  offset = "0x000005DC"
  [[register.field]]
    name = "DB_STREAM_ID"
    bits = "31:16"
    type = "rw"
    shortdesc = '''DB_STREAM_ID For a description of this standard USB register field, see the eXtensible Host Controller Interface for Universal Serial Bus (USB) Specification 3.'''
    longdesc = '''0.'''
  [[register.field]]
    name = "RESERVED"
    bits = "15:8"
    type = "ro"
  [[register.field]]
    name = "DB_TARGET"
    bits = "7:0"
    type = "rw"
    shortdesc = '''DB_TARGET For a description of this standard USB register field, see the eXtensible Host Controller Interface for Universal Serial Bus (USB) Specification 3.'''
    longdesc = '''0.'''
[[register]]
  name = "USBLEGSUP"
  type = "mixed"
  width = 32
  description = "USBLEGSUP"
  default = "0x00000000"
  offset = "0x000008E0"
  [[register.field]]
    name = "RESERVED"
    bits = "31:25"
    type = "ro"
  [[register.field]]
    name = "HC_OS_OWNED"
    bits = "24"
    type = "rw"
    shortdesc = '''HC_OS_OWNED SEMAPHORE For a description of this standard USB register field, see the eXtensible Host Controller Interface for Universal Serial Bus (USB) Specification 3.'''
    longdesc = '''0.'''
  [[register.field]]
    name = "RESERVED"
    bits = "23:17"
    type = "ro"
  [[register.field]]
    name = "HC_BIOS_OWNED"
    bits = "16"
    type = "rw"
    shortdesc = '''HC_BIOS_OWNED SEMAPHORE For a description of this standard USB register field, see the eXtensible Host Controller Interface for Universal Serial Bus (USB) Specification 3.'''
    longdesc = '''0.'''
  [[register.field]]
    name = "NEXT_CAPABILITY_POINTER"
    bits = "15:8"
    type = "ro"
    shortdesc = '''NEXT_CAPABILITY_POINTER For a description of this standard USB register field, see the eXtensible Host Controller Interface for Universal Serial Bus (USB) Specification 3.'''
    longdesc = '''0.'''
  [[register.field]]
    name = "CAPABILITY_ID"
    bits = "7:0"
    type = "ro"
    shortdesc = '''CAPABILITY_ID set_register_field_attribute DWC_usb3_map/DWC_usb3_block_HC_Extended_Capability_Register/USBLEGSUP/CAPABILITY_ID RegisterResetValue 0x1 For a description of this standard USB register field, see the eXtensible Host Controller Interface for Universal Serial Bus (USB) Specification 3.'''
    longdesc = '''0.'''
[[register]]
  name = "USBLEGCTLSTS"
  type = "mixed"
  width = 32
  description = "USBLEGCTLSTS"
  default = "0x00000000"
  offset = "0x000008E4"
  [[register.field]]
    name = "SMI_ON_BAR"
    bits = "31"
    type = "wtc"
    shortdesc = '''SMI_ON_BAR For a description of this standard USB register field, see the eXtensible Host Controller Interface for Universal Serial Bus (USB) Specification 3.'''
    longdesc = '''0.'''
  [[register.field]]
    name = "SMI_ON_PCI"
    bits = "30"
    type = "wtc"
    shortdesc = '''SMI_ON_PCI COMMAND For a description of this standard USB register field, see the eXtensible Host Controller Interface for Universal Serial Bus (USB) Specification 3.'''
    longdesc = '''0.'''
  [[register.field]]
    name = "SMI_ON_OS"
    bits = "29"
    type = "wtc"
    shortdesc = '''SMI_ON_OS OWNERSHIP CHANGE For a description of this standard USB register field, see the eXtensible Host Controller Interface for Universal Serial Bus (USB) Specification 3.'''
    longdesc = '''0.'''
  [[register.field]]
    name = "RESERVED"
    bits = "28:21"
    type = "ro"
  [[register.field]]
    name = "SMI_ON_HOST"
    bits = "20"
    type = "ro"
    shortdesc = '''SMI_ON_HOST SYSTEM ERROR For a description of this standard USB register field, see the eXtensible Host Controller Interface for Universal Serial Bus (USB) Specification 3.'''
    longdesc = '''0.'''
  [[register.field]]
    name = "RESERVED"
    bits = "19:17"
    type = "ro"
  [[register.field]]
    name = "SMI_ON_EVENT"
    bits = "16"
    type = "ro"
    shortdesc = '''SMI_ON_EVENT INTERRUPT For a description of this standard USB register field, see the eXtensible Host Controller Interface for Universal Serial Bus (USB) Specification 3.'''
    longdesc = '''0.'''
  [[register.field]]
    name = "SMI_ON_BAR_E"
    bits = "15"
    type = "rw"
    shortdesc = '''SMI_ON_BAR ENABLE For a description of this standard USB register field, see the eXtensible Host Controller Interface for Universal Serial Bus (USB) Specification 3.'''
    longdesc = '''0.'''
  [[register.field]]
    name = "SMI_ON_PCI_E"
    bits = "14"
    type = "rw"
    shortdesc = '''SMI_ON_PCI COMMAND ENABLE For a description of this standard USB register field, see the eXtensible Host Controller Interface for Universal Serial Bus (USB) Specification 3.'''
    longdesc = '''0.'''
  [[register.field]]
    name = "SMI_ON_OS_E"
    bits = "13"
    type = "rw"
    shortdesc = '''SMI_ON_OS OWNERSHIP ENABLE For a description of this standard USB register field, see the eXtensible Host Controller Interface for Universal Serial Bus (USB) Specification 3.'''
    longdesc = '''0.'''
  [[register.field]]
    name = "RESERVED"
    bits = "12:5"
    type = "ro"
  [[register.field]]
    name = "SMI_ON_HOST_E"
    bits = "4"
    type = "rw"
    shortdesc = '''SMI_ON_HOST SYSTEM ERROR ENABLE For a description of this standard USB register field, see the eXtensible Host Controller Interface for Universal Serial Bus (USB) Specification 3.'''
    longdesc = '''0.'''
  [[register.field]]
    name = "RESERVED"
    bits = "3:1"
    type = "ro"
  [[register.field]]
    name = "USB_SMI_ENABLE"
    bits = "0"
    type = "rw"
    shortdesc = '''USB_SMI_ENABLE For a description of this standard USB register field, see the eXtensible Host Controller Interface for Universal Serial Bus (USB) Specification 3.'''
    longdesc = '''0.'''
[[register]]
  name = "SUPTPRT2_DW0"
  type = "ro"
  width = 32
  description = "SUPTPRT2_DW0"
  default = "0x02000402"
  offset = "0x000008F0"
  [[register.field]]
    name = "MAJOR_REVISION"
    bits = "31:24"
    type = "ro"
  [[register.field]]
    name = "MINOR_REVISION"
    bits = "23:16"
    type = "ro"
  [[register.field]]
    name = "NEXT_CAPABILITY_POINTER"
    bits = "15:8"
    type = "ro"
  [[register.field]]
    name = "CAPABILITY_ID"
    bits = "7:0"
    type = "ro"
    shortdesc = '''CAPABILITY_ID For a description of this standard USB register field, see the eXtensible Host Controller Interface for Universal Serial Bus (USB) Specification 3.'''
    longdesc = '''0.'''
[[register]]
  name = "SUPTPRT2_DW1"
  type = "ro"
  width = 32
  description = "Register SUPTPRT2_DW1"
  default = "0x20425355"
  offset = "0x000008F4"
  [[register.field]]
    name = "NAME_STRING"
    bits = "31:0"
    type = "ro"
    shortdesc = '''NAME_STRING For a description of this standard USB register field, see the eXtensible Host Controller Interface for Universal Serial Bus (USB) Specification 3.'''
    longdesc = '''0.'''
[[register]]
  name = "SUPTPRT2_DW2"
  type = "ro"
  width = 32
  description = "xHCI Supported Protocol Capability_ Data Word 2 For a description of other register fields, see section 7.2 of the eXtensible Host Controller Interface for Universal Serial Bus (USB) Specification 3.0."
  default = "0x00080201"
  offset = "0x000008F8"
  [[register.field]]
    name = "PSIC"
    bits = "31:28"
    type = "ro"
  [[register.field]]
    name = "MHD"
    bits = "27:25"
    type = "ro"
    shortdesc = '''Hub Depth For a description of this standard USB register field, see the eXtensible Host Controller Interface for Universal Serial Bus (USB) Specification 3.'''
    longdesc = '''0.'''
  [[register.field]]
    name = "BLC"
    bits = "20"
    type = "ro"
    shortdesc = '''BESL LPM Capability.'''
    longdesc = '''When this bit is set to: - 1: The ports described by this xHCI Supported Protocol Capability applies BESL timing to the BESL and BESLD fields of the PORTPMSC and PORTHLPMC registers. - 0: The ports described by this xHCI Supported Protocol Capability applies HIRD timing to the BESL and BESLD fields of the PORTPMSC and PORTHLPMC registers.'''
  [[register.field]]
    name = "HLC"
    bits = "19"
    type = "ro"
    shortdesc = '''Compatible Port Offset.'''
    longdesc = '''Compatible Port Count Refer to Table 7-3 in the DWC Cores SuperSpeed USB 3.0 Controller Databook.'''
  [[register.field]]
    name = "IHI"
    bits = "18"
    type = "ro"
  [[register.field]]
    name = "HSO"
    bits = "17"
    type = "ro"
  [[register.field]]
    name = "COMPATIBLE_PORT_COUNT"
    bits = "15:8"
    type = "ro"
    shortdesc = '''COMPATIBLE_PORT_COUNT For a description of this standard USB register field, see the eXtensible Host Controller Interface for Universal Serial Bus (USB) Specification 3.'''
    longdesc = '''0.'''
  [[register.field]]
    name = "COMPATIBLE_PORT_OFFSET"
    bits = "7:0"
    type = "ro"
    shortdesc = '''COMPATIBLE_PORT_OFFSET For a description of this standard USB register field, see the eXtensible Host Controller Interface for Universal Serial Bus (USB) Specification 3.'''
    longdesc = '''0.'''
[[register]]
  name = "SUPTPRT2_DW3"
  type = "ro"
  width = 32
  description = "Register SUPTPRT2_DW3"
  default = "0x00000000"
  offset = "0x000008FC"
  [[register.field]]
    name = "RESERVED"
    bits = "31:5"
    type = "ro"
  [[register.field]]
    name = "PROTCL_SLT_TY"
    bits = "4:0"
    type = "ro"
[[register]]
  name = "SUPTPRT3_DW0"
  type = "ro"
  width = 32
  description = "Register SUPTPRT3_DW0"
  default = "0x03000002"
  offset = "0x00000900"
  [[register.field]]
    name = "MAJOR_REVISION"
    bits = "31:24"
    type = "ro"
    shortdesc = '''MAJOR_REVISION For a description of this standard USB register field, see the eXtensible Host Controller Interface for Universal Serial Bus (USB) Specification 3.'''
    longdesc = '''0.'''
  [[register.field]]
    name = "MINOR_REVISION"
    bits = "23:16"
    type = "ro"
    shortdesc = '''MINOR_REVISION For a description of this standard USB register field, see the eXtensible Host Controller Interface for Universal Serial Bus (USB) Specification 3.'''
    longdesc = '''0.'''
  [[register.field]]
    name = "NEXT_CAPABILITY_POINTER"
    bits = "15:8"
    type = "ro"
    shortdesc = '''NEXT_CAPABILITY_POINTER For a description of this standard USB register field, see the eXtensible Host Controller Interface for Universal Serial Bus (USB) Specification 3.'''
    longdesc = '''0.'''
  [[register.field]]
    name = "CAPABILITY_ID"
    bits = "7:0"
    type = "ro"
    shortdesc = '''CAPABILITY_ID For a description of this standard USB register field, see the eXtensible Host Controller Interface for Universal Serial Bus (USB) Specification 3.'''
    longdesc = '''0.'''
[[register]]
  name = "SUPTPRT3_DW1"
  type = "ro"
  width = 32
  description = "Register SUPTPRT3_DW1"
  default = "0x20425355"
  offset = "0x00000904"
  [[register.field]]
    name = "NAME_STRING"
    bits = "31:0"
    type = "ro"
    shortdesc = '''NAME_STRING For a description of this standard USB register field, see the eXtensible Host Controller Interface for Universal Serial Bus (USB) Specification 3.'''
    longdesc = '''0.'''
[[register]]
  name = "SUPTPRT3_DW2"
  type = "ro"
  width = 32
  description = "SUPTPRT3_DW2 For a description of this standard USB register field, see the eXtensible Host Controller Interface for Universal Serial Bus (USB) Specification 3.0."
  default = "0x00000002"
  offset = "0x00000908"
  [[register.field]]
    name = "PSIC"
    bits = "31:28"
    type = "ro"
  [[register.field]]
    name = "MHD"
    bits = "27:25"
    type = "ro"
    shortdesc = '''Hub Depth For a description of this standard USB register field, see the eXtensible Host Controller Interface for Universal Serial Bus (USB) Specification 3.'''
    longdesc = '''0.'''
  [[register.field]]
    name = "COMPATIBLE_PORT_COUNT"
    bits = "15:8"
    type = "ro"
    shortdesc = '''COMPATIBLE_PORT_COUNT For a description of this standard USB register field, see the eXtensible Host Controller Interface for Universal Serial Bus (USB) Specification 3.'''
    longdesc = '''0.'''
  [[register.field]]
    name = "COMPATIBLE_PORT_OFFSET"
    bits = "7:0"
    type = "ro"
    shortdesc = '''COMPATIBLE_PORT_OFFSET For a description of this standard USB register field, see the eXtensible Host Controller Interface for Universal Serial Bus (USB) Specification 3.'''
    longdesc = '''0.'''
[[register]]
  name = "SUPTPRT3_DW3"
  type = "ro"
  width = 32
  description = "SUPTPRT3_DW3"
  default = "0x00000000"
  offset = "0x0000090C"
  [[register.field]]
    name = "RESERVED"
    bits = "31:5"
    type = "ro"
  [[register.field]]
    name = "PROTCL_SLT_TY"
    bits = "4:0"
    type = "ro"
[[register]]
  name = "DCID"
  type = "ro"
  width = 32
  description = "DCID"
  default = "0x00000000"
  offset = "0x00000910"
  [[register.field]]
    name = "RESERVED"
    bits = "31:21"
    type = "ro"
  [[register.field]]
    name = "DCERSTMAX"
    bits = "20:16"
    type = "ro"
  [[register.field]]
    name = "NEXT_CAPABILITY_POINTER"
    bits = "15:8"
    type = "ro"
  [[register.field]]
    name = "CAPABILITY_ID"
    bits = "7:0"
    type = "ro"
[[register]]
  name = "DCDB"
  type = "mixed"
  width = 32
  description = "Register DCDB"
  default = "0x00000000"
  offset = "0x00000914"
  [[register.field]]
    name = "RESERVED"
    bits = "31:16"
    type = "ro"
  [[register.field]]
    name = "DBTARGET"
    bits = "15:8"
    type = "rw"
  [[register.field]]
    name = "RESERVED"
    bits = "7:0"
    type = "ro"
[[register]]
  name = "DCERSTSZ"
  type = "mixed"
  width = 32
  description = "DCERSTSZ"
  default = "0x00000000"
  offset = "0x00000918"
  [[register.field]]
    name = "RESERVED"
    bits = "31:16"
    type = "ro"
  [[register.field]]
    name = "ERS_TABLE_SIZE"
    bits = "15:0"
    type = "rw"
[[register]]
  name = "DCERSTBA_LO"
  type = "mixed"
  width = 32
  description = "DCERSTBA_LO"
  default = "0x00000000"
  offset = "0x00000920"
  [[register.field]]
    name = "ERS_TABLE_BAR"
    bits = "31:4"
    type = "rw"
  [[register.field]]
    name = "RESERVED"
    bits = "3:0"
    type = "ro"
[[register]]
  name = "DCERSTBA_HI"
  type = "rw"
  width = 32
  description = "Register DCERSTBA_HI"
  default = "0x00000000"
  offset = "0x00000924"
  [[register.field]]
    name = "ERS_TABLE_BAR"
    bits = "31:0"
    type = "rw"
[[register]]
  name = "DCERDP_LO"
  type = "mixed"
  width = 32
  description = "DCERDP_LO"
  default = "0x00000000"
  offset = "0x00000928"
  [[register.field]]
    name = "DEQUEUE_POINTER"
    bits = "31:4"
    type = "rw"
  [[register.field]]
    name = "RESERVED"
    bits = "3"
    type = "ro"
  [[register.field]]
    name = "DESI"
    bits = "2:0"
    type = "rw"
[[register]]
  name = "DCERDP_HI"
  type = "rw"
  width = 32
  description = "DCERDP_HI"
  default = "0x00000000"
  offset = "0x0000092C"
  [[register.field]]
    name = "DEQUEUE_POINTER"
    bits = "31:0"
    type = "rw"
[[register]]
  name = "DCCTRL"
  type = "mixed"
  width = 32
  description = "DCCTRL"
  default = "0x00000000"
  offset = "0x00000930"
  [[register.field]]
    name = "DCE"
    bits = "31"
    type = "rw"
  [[register.field]]
    name = "DEVICE_ADDRESS"
    bits = "30:24"
    type = "ro"
  [[register.field]]
    name = "DEBUG_MAX_BURST_SIZE"
    bits = "23:16"
    type = "ro"
  [[register.field]]
    name = "RESERVED"
    bits = "15:5"
    type = "ro"
  [[register.field]]
    name = "DRC"
    bits = "4"
    type = "wtc"
  [[register.field]]
    name = "HIT"
    bits = "3"
    type = "rw"
  [[register.field]]
    name = "HOT"
    bits = "2"
    type = "rw"
  [[register.field]]
    name = "LSE"
    bits = "1"
    type = "rw"
  [[register.field]]
    name = "DCR"
    bits = "0"
    type = "ro"
[[register]]
  name = "DCST"
  type = "ro"
  width = 32
  description = "DCST"
  default = "0x00000000"
  offset = "0x00000934"
  [[register.field]]
    name = "DEBUG_PORT_NUMBER"
    bits = "31:24"
    type = "ro"
  [[register.field]]
    name = "RESERVED"
    bits = "23:2"
    type = "ro"
  [[register.field]]
    name = "SBR"
    bits = "1"
    type = "ro"
  [[register.field]]
    name = "ER"
    bits = "0"
    type = "ro"
[[register]]
  name = "DCPORTSC"
  type = "mixed"
  width = 32
  description = "Register DCPORTSC"
  default = "0x00000000"
  offset = "0x00000938"
  [[register.field]]
    name = "RESERVED"
    bits = "31:24"
    type = "ro"
  [[register.field]]
    name = "CEC"
    bits = "23"
    type = "wtc"
  [[register.field]]
    name = "PLC"
    bits = "22"
    type = "wtc"
  [[register.field]]
    name = "PRC"
    bits = "21"
    type = "wtc"
  [[register.field]]
    name = "RESERVED"
    bits = "20:18"
    type = "ro"
  [[register.field]]
    name = "CSC"
    bits = "17"
    type = "wtc"
  [[register.field]]
    name = "RESERVED"
    bits = "16:14"
    type = "ro"
  [[register.field]]
    name = "PORTSPEED"
    bits = "13:10"
    type = "ro"
  [[register.field]]
    name = "RESERVED"
    bits = "9"
    type = "ro"
  [[register.field]]
    name = "PLS"
    bits = "8:5"
    type = "ro"
  [[register.field]]
    name = "PR"
    bits = "4"
    type = "ro"
  [[register.field]]
    name = "RESERVED"
    bits = "3:2"
    type = "ro"
  [[register.field]]
    name = "PED"
    bits = "1"
    type = "rw"
  [[register.field]]
    name = "CCS"
    bits = "0"
    type = "ro"
[[register]]
  name = "DCCP_LO"
  type = "mixed"
  width = 32
  description = "DCCP_LO"
  default = "0x00000000"
  offset = "0x00000940"
  [[register.field]]
    name = "DCCPR"
    bits = "31:4"
    type = "rw"
  [[register.field]]
    name = "RESERVED"
    bits = "3:0"
    type = "ro"
[[register]]
  name = "DCCP_HI"
  type = "rw"
  width = 32
  description = "Register DCCP_HI"
  default = "0x00000000"
  offset = "0x00000944"
  [[register.field]]
    name = "DCCPR"
    bits = "31:0"
    type = "rw"
[[register]]
  name = "DCDDI1"
  type = "rw"
  width = 32
  description = "Register DCDDI1"
  default = "0x00000000"
  offset = "0x00000948"
  [[register.field]]
    name = "VENDORID"
    bits = "31:16"
    type = "rw"
  [[register.field]]
    name = "RESERVED"
    bits = "15:8"
    type = "rw"
  [[register.field]]
    name = "DBCPROTOCOL"
    bits = "7:0"
    type = "rw"
[[register]]
  name = "DCDDI2"
  type = "rw"
  width = 32
  description = "Register DCDDI2"
  default = "0x00000000"
  offset = "0x0000094C"
  [[register.field]]
    name = "DEVICEREV"
    bits = "31:16"
    type = "rw"
  [[register.field]]
    name = "PRODUCTID"
    bits = "15:0"
    type = "rw"
[[register]]
  name = "GSBUSCFG0"
  type = "mixed"
  width = 32
  description = "Global SoC Bus Configuration Register 0 This register configures system bus DMA options for the master bus, which may be configured as AHB, AXI, or Native. Options include burst length and cache type (bufferable/posted, cacheable/snoop, and so on). The application can program this register upon power-on, or a change in mode of operation after the DMA engine is halted. xHCI Register Power-On Value: If you are using a standard xHCI host driver, make sure to set the register's power-on value during coreConsultant configuration (DWC_USB3_GSBUSCFG0_INIT parameter) because the standard xHCI driver does not access this register. For more details on this register, refer to 'Architecture Details' chapter in the Databook."
  default = "0x00000000"
  offset = "0x0000C100"
  [[register.field]]
    name = "DATRDREQINFO"
    bits = "31:28"
    type = "rw"
  [[register.field]]
    name = "DESRDREQINFO"
    bits = "27:24"
    type = "rw"
    shortdesc = '''DESRDREQINFO AHB-prot/AXI-cache/OCP-ReqInfo for Descriptor Read (DesRdReqInfo).'''
    longdesc = '''Input to BUS-GM.'''
  [[register.field]]
    name = "DATWRREQINFO"
    bits = "23:20"
    type = "rw"
    shortdesc = '''DATWRREQINFO AHB-prot/AXI-cache/OCP-ReqInfo for Data Write (DatWrReqInfo).'''
    longdesc = '''Input to BUS-GM.'''
  [[register.field]]
    name = "DESWRREQINFO"
    bits = "19:16"
    type = "rw"
  [[register.field]]
    name = "RESERVED"
    bits = "15:12"
    type = "ro"
  [[register.field]]
    name = "DATBIGEND"
    bits = "11"
    type = "rw"
  [[register.field]]
    name = "DESBIGEND"
    bits = "10"
    type = "rw"
  [[register.field]]
    name = "RESERVED"
    bits = "9:8"
    type = "ro"
  [[register.field]]
    name = "INCR256BRSTENA"
    bits = "7"
    type = "rw"
    shortdesc = '''INCR256 Burst Type Enable Input to BUS-GM.'''
    longdesc = '''For the AHB/AXI configuration, if software set this bit to 1, the AHB/AXI master uses INCR to do the 256-beat burst.'''
  [[register.field]]
    name = "INCR128BRSTENA"
    bits = "6"
    type = "rw"
  [[register.field]]
    name = "INCR64BRSTENA"
    bits = "5"
    type = "rw"
  [[register.field]]
    name = "INCR32BRSTENA"
    bits = "4"
    type = "rw"
  [[register.field]]
    name = "INCR16BRSTENA"
    bits = "3"
    type = "rw"
    shortdesc = '''INCR16 Burst Type Enable Input to BUS-GM.'''
    longdesc = '''For the AHB/AXI configuration, if software set this bit to '1', the AHB/AXI master uses INCR to do the 16-beat burst.'''
  [[register.field]]
    name = "INCR8BRSTENA"
    bits = "2"
    type = "rw"
  [[register.field]]
    name = "INCR4BRSTENA"
    bits = "1"
    type = "rw"
    shortdesc = '''INCR4 Burst Type Enable Input to BUS-GM; For the AXI configuration, when this bit is enabled the controller is allowed to do bursts of beat length 1, 2, 3, and 4.'''
    longdesc = '''It is highly recommended that this bit is enabled to prevent descriptor reads and writes from being broken up into separate transfers.'''
  [[register.field]]
    name = "INCRBRSTENA"
    bits = "0"
    type = "rw"
    shortdesc = '''Undefined Length INCR Burst Type Enable (INCRBrstEna) Input to BUS-GM; This bit determines the set of burst lengths the master interface uses.'''
    longdesc = '''It works in conjunction with the GSBUSCFG0[7:1] enables (INCR256/128/64/32/16/8/4). 0: INCRX burst mode HBURST (for AHB configurations) and ARLEN/AWLEN (for AXI configurations) do not use INCR. They use only the following burst lengths: - 1 - 4 (if GSBUSCFG0.INCR4BrstEna = 1) - 8 (if GSBUSCFG0.INCR8BrstEna = 1) - 16 (if GSBUSCFG0.INCR16BrstEna = 1) - 32 (if GSBUSCFG0.INCR32BrstEna = 1) - 64 (if GSBUSCFG0.INCR64BrstEna = 1) - 128 (if GSBUSCFG0.INCR128BrstEna = 1) - 256 (if GSBUSCFG0.INCR256BrstEna = 1) 1: INCR (undefined length) burst mode - AHB configurations: HBURST uses SINGLE or INCR of any length less than or equal to the largest-enabled burst length of INCR4/8/16/32/64/128/256. - AXI configurations: ARLEN/AWLEN uses any length less than or equal to the largest-enabled burst length of INCR4/8/16/32/64/128/256. For cache line-aligned applications, this bit is typically set to 0 to ensure that the master interface uses only power-of-2 burst lengths (as enabled via GSBUSCFG0[7:0]).'''
[[register]]
  name = "GSBUSCFG1"
  type = "mixed"
  width = 32
  description = "Global SoC Bus Configuration Register 1 xHCI Register Power-On Value: If you are using a standard xHCI host driver, make sure to set the register's power-on value during coreConsultant configuration (DWC_USB3_GSBUSCFG1_INIT parameter) because the standard xHCI driver does not access this register. For more details on this register, refer to 'Architecture Details' chapter in the Databook."
  default = "0x00000000"
  offset = "0x0000C104"
  [[register.field]]
    name = "RESERVED"
    bits = "31:13"
    type = "ro"
  [[register.field]]
    name = "EN1KPAGE"
    bits = "12"
    type = "rw"
    shortdesc = '''1k Page Boundary Enable By default (this bit is disabled) the AXI breaks transfers at the 4k page boundary.'''
    longdesc = '''When this bit is enabled, the AXI master (DMA data) breaks transfers at the 1k page boundary.'''
  [[register.field]]
    name = "PIPETRANSLIMIT"
    bits = "11:8"
    type = "rw"
    shortdesc = '''AXI Pipelined Transfers Burst Request Limit The field controls the number of outstanding pipelined transfer requests the AXI master pushes to the AXI slave.'''
    longdesc = '''When the AXI master reaches this limit, it does not make any more requests on the AXI ARADDR and AWADDR buses until the associated data phases complete. This field is encoded as follows: - 'h0: 1 request - 'h1: 2 requests - 'h2: 3 requests - 'h3: 4 requests - .. - 'hF: 16 requests'''
  [[register.field]]
    name = "RESERVED"
    bits = "7:0"
    type = "ro"
[[register]]
  name = "GTXTHRCFG"
  type = "mixed"
  width = 32
  description = "Global Tx Threshold Control Register For more information on - Using this register, refer to 'Architecture Details' chapter. - Selecting values for the fields of this register, see the 'TX/RX Data FIFO Sizes and TX/RX Threshold Control Register Settings' section in the DWC SuperSpeed USB 3.0 Controller User Guide. Note: - All the fields in GTXTHRCFG register are valid only in Host mode. - GTXTHRCFG register is not applicable for Debug Target. - GTXTHRCFG register is not applicable in USB 2.0-only mode."
  default = "0x00000000"
  offset = "0x0000C108"
  [[register.field]]
    name = "RESERVED"
    bits = "31"
    type = "ro"
  [[register.field]]
    name = "RESERVED"
    bits = "30"
    type = "ro"
  [[register.field]]
    name = "USBTXPKTCNTSEL"
    bits = "29"
    type = "rw"
    shortdesc = '''USB Transmit Packet Count Enable This field enables/disables the USB transmission multi-packet thresholding: - 0: USB transmission multi-packet thresholding is disabled; the core can only start transmission on the USB after the entire packet has been fetched into the corresponding TXFIFO.'''
    longdesc = '''- 1: USB transmission multi-packet thresholding is enabled. The core can only start transmission on the USB after USB Transmit Packet Count amount of packets for the USB transaction (burst) are already in the corresponding TXFIFO. This mode is only valid in the host mode. It is only used for SuperSpeed.'''
  [[register.field]]
    name = "RESERVED"
    bits = "28"
    type = "ro"
  [[register.field]]
    name = "USBTXPKTCNT"
    bits = "27:24"
    type = "rw"
    shortdesc = '''USB Transmit Packet Count This field specifies the number of packets that must be in the TXFIFO before the core can start transmission for the corresponding USB transaction (burst).'''
    longdesc = '''This field is only valid when the USB Transmit Packet Count Enable field is set to one. Valid values are from 1 to 15. Note: This field must be less than or equal to the USB Maximum TX Burst Size field.'''
  [[register.field]]
    name = "USBMAXTXBURSTSIZE"
    bits = "23:16"
    type = "rw"
    shortdesc = '''USB Maximum TX Burst Size When USBTxPktCntSel is 1, this field specifies the Maximum Bulk OUT burst the core can execute.'''
    longdesc = '''When the system bus is slower than the USB, TX FIFO can underrun during a long burst. You can program a smaller value to this field to limit the TX burst size that the core can execute. It only applies to SS Bulk, Isochronous, and Interrupt OUT endpoints in the host mode. Valid values are from 1 to 16.'''
  [[register.field]]
    name = "RESERVED"
    bits = "15"
    type = "ro"
  [[register.field]]
    name = "RESERVED"
    bits = "14"
    type = "ro"
    shortdesc = '''Reserved1(Rsvd/Rs) Register field must write only 0 by the application.'''
    longdesc = '''The read value must be treated as X (unknown).'''
  [[register.field]]
    name = "RESERVED"
    bits = "13:11"
    type = "ro"
    shortdesc = '''Reserved (Rsvd/Rs) The register field must write only 0 by the application.'''
    longdesc = '''The read value must be treated as X (unknown).'''
  [[register.field]]
    name = "RESERVED"
    bits = "10:0"
    type = "ro"
[[register]]
  name = "GRXTHRCFG"
  type = "mixed"
  width = 32
  description = "Global Rx Threshold Control Register In a normal case, a Tx burst starts as soon as one packet is prefetched; an Rx burst starts as soon as 1-packet space is available. This works well as long as the system bus is faster than the USB 3.0 bus (a 1024-bytes packet takes ~2.2 microseconds on the USB bus in SS mode). If the system bus latency is larger than 2.2 microseconds to access a 1024-byte packet, then starting a burst on 1-packet condition leads to an early abort of the burst causing unnecessary performance reduction. To avoid underrun and overrun during the burst, in a high-latency bus system (like USB), threshold and burst size control is provided through GTXTHRCFG and GRXTHRCFG registers. Bit [29] of the GTXTHRCFG and GRXTHRCFG registers enables this feature. For more information on - Using this register, refer to 'Architecture Details' chapter. - Selecting values for the fields of this register, see the 'TX/RX Data FIFO Sizes and TX/RX Threshold Control Register Settings' section in the DWC SuperSpeed USB 3.0 Controller User Guide. Note: - GRXTHRCFG register is not applicable for Debug Target. - GRXTHRCFG register is not applicable in USB 2.0-only mode."
  default = "0x00000000"
  offset = "0x0000C10C"
  [[register.field]]
    name = "RESERVED"
    bits = "31:30"
    type = "ro"
  [[register.field]]
    name = "USBRXPKTCNTSEL"
    bits = "29"
    type = "rw"
    shortdesc = '''USB ReceivePacket Count Enable This field enables/disables the USB reception multi-packet thresholding: - 0: The core can only start reception on the USB when the RX FIFO has space for at least one packet.'''
    longdesc = '''- 1: The core can only start reception on the USB when the RX FIFO has space for at least USBRxPktCnt amount of packets. This mode is valid in both host and device mode. It is only used for SuperSpeed. In device mode, - Setting this bit to 1 also enables the functionality of reporting NUMP in the ACK TP based on the RX FIFO space instead of reporting a fixed NUMP derived from DCFG.NUMP - If you are using external buffer control (EBC) feature, disable this mode by setting USBRxPktCntSel to 0.'''
  [[register.field]]
    name = "RESERVED"
    bits = "28"
    type = "ro"
  [[register.field]]
    name = "USBRXPKTCNT"
    bits = "27:24"
    type = "rw"
    shortdesc = '''USB Receive Packet Count In host mode, this field specifies the space (in terms of the number of packets) that must be available in the RX FIFO before the core can start the corresponding USB RX transaction (burst).'''
    longdesc = '''In device mode, this field specifies the space (in terms of the number of packets) that must be available in the RX FIFO before the core can send ERDY for a flow-controlled endpoint. This field is valid only when the USB Receive Packet Count Enable field is set to 1. The valid values for this field are from 1 to 15. Note: This field must be less than or equal to the USB Maximum Receive Burst Size field.'''
  [[register.field]]
    name = "USBMAXRXBURSTSIZE"
    bits = "23:19"
    type = "rw"
    shortdesc = '''USB Maximum Receive Burst Size In host mode, this field specifies the Maximum Bulk IN burst the DWC_usb3 core can perform.'''
    longdesc = '''When the system bus is slower than the USB, RX FIFO can overrun during a long burst. You can program a smaller value to this field to limit the RX burst size that the core can perform. It only applies to SS Bulk, Isochronous, and Interrupt IN endpoints in the host mode. In device mode, this field specifies the NUMP value that is sent in ERDY for an OUT endpoint. This field is valid only when USBRxPktCntSel is one. The valid values for this field are from 1 to 16.'''
  [[register.field]]
    name = "RESERVED"
    bits = "18:16"
    type = "ro"
  [[register.field]]
    name = "RESERVED"
    bits = "15"
    type = "ro"
  [[register.field]]
    name = "RESERVED"
    bits = "14:13"
    type = "ro"
  [[register.field]]
    name = "RESVISOCOUTSPC"
    bits = "12:0"
    type = "rw"
[[register]]
  name = "GCTL"
  type = "rw"
  width = 32
  description = "Global Core Control Register Refer to <workspace>/src/DWC_usb3_params.v for details on `DWC_USB3_GCTL_INIT. Note: When Hibernation is not enabled, you can write any value to GblHibernationEn. It always returns 0 when read."
  default = "0x00693004"
  offset = "0x0000C110"
  [[register.field]]
    name = "PWRDNSCALE"
    bits = "31:19"
    type = "rw"
    shortdesc = '''Power Down Scale (PwrDnScale) The USB3 suspend_clk input replaces pipe3_rx_pclk as a clock source to a small part of the USB3 core that operates when the SS PHY is in its lowest power (P3) state, and therefore does not provide a clock.'''
    longdesc = '''The Power Down Scale field specifies how many suspend_clk periods fit into a 16 kHz clock period. When performing the division, round up the remainder. For example, when using an 8-bit/16-bit/32-bit PHY and 25-MHz Suspend clock, Power Down Scale = 25000 kHz/16 kHz = 13'd1563 (rounder up) Note: - Minimum Suspend clock frequency is 32 kHz - Maximum Suspend clock frequency is 125 MHz The LTSSM uses Suspend clock for 12-ms and 100-ms timers during suspend mode. According to the USB 3.0 specification, the accuracy on these timers is 0% to +50%. - 12 ms + 0~+50% accuracy = 18 ms (Range is 12 ms - 18 ms) - 100 ms + 0~+50% accuracy = 150 ms (Range is 100 ms - 150 ms). The suspend clock accuracy requirement is: - (12,000/62.5) * (GCTL[31:19]) * actual suspend_clk_period must be between 12,000 and 18,000 - (100,0000/62.5) * (GCTL[31:19]) * actual suspend_clk_period must be between 100,000 and 150,000 For example, if your suspend_clk frequency varies from 7.5 MHz to 10.5MHz, then the value needs to programmed is: Power Down Scale = 10500/16 = 657 (rounded up; and fastest frequency used).'''
  [[register.field]]
    name = "MASTERFILTBYPASS"
    bits = "18"
    type = "rw"
    shortdesc = '''Master Filter Bypass When this bit is set to 1'b1, irrespective of the parameter `DWC_USB3_EN_BUS_FILTERS chosen, all the filters in the DWC_usb3_filter module are bypassed.'''
    longdesc = '''The double synchronizers to mac_clk preceding the filters are also bypassed. For enabling the filters, this bit must be 1'b0.'''
  [[register.field]]
    name = "BYPSSETADDR"
    bits = "17"
    type = "rw"
  shortdesc = '''Bypass SetAddress in Device Mode.'''
  longdesc = '''When BYPSSETADDR bit is set, the device core uses the value in the DCFG[DevAddr] bits directly for comparing the device address in the tokens. For simulation, you can use this feature to avoid sending an actual SET ADDRESS control transfer on the USB, and make the device core respond to a new address. When the xHCI Debug capability is enabled and this bit is set, the Debug Target immediately enters the configured state without requiring the Debug Host to send a SetAddress or SetConfig request. Note: You can set this bit for simulation purposes only. In the actual hardware, this bit must be set to 1'b0.'''
[[register.field]]
name = "U2RSTECN"
bits = "16"
type = "rw"
shortdesc = '''U2RSTECN If the SuperSpeed connection fails during POLL or LMP exchange, the device connects at non-SS mode.'''
longdesc = '''If this bit is set, then device attempts three more times to connect at SS, even if it previously failed to operate in SS mode. For each attempt, the device checks receiver termination eight times. From 2.60a release, this bit controls whether to check for Rx.Detect eight times or one time for every attempt. Device controller on USB 2.0 reset checks for receiver termination eight times per attempt if this bit is set to zero, or only once per attempt if the bit is set to one. Note: This bit is applicable only in device mode.'''
[[register.field]]
name = "FRMSCLDWN"
bits = "15:14"
type = "rw"
shortdesc = '''FRMSCLDWN This field scales down device view of a SOF/USOF/ITP duration.'''
longdesc = '''For SS/HS mode: - Value of 2'h3 implements interval to be 15.625 us - Value of 2'h2 implements interval to be 31.25 us - Value of 2'h1 implements interval to be 62.5 us - Value of 2'h0 implements interval to be 125us For FS mode, the scale-down value is multiplied by 8. When xHCI Debug Capability is enabled, this field also scales down the MaxPacketSize of the IN and OUT bulk endpoint to allow more traffic during simulation. It can only be changed from a non-zero value during simulation. - 2'h0: 1024 bytes - 2'h1: 512 bytes - 2'h2: 256 bytes - 2'h3: 128 bytes'''
[[register.field]]
name = "PRTCAPDIR"
bits = "13:12"
type = "rw"
shortdesc = '''PRTCAPDIR: Port Capability Direction (PrtCapDir) - 2'b01: for Host configurations - 2'b10: for Device configurations - 2'b11: for OTG configurations When DWC_USB3_EN_OTG is 0, then the core acts as a DRD.'''
longdesc = '''When DWC_USB3_EN_OTG is 1, - If PrtCapDir is 2'b11, it acts as an OTG 2.0 device with A-device or B-device determined by the IDDIG input, and Host or Peripheral role based on HNP. - If PrtCapDir is 2'b01, it acts as a DRD in host mode. - If PrtCapDir is 2'b10, it acts as a DRD in device mode. The OTG device can be programmed to enable/disable SRP and HNP by using the fields present in OCFG register. When DWC_USB3_EN_OTG is 2, - If PrtCapDir is 2'b11, it acts as an OTG 3.0 device with A-device or B-device determined by the IDDIG input, and Host or Peripheral role based on HNP/RSP. - If PrtCapDir is 2'b01, it acts as a DRD in host mode. - If PrtCapDir is 2'b10, it acts as a DRD in device mode. The OTG device can be programmed to enable/disable SRP and HNP/RSP using the fields present in the OCFG register. Note: For static Host-only/Device-only applications, use DRD Host or DRD Device mode. The combination of GCTL.PrtCapDir=2'b11 with SRP and HNP/RSP disabled is not recommended for these applications. The sequence for switching modes in DRD configuration is as follows: Switching from Device to Host: 1. Reset the controller using GCTL[11] (CoreSoftReset). 2. Set GCTL[13:12] (PrtCapDir) to 2'b01 (Host mode). 3. Reset the host using USBCMD.HCRESET. 4. Follow the steps in 'Initializing Host Registers' section of the databook. Switching from Host to Device: 1. Reset the controller using GCTL[11] (CoreSoftReset). 2. Set GCTL[13:12] (PrtCapDir) to 2'b10 (Device mode). 3. Reset the device by setting DCTL[30] (CSftRst). 4. Follow the steps in 'Register Initialization' section of the databook. Programming this field with random data causes the core to keep toggling between the host mode and the device mode. Bit Bash register testing is not recommended.'''
[[register.field.enum]]
name = "HOST"
value = 1
[[register.field.enum]]
name = "DEVICE"
value = 2
[[register.field.enum]]
name = "OTG"
value = 3

[[register.field]]
name = "CORESOFTRESET"
bits = "11"
type = "rw"
shortdesc = '''Core Soft Reset (CoreSoftReset) - 1'b0 - No soft reset - 1'b1 - Soft reset to core Clears the interrupts and all the CSRs except the following registers: - GCTL - GUCTL - GSTS - GSNPSID - GGPIO - GUID - GUSB2PHYCFGn registers - GUSB3PIPECTLn registers - DCFG - DCTL - DEVTEN - DSTS When you reset PHYs (using GUBS3PHYCFG or GUSB3PIPECTL registers), you must keep the core in reset state until PHY clocks are stable.'''
longdesc = '''This controls the bus, ram, and mac domain resets. Note: This bit is for debug purposes only. Use USBCMD.HCRESET in xHCI Mode and DCTL.SoftReset in device mode for soft reset. Programming this field with random data will reset the internal logic of the host controller. Due to this side effect Bit Bash register testing is not recommended.'''
[[register.field]]
name = "SOFITPSYNC"
bits = "10"
type = "rw"
shortdesc = '''SOFITPSYNC If this bit is set to '0' operating in host mode, the core keeps the UTMI/ULPI PHY on the first port in a non-suspended state whenever there is a SuperSpeed port that is not in Rx.'''
longdesc = '''Detect, SS.Disable and U3. If this bit is set to '1' operating in host mode, the core keeps the UTMI/ULPI PHY on the first port in a non-suspended state whenever the other non-SuperSpeed ports are not in a suspended state. This feature is useful because it saves power by suspending UTMI/ULPI when SuperSpeed only is active, and it helps resolve when the PHY does not transmit a host resume unless it is placed in suspend state. This bit must be programmed as a part of initialization at power-on reset, and must not be dynamically changed afterwards. Note: - USB2PHYCFGn[6].PhySusp eventually decides to put the UTMI/ULPI PHY in to suspend state. In addition, when this bit is set to '1', the core generates ITP from the ref_clk based counter. Otherwise, ITP and SOF are generated from utmi/ulpi_clk[0] based counter. To program the reference clock period inside the core, refer to GUCTL[31:22].REFCLKPER. - This feature is valid in Host and DRD/OTG configurations and used only in Host mode operation. - If you never use this feature or the GFLADJ.GFLADJ_REFCLK_LPM_SEL, the minimum frequency for the ref_clk can be as low as 32KHz. You can connect the suspend_clk (as low as 32 KHz) to the ref_clk. - If you plan to enable hardware-based LPM or software-based LPM (PORTPMSC. HLE=1), then you cannot use this feature. Turn off this feature by setting this bit to '0' and use the GFLADJ.GFLADJ_REFCLK_LPM_SEL feature. - If you set this bit to '1', the GUSB2PHYCFG.U2_FREECLK_EXISTS bit and the DWC_USB3_FREECLK_USB2_EXIST parameter must be set to '0'. Program this bit to 0 if the core is intended to be operated in USB 3.0 mode.'''
[[register.field]]
name = "U1U2TIMERSCALE"
bits = "9"
type = "rw"
shortdesc = '''Disable U1/U2 timer Scaledown (U1U2TimerScale).'''
longdesc = '''If set to '1' along with GCTL[5:4] (ScaleDown) = 2'bX1, disables the scale down of U1/U2 inactive timer values. This is for simulation mode only.'''
[[register.field]]
    name = "DEBUGATTACH"
    bits = "8"
    type = "rw"
  [[register.field]]
    name = "RAMCLKSEL"
    bits = "7:6"
    type = "rw"
    shortdesc = '''RAM Clock Select (RAMClkSel) - 2'b00: bus clock - 2'b01: pipe clock (Only used in device mode) - 2'b10: In device mode , pipe/2 clock.'''
    longdesc = '''In Host mode, controller switches ram_clk between pipe/2 clock, mac2_clk and bus_clk based on the status of the U2/U3 ports - 2'b11: In device mode, selects mac2_clk as ram_clk (when 8-bit UTMI or ULPI used. Not supported in 16-bit UTMI mode) In Host mode, controller switches ram_clk between pipe_clk, mac2_clk and bus_clk based on the status of the U2/U3 ports. In device mode, upon a USB reset and USB disconnect, the hardware clears these bits to 2'b00. Note: - In device mode, if you set RAMClkSel to 2'b11 (mac2_clk), the controller internally switches the ram_clk to bus_clk when the link state changes to Suspend (L2 or L3), and switches the ram_clk back to mac2_clk when the link state changes to resume or U2. - In host mode, if a value of 2/3 is chosen, then controller switches ram_clk between bus_clk, mac2_clk and pipe_clk, pipe_clk/2, based on the state of the U2/U3 ports. For example if only the U2 port is active and the U3 ports are suspended, then the ram_clk is swicthed to mac2_clk. When only the U3 ports are active and the U2 ports are suspended, then the core internally swicth the ram_clk to pipe3 clock and when all U2 and U3 ports are suspended, it switch the ram_clk to bus_clk. This allows de coupling the ram_clk from the bus_clk and depending on the bandwidth requiredmnet allows the bus_clk to be run at a lower frequency than the ram_clk requirements. bus_clk frequency still cannot go below 60Mhz in host mode, and this is not verified. A value of 2 can be chosen only if the pipe data width is 8 or 16 bits. In this case the when the ram_clk is switched to pipe_clk, it uses pipe_clk/2 instead of pipe_clk. If a value of 3 is chosen for RAMClkSel, then when ram_clk is switched to pipe_clk, then pipe_clk is used without any divider. - In device mode, when RAMClkSel != 2'b00, the bus_clk_early frequency can be a minimum of 1 MHz. This is tested in simulation and also in hardware with Linux, Microsoft Windows 8, and MCCI Windows7 host drivers. Only control and non periodic transfers are supported when bus_clk is 1 MHz. For periodic applications, the bus_clk_early minimum frequency is higher depending on your application and SoC bus. Even though 1 MHz has been tested with standard host drivers, recommends 5 MHz minimum for ASIC designs to provide a margin or at least have a backup option to increase the bus_clk frequency to 5 MHz if needed. Programming this field with random data will cause side effect. Bit Bash register testing is not recommended.'''
  [[register.field]]
    name = "SCALEDOWN"
    bits = "5:4"
    type = "rw"
    shortdesc = '''Scale-Down Mode (ScaleDown) When Scale-Down mode is enabled for simulation, the core uses scaled-down timing values, resulting in faster simulations.'''
    longdesc = '''When Scale-Down mode is disabled, actual timing values are used. This is required for hardware operation. HS/FS/LS Modes - 2'b00: Disables all scale-downs. Actual timing values are used. - 2'b01: Enables scale-down of all timing values except Device mode suspend and resume. These include Speed enumeration, HNP/SRP, and Host mode suspend and resume - 2'b10: Enables scale-down of Device mode suspend and resume timing values only. - 2'b11: Enables bit 0 and bit 1 scale-down timing values. SS Mode - 2'b00: Disables all scale-downs. Actual timing values are used. - 2'b01: Enables scaled down SS timing and repeat values including: (1) Number of TxEq training sequences reduce to 8; (2) LFPS polling burst time reduce to 256 nS; (3) LFPS warm reset receive reduce to 30 uS. Refer to the rtl_vip_scaledown_mapping.xls file under <workspace>/sim/SoC_sim directory for the complete list. - 2'b10: No TxEq training sequences are sent. Overrides Bit 4. - 2'b11: Enables bit 0 and bit 1 scale-down timing values.'''
  [[register.field]]
    name = "DISSCRAMBLE"
    bits = "3"
    type = "rw"
  [[register.field]]
    name = "U2EXIT_LFPS"
    bits = "2"
    type = "rw"
    shortdesc = '''U2EXIT_LFPS If this bit is, - 0: the link treats 248ns LFPS as a valid U2 exit.'''
    longdesc = '''- 1: the link waits for 8us of LFPS before it detects a valid U2 exit. This bit is added to improve interoperability with a third party host controller. This host controller in U2 state while performing receiver detection generates an LFPS glitch of about 4ms duration. This causes the device to exit from U2 state because the LFPS filter value is 248ns. With the new functionality enabled, the device can stay in U2 while ignoring this glitch from the host controller.'''
  [[register.field]]
    name = "GBLHIBERNATIONEN"
    bits = "1"
    type = "rw"
    shortdesc = '''GblHibernationEn This bit enables hibernation at the global level.'''
    longdesc = '''If hibernation is not enabled through this bit, the PMU immediately accepts the D0->D3 and D3->D0 power state change requests, but does not save or restore any core state. In addition, the PMUs never drive the PHY interfaces and let the core continue to drive the PHY interfaces.'''
  [[register.field]]
    name = "DSBLCLKGTNG"
    bits = "0"
    type = "rw"
    shortdesc = '''Disable Clock Gating (DsblClkGtng) This bit is set to 1 and the core is in Low Power mode, internal clock gating is disabled.'''
    longdesc = '''You can set this bit to 1'b1 after Power On Reset.'''
[[register]]
  name = "GPMSTS"
  type = "mixed"
  width = 32
  description = "Global Power Management Status Register This debug register gives information on which event caused the hibernation exit. It provides internal status and state machine information, and is for use only for debugging purposes. This register is not applicable in USB 2.0-only mode."
  default = "0x00000000"
  offset = "0x0000C114"
  [[register.field]]
    name = "PORTSEL"
    bits = "31:28"
    type = "wo"
  [[register.field]]
    name = "RESERVED"
    bits = "27:17"
    type = "ro"
  [[register.field]]
    name = "U3WAKEUP"
    bits = "16:12"
    type = "ro"
    shortdesc = '''U3Wakeup This field gives the following USB 3.'''
    longdesc = '''0 port wakeup conditions: - Bit [12]: Overcurrent Detected - Bit [13]: Resume Detected - Bit [14]: Connect Detected - Bit [15]: Disconnect Detected - Bit [16]: Last Connection State'''
  [[register.field]]
    name = "RESERVED"
    bits = "11:10"
    type = "ro"
  [[register.field]]
    name = "U2WAKEUP"
    bits = "9:0"
    type = "ro"
    shortdesc = '''U2Wakeup This field indicates the following USB 2.'''
    longdesc = '''0 port wakeup conditions: - Bit [0]: Overcurrent Detected - Bit [1]: Resume Detected - Bit [2]: Connect Detected - Bit [3]: Disconnect Detected - Bit [4]: Last Connection State - Bit [5]: ID Change Detected - Bit [6]: SRP Request Detected - Bit [7]: ULPI Interrupt Detected - Bit [8]: USB Reset Detected - Bit [9]: Resume Detected Changed'''
[[register]]
  name = "GSTS"
  type = "mixed"
  width = 32
  description = "Global Status Register"
  default = "0x00000000"
  offset = "0x0000C118"
  [[register.field]]
    name = "CBELT"
    bits = "31:20"
    type = "ro"
  [[register.field]]
    name = "RESERVED"
    bits = "19:12"
    type = "ro"
  [[register.field]]
    name = "SSIC_IP"
    bits = "11"
    type = "ro"
    shortdesc = '''SSIC interrupt pending (SSIC_IP) This field indicates that there is a pending interrupt related to SSIC in the SEVT register.'''
    longdesc = '''Note: When the DWC_USB3_NUM_SSIC_PORTS parameter is set to zero, this bit is reserved.'''
  [[register.field]]
    name = "OTG_IP"
    bits = "10"
    type = "ro"
  [[register.field]]
    name = "BC_IP"
    bits = "9"
    type = "ro"
  [[register.field]]
    name = "ADP_IP"
    bits = "8"
    type = "ro"
  [[register.field]]
    name = "HOST_IP"
    bits = "7"
    type = "ro"
  [[register.field]]
    name = "DEVICE_IP"
    bits = "6"
    type = "ro"
  [[register.field]]
    name = "CSRTIMEOUT"
    bits = "5"
    type = "wtc"
  [[register.field]]
    name = "BUSERRADDRVLD"
    bits = "4"
    type = "wtc"
    shortdesc = '''Bus Error Address Valid (BusErrAddrVld) Indicates that the GBUSERRADDR register is valid and reports the first bus address that encounters a bus error.'''
    longdesc = '''Note: Only supported in AHB and AXI configurations.'''
  [[register.field]]
    name = "RESERVED"
    bits = "3:2"
    type = "ro"
  [[register.field]]
    name = "CURMOD"
    bits = "1:0"
    type = "ro"
[[register]]
  name = "GUCTL1"
  type = "mixed"
  width = 32
  description = "Global User Control Register 1"
  default = "0x00000000"
  offset = "0x0000C11C"
  [[register.field]]
    name = "RESERVED"
    bits = "31:30"
    type = "ro"
  [[register.field]]
    name = "FILTER_SE0_FSLS_EOP"
    bits = "29"
    type = "rw"
    shortdesc = '''FILTER_SE0_FSLS_EOP - 0: Default behaviour, no change in Linestate check for SE0 detection in FS/LS - 1: Feature enabled, FS/LS SE0 is filtered for 2 clocks for detecting EOP This bit is applicable for FS/LS operation.'''
    longdesc = '''If this feature is enabled, then SE0 on the linestate is validated for 2 consecutive utmi/ulpi clock edges for EOP detection. This feature is applicable only in FS in device mode and FS/LS mode of operation in host mode. - Device mode: FS - If GUCTL1.FILTER_SE0_FSLS_EOP is set, then for device LPM hanshake, the core will ignore single SE0 glitch on the linestate during transmit. Only 2 or more SE0 is considered as a valid EOP on FS. - Host mode: FS/LS - If GUCTL1.FILTER_SE0_FSLS_EOP is set, then the core will ignore single SE0 glitch on the linestate during transmit. Only 2 or more SE0 is considered as a valid EOP on FS/LS port. Enable this feature if the LineState has SE0 glitches during transmission. This bit is quasi-static, i.e., should not be changed during device operation.'''
  [[register.field]]
    name = "TX_IPGAP_LINECHECK_DIS"
    bits = "28"
    type = "rw"
    shortdesc = '''TX_IPGAP_LINECHECK_DIS - 0: Default behaviour, no change in Linestate check - 1: Feature enabled, 2.'''
    longdesc = '''0 MAC disables Linestate check during HS transmit This bit is applicable for HS operation of u2mac. If this feature is enabled, then the 2.0 mac operating in HS ignores the UTMI/ULPI Linestate during the transmit of a token (during token-to-token and token-to-data IPGAP). When enabled, the controller implements a fixed 40-bit TxEndDelay after the packet is given on UTMI and ignores the Linestate during this time. This fetaure is applicable only in HS mode of operation. - Device mode: If GUCTL1.TX_IPGAP_LINECHECK_DIS is set, then for device LPM handshake, the core will ignore the linestate after TX and wait for a fixed clocks ( 40 bit times equivalent) after transmiting ACK on utmi. - Host mode: If GUCTL1.TX_IPGAP_LINECHECK_DIS is set, then the ipgap between (tkn to tkn/data) is added by 40 bit times of TXENDDELAY, and linestate is ignored during this 40 bit times delay. Enable this bit if the LineState will not reflect the expected line state (J) during transmission. This bit is quasi-static, i.e., should not be changed during device operation.'''
  [[register.field]]
    name = "DEV_TRB_OUT_SPR_IND"
    bits = "27"
    type = "rw"
    shortdesc = '''DEV_TRB_OUT_SPR_IND - 0: Default behaviour, no change in TRB status dword - 1: Feature enabled, OUT TRB status indicates Short Packet This bit is applicable for device mode only (and ignored in host mode).'''
    longdesc = '''If the device application (SW/HW) wants to know if a short packet was received for an OUT in the TRB status itself, then this feature can be enabled, so that a bit is set in the TRB writeback in the buf_size dword. Bit[26] - SPR of the {trbstatus, RSVD, SPR, PCM1, bufsize} dword will be set during an OUT transfer TRB write back if this is the last TRB used for that transfer descriptor. This bit is quasi-static, i.e., should not be changed during device operation.'''
  [[register.field]]
    name = "DEV_FORCE_20_CLK_FOR_30_CLK"
    bits = "26"
    type = "rw"
    shortdesc = '''DEV_FORCE_20_CLK_FOR_30_CLK - 0: Default behaviour, Uses 3.'''
    longdesc = '''0 clock when operating in 2.0 mode - 1: Feature enabled This bit is applicable (and to be set) for device mode (DCFG.Speed != SS) only. In the 3.0 device core, if the core is programmed to operate in 2.0 only (i.e., Device Speed is programmed to 2.0 speeds in DCFG[Speed]), then setting this bit makes the internal 2.0 (utmi/ulpi) clock to be routed as the 3.0 (pipe) clock. Enabling this feature allows the pipe3 clock to be not-running when forcibily operating in 2.0 device mode. Note: When using this feature, all pipe3 inputs must be in inactive mode, esp. pipe3 clocks not running and pipe3_phystatus_async must be tied to 0. This bit should not be set if the core is programmed to operate in SuperSpeed mode (even when it falls back to 2.0). This bit is quasi-static, i.e., should not be changed during operation.'''
  [[register.field]]
    name = "P3_IN_U2"
    bits = "25"
    type = "rw"
    shortdesc = '''P3_IN_U2 - 0: Default behaviour, When SuperSpeed link is in U2 , PowerState P2 is attempted on the PIPE Interface.'''
    longdesc = '''- 1: When SuperSpeed link is in U2, PowerState P3 is attempted if GUSB3PIPECTL[17] is set. Setting this bit enables P3 Power State when the SuperSpeed link is in U2. Another Power Saving option. Check with your PHY vendor before enabling this option.When setting this bit to 1 to enable P3 in P2, GUSB3PIPECTL[27] should be set to 0 to make sure that the U2 exit is attempted in P0. This bit should be set only when GCTL.SOFITPSYNC=1 or GFLADJ.GFLADJ_REFCLK_LPM_SEL=1.'''
  [[register.field]]
    name = "DEV_L1_EXIT_BY_HW"
    bits = "24"
    type = "rw"
    shortdesc = '''DEV_L1_EXIT_BY_HW - 0: Default behaviour, disables device L1 hardware exit logic - 1: feature enabled This bit is applicable for device mode (2.'''
    longdesc = '''0) only. This field enables device controller sending remote wakeup for L1 if the device becomes ready for sending/accepting data when in L1 state. If the host expects the device to send remote wkp signalling to resume after going into L1 in flow controlled state, then this bit can be set to send the remote wake signal automatically when the device controller becomes ready. This HW remote wake feature is applicable only to bulk and interrupt transfers, and not for Isoch/Control - When control transfers are in progress, the LPM will be rejected (NYET response). Only after control transfers are completed (either with ACK/STALL), LPM will be accepted - For Isoch transfers, the host needs to do the wake-up and start the transfer. Device controller will not do remote-wakeup when Isoch endpoints get ready. The device SW needs to keep the GUSB2PHYCFG[EnblSlpM] reset in order to keep the PHY clock to be running for keeping track of SOF intervals. - When L1 hibernation is enabled, the controller will not do automatic exit for hibernation requests thru L1. This bit is quasi-static, i.e., should not be changed during device operation.'''
  [[register.field]]
    name = "IP_GAP_ADD_ON"
    bits = "23:21"
    type = "rw"
    shortdesc = '''This register field is used to add on to the default inter packet gap setting in the USB 2.'''
    longdesc = '''0 MAC. This should be programmed to a non zero value only in case where you need to increase the default inter packet delay calculations in the USB 2.0 MAC module DWC_usb3_u2mac.v'''
  [[register.field]]
    name = "DEV_LSP_TAIL_LOCK_DIS"
    bits = "20"
    type = "rw"
    shortdesc = '''DEV_LSP_TAIL_LOCK_DIS - 0: Default behaviour, enables device lsp lock logic for tail TRB update - 1: Fix disabled This is a bug fix for STAR 9000716195 that affects the CSP mode for OUT endpoints in device mode.'''
    longdesc = '''The issue is that tail TRB index is not synchronized with the cache Scratchpad bytecount update. If the fast-forward request comes in-between the bytecount update ona newly fetched TRB and the tail-index write update in TPF, the RDP works on an incorrect tail index and misses the byte count decrement for the newly fetched TRB in the fast-forwarding process. This fix needs to be present all the times.'''
  [[register.field]]
    name = "NAK_PER_ENH_FS"
    bits = "19"
    type = "rw"
    shortdesc = '''NAK_PER_ENH_FS - 1: Enables performance enhancement for FS async endpoints in the presence of NAKs - 0: Enhancement not applied If a periodic endpoint is present , and if a bulk endpoint which is also active is being NAKed by the device, then this could result in a decrease in performance of other Full Speed bulk endpoint which is ACked by the device.'''
    longdesc = '''Setting this bit to 1, will enable the host controller to schedule more transactions to the async endpoints ( bulk/ control) and hence will improve the performance of the bulk endpoint. This control bit should be enabled only if the existing performance with the default setting is not sufficient for your FullSpeed application. Setting this bit will only control, and is only required for Full Speed transfers.'''
  [[register.field]]
    name = "NAK_PER_ENH_HS"
    bits = "18"
    type = "rw"
    shortdesc = '''NAK_PER_ENH_HS - 1: Enables performance enhancement for HS async endpoints in the presence of NAKs - 0: Enhancement not applied If a periodic endpoint is present , and if a bulk endpoint which is also active is being NAKed by the device, then this could result in a decrease in performance of other High Speed bulk endpoint which is ACked by the device.'''
    longdesc = '''Setting this bit to 1, will enable the host controller to schedule more transactions to the async endpoints ( bulk/ control) and hence will improve the performance of the bulk endpoint. This control bit should be enabled only if the existing performance with the default setting is not sufficient for your HighSpeed application. Setting this bit will only control, and is only required for High Speed transfers.'''
  [[register.field]]
    name = "PARKMODE_DISABLE_SS"
    bits = "17"
    type = "rw"
    shortdesc = '''PARKMODE_DISABLE_SS This bit is used only in host mode, and is for debug purpose only.'''
    longdesc = '''When this bit is set to '1' all SS bus instances in park mode are disabled.'''
  [[register.field]]
    name = "PARKMODE_DISABLE_HS"
    bits = "16"
    type = "rw"
    shortdesc = '''PARKMODE_DISABLE_HS This bit is used only in host mode.'''
    longdesc = '''When this bit is set to '1' all HS bus instances park mode are disabled. To improve performance in park mode, the xHCI scheduler queues in three requests of 4 packets each for High Speed asynchronous endpoints in a micro-frame. But if a device is slow and if it NAKs more than 3 times, then it is rescheduled only in the next micro-frame. This could decrease the performance of a slow device even further. In a few high speed devices (such as Sandisk Cruzer Blade 4GB VID:1921, PID:21863 and Flex Drive VID:3744, PID:8552) when an IN request is sent within 900ns of the ACK of the previous packet, these devices send a NAK. When connected to these devices, if required, the software can disable the park mode if you see performance drop in your system. When park mode is disabled, pipelining of multiple packet is disabled and instead one packet at a time is requested by the scheduler. This allows up to 12 NAKs in a micro-frame and improves performance of these slow devices.'''
  [[register.field]]
    name = "PARKMODE_DISABLE_FSLS"
    bits = "15"
    type = "rw"
    shortdesc = '''PARKMODE_DISABLE_FSLS This bit is used only in host mode, and is for debug purpose only.'''
    longdesc = '''When this bit is set to '1' all FS/LS bus instances in park mode disabled.'''
  [[register.field]]
    name = "RESERVED"
    bits = "14:11"
    type = "ro"
  [[register.field]]
    name = "RESUME_TERMSEL_XCVRSEL_UNIFY"
    bits = "10"
    type = "rw"
    shortdesc = '''When this bit is set to '0', termsel, xcvrsel will become 0 during end of resume while the opmode will become 0 once controller completes end of resume and enters U0 state (2 separate commandswill be issued).'''
    longdesc = '''When this bit is set to '1', all the termsel, xcvrsel, opmode becomes 0 during end of resume itself (only 1 command will be issued)'''
  [[register.field]]
    name = "RESERVED"
    bits = "9"
    type = "ro"
  [[register.field]]
    name = "L1_SUSP_THRLD_EN_FOR_HOST"
    bits = "8"
    type = "rw"
    shortdesc = '''L1_SUSP_THRLD_EN_FOR_HOST This bit is used only in host mode.'''
    longdesc = '''The host controller asserts the utmi_l1_suspend_n and utmi_sleep_n output signals (see 'LPM Interface Signals' table in the Databook) as follows: The controller asserts the utmi_l1_suspend_n signal to put the PHY into deep low-power mode in L1 when both of the following are true: - The HIRD/BESL value used is greater than or equal to the value in L1_SUSP_THRLD_FOR_HOST field. - The L1_SUSP_THRLD_EN_FOR_HOST bit is set to 1'b1. The controller asserts utmi_sleep_n on L1 when one of the following is true: - The HIRD/BESL value used is less than the value in L1_SUSP_THRLD_FOR_HOST field. - The L1_SUSP_THRLD_EN_FOR_HOST bit is set to 1'b0.'''
  [[register.field]]
    name = "L1_SUSP_THRLD_FOR_HOST"
    bits = "7:4"
    type = "rw"
    shortdesc = '''L1_SUSP_THRLD_FOR_HOST This field is effective only when the L1_SUSP_THRLD_EN_FOR_HOST bit is set to 1.'''
    longdesc = '''For more details, refer to the description of the L1_SUSP_THRLD_EN_FOR_HOST bit.'''
  [[register.field]]
    name = "HC_ERRATA_ENABLE"
    bits = "3"
    type = "rw"
    shortdesc = '''Host ELD Enable (HELDEn) When this bit is set to 1, it enables the Exit Latency Delta (ELD) support defined in the xHCI 1.'''
    longdesc = '''0 Errata. This bit is used only in the host mode. This bit has to be set to 1 in Host mode.'''
  [[register.field]]
    name = "HC_PARCHK_DISABLE"
    bits = "2"
    type = "rw"
    shortdesc = '''Host Parameter Check Disable (HParChkDisable) When this bit is set to '0' (by default), the xHC checks that the input slot/EP context fields comply to the xHCI Specification.'''
    longdesc = '''Upon detection of a parameter error during command execution, the xHC generates an event TRB with completion code indicating 'PARAMETER ERROR'. When the bit is set to '1', the xHC does not perform parameter checks and does not generate 'PARAMETER ERROR' completion code.'''
  [[register.field]]
    name = "OVRLD_L1_SUSP_COM"
    bits = "1"
    type = "rw"
    shortdesc = '''OVRLD_L1_SUSP_COM If this bit is set, the utmi_l1_suspend_com_n is overloaded with the utmi_sleep_n signal.'''
    longdesc = '''This bit is usually set if the PHY stops the port clock during L1 sleep condition. Note: The recommended connection for the SUSPENDM/SLEEPM signals to the PHY with respect to this bit is as follows. For non-zero ports: Connect: - utmi_sleep_n[n] to SLEEPM[n] - (utmi_suspend_n[n] & utmi_l1_suspend_n[n]) to SUSPENDM[n] - USB2 PHYCLK[n] to utmi_clk[n] GUCTL1.OVRLD_L1_SUSP_COM impacts only Port0. For Port0: For PHY, GUSB2PHYCFGn.U2_FREECLK_EXISTS=1; With this connection, the PHY keeps PLL active so that FREECLK is always available irrespective of suspend/sleep. - Connect USB2 PHY COMMONONN to 0. - Connect utmi_sleep_n[0] to SLEEPM[0]. - Connect (utmi_suspend_n[0] & utmi_l1_suspend_n[0]) to SUSPENDM[0]. - Connect USB2 PHY FREECLK to utmi_clk[0]. - Leave utmi_suspend_com_n, utmi_l1_suspend_com_n unconnected. - GUCTL1.OVRLD_L1_SUSP_COM can be set to any value. For Third Party PHY, GUSB2PHYCFGn.U2_FREECLK_EXISTS=0; With this connection the PHY can shut off all the clocks when the required conditions are met (like, GUSB2PHYCFGn[8,6], GUCTL1[1], GFLADJ[23], GCTL[10], Suspend condition, HW LPM enable etc). - Connect -utmi_suspend_com_n to SUSPENDM[0] (or equivalent). - Connect -utmi_l1_suspend_com_n to SLEEPM[0] (or equivalent). - Connect PHYCLK0 (first port clock) to utmi_clk[0]. - Leave utmi_suspend_n[0], utmi_l1_suspend_ n[0], utmi_sleep_n[0] unconnected. - Set GUCTL1.OVRLD_L1_SUSP_COM to 1'b1.'''
  [[register.field]]
    name = "LOA_FILTER_EN"
    bits = "0"
    type = "rw"
    shortdesc = '''LOA_FILTER_EN If this bit is set, the USB 2.'''
    longdesc = '''0 port babble is checked at least three consecutive times before the port is disabled. This prevents false triggering of the babble condition when using low quality cables. Note: This bit is valid only in host mode.'''
[[register]]
  name = "GSNPSID"
  type = "ro"
  width = 32
  description = "Global ID Register This is a read-only register that contains the release number of the core."
  default = "0x5533290A"
  offset = "0x0000C120"
  [[register.field]]
    name = "SYNOPSYSID"
    bits = "31:0"
    type = "ro"
    shortdesc = '''ID - ID[31:16] indicates Core Identification Number.'''
    longdesc = '''0x5533 is ASCII for U3 (DWC_usb3). - ID[15:0] indicates the release number. Current Release is 2.90a. Software uses this register to configure release-specific features in the driver.'''
[[register]]
  name = "GGPIO"
  type = "mixed"
  width = 32
  description = "Global General Purpose Input/Output Register The application can use this register for general purpose input and output ports or for debugging."
  default = "0x00000000"
  offset = "0x0000C124"
  [[register.field]]
    name = "GPO"
    bits = "31:16"
    type = "rw"
  [[register.field]]
    name = "GPI"
    bits = "15:0"
    type = "ro"
    shortdesc = '''General Purpose Input This field's read value reflects the gp_in[15:0] core input value.'''
    longdesc = '''Note: Register bit-bash test should not check for reset value of this field since its not predictable; depends on the gp_in port.'''
[[register]]
  name = "GUID"
  type = "rw"
  width = 32
  description = "Global User ID Register This is a read/write register containing the User ID. The power-on value for this register is specified as the User Identification Register. Power-on value during coreConsultant configuration (parameter DWC_USB3_USERID). This register can be used in the following ways: - To store the version or revision of your system; - To store hardware configurations that are outside the core; - As a scratch register."
  default = "0x12345678"
  offset = "0x0000C128"
  [[register.field]]
    name = "USERID"
    bits = "31:0"
    type = "rw"
[[register]]
  name = "GUCTL"
  type = "mixed"
  width = 32
  description = "Global User Control Register: This register provides a few options for the software to control the core behavior in the Host mode. Most of the options are used to improve host inter-operability with different devices."
  default = "0x00000000"
  offset = "0x0000C12C"
  [[register.field]]
    name = "REFCLKPER"
    bits = "31:22"
    type = "rw"
    shortdesc = '''REFCLKPER This field indicates in terms of nano seconds the period of ref_clk.'''
    longdesc = '''The default value of this register is set to 'h8 (8ns/125 MHz). This field needs to be updated during power-on initialization, if GCTL.SOFITPSYNC or GFLADJ.GFLADJ_REFCLK_LPM_SEL is set to '1'. The programmable maximum value is 62ns, and the minimum value is 8ns. You must use a reference clock with a period that is an integer multiple, so that ITP can meet the jitter margin of 32ns. The allowable ref_clk frequencies whose period is not integer multiples are 16/17/19.2/24/39.7MHz. This field must not be set to '0' at any time. If you never plan to use this feature, then set this field to 'h8, the default value.'''
  [[register.field]]
    name = "NOEXTRDL"
    bits = "21"
    type = "rw"
    shortdesc = '''No Extra Delay Between SOF and the First Packet(NoExtrDl) Some HS devices misbehave when the host sends a packet immediately after a SOF.'''
    longdesc = '''However, adding an extra delay between a SOF and the first packet can reduce the USB data rate and performance. This bit is used to control whether the host must wait for 2 microseconds before it sends the first packet after a SOF, or not. User can set this bit to one to improve the performance if those problematic devices are not a concern in the user's host environment. - 1'b0: Host waits for 2 microseconds after a SOF before it sends the first USB packet. - 1'b1: Host doesn't wait after a SOF before it sends the first USB packet.'''
  [[register.field]]
    name = "RESERVED"
    bits = "20:18"
    type = "ro"
  [[register.field]]
    name = "SPRSCTRLTRANSEN"
    bits = "17"
    type = "rw"
    shortdesc = '''Sparse Control Transaction Enable Some devices are slow in responding to Control transfers.'''
    longdesc = '''Scheduling multiple transactions in one microframe/frame can cause these devices to misbehave. If this bit is set to 1'b1, the host controller schedules transactions for a Control transfer in different microframes/frames.'''
  [[register.field]]
    name = "RESBWHSEPS"
    bits = "16"
    type = "rw"
    shortdesc = '''Reserving 85% Bandwidth for HS Periodic EPs (ResBwHSEPS) By default, HC reserves 80% of the bandwidth for periodic EPs.'''
    longdesc = '''If this bit is set, the bandwidth is relaxed to 85% to accommodate two high speed, high bandwidth ISOC EPs. USB 2.0 required 80% bandwidth allocated for ISOC traffic. If two High-bandwidth ISOC devices (HD Webcams) are connected, and if each requires 1024-bytes X 3 packets per Micro-Frame, then the bandwidth required is around 82%. If this bit is set, then it is possible to connect two Webcams of 1024bytes X 3 paylod per Micro-Frame each. Otherwise, you may have to reduce the resolution of the Webcams. This bit is valid in Host and DRD configuration and is used in host mode operation only. Ignore this bit in device mode.'''
  [[register.field]]
    name = "CMDEVADDR"
    bits = "15"
    type = "rw"
    shortdesc = '''Compliance Mode for Device Address (CMdevAddr) When this bit is 1'b1, Slot ID may have different value than Device Address if max_slot_enabled < 128.'''
    longdesc = '''- 1'b1: Increment Device Address on each Address Device command. - 1'b0: Device Address is equal to Slot ID. The xHCI compliance requires this bit to be set to '1'. The '0' mode is for debug purpose only. This allows you to easily identify a device connected to a port in the Lecroy or Eliisys trace during hardware debug. This bit is valid in Host and DRD configuration and is used in host mode operation only. Ignore this bit in device mode.'''
  [[register.field]]
    name = "USBHSTINAUTORETRYEN"
    bits = "14"
    type = "rw"
    shortdesc = '''Host IN Auto Retry (USBHstInAutoRetryEn) When set, this field enables the Auto Retry feature.'''
    longdesc = '''For IN transfers (non-isochronous) that encounter data packets with CRC errors or internal overrun scenarios, the auto retry feature causes the Host core to reply to the device with a non-terminating retry ACK (that is, an ACK transaction packet with Retry = 1 and NumP != 0). If the Auto Retry feature is disabled (default), the core will respond with a terminating retry ACK (that is, an ACK transaction packet with Retry = 1 and NumP = 0). - 1'b0: Auto Retry Disabled - 1'b1: Auto Retry Enabled Note: This bit is also applicable to the device mode.'''
  [[register.field]]
    name = "ENOVERLAPCHK"
    bits = "13"
    type = "rw"
    shortdesc = '''Enable Check for LFPS Overlap During Remote Ux Exit: If this bit is set to, - 1'b1: The SuperSpeed link when exiting U1/U2/U3 waits for either the remote link LFPS or TS1/TS2 training symbols before it confirms that the LFPS handshake is complete.'''
    longdesc = '''This is done to handle the case where the LFPS glitch causes the link to start exiting from the low power state. Looking for the LFPS overlap makes sure that the link partner also sees the LFPS. - 1'b0: When the link exists U1/U2/U3 because of a remote exit, it does not look for an LFPS overlap.'''
  [[register.field]]
    name = "EXTCAPSUPPTEN"
    bits = "12"
    type = "rw"
    shortdesc = '''External Extended Capability Support Enable (ExtCapSuptEN) When set, this field enables extended capabilities to be implemented outside the core.'''
    longdesc = '''When the ExtCapSupEN is set and the Debug Capability is enabled, the Next Capability pointer in 'Debug Capability' returns 16. A read to the first DWORD of the last internal extended capability (the 'xHCI Supported Protocol Capability for USB 3.0' when the Debug Capability is not enabled) returns a value of 4 in the Next Capability Pointer field. This indicates to software that there is another capability four DWORDs after this capability (for example, at address N+16 where N is the address of this DWORD). If enabled, an external address decoder that snoops the xHC slave interface must be implemented. If it sees an access to N+16 or greater, the slave access is re-routed to a piece of hardware which returns the external capability pointer register of the new capability and also handles reads/writes to this new capability and the side effects. If disabled, a read to the first DWORD of the last internal extended capability returns 0 in the 'Next Capability Pointer field. This indicates there are no more capabilities.'''
  [[register.field]]
    name = "INSRTEXTRFSBODI"
    bits = "11"
    type = "rw"
    shortdesc = '''Insert Extra Delay Between FS Bulk OUT Transactions (InsrtExtrFSBODl).'''
    longdesc = '''Some FS devices are slow to receive Bulk OUT data and can get stuck when there are consecutive Bulk OUT transactions with short inter-transaction delays. This bit is used to control whether the host inserts extra delay between consecutive Bulk OUT transactions to a FS Endpoint. - 1'b0: Host doesn't insert extra delay between consecutive Bulk OUT transactions to a FS Endpoint. - 1'b1: Host inserts about 12us extra delay between consecutive Bulk OUT transactions to a FS Endpoint to work around the device issue. Note: Setting this bit to one will reduce the Bulk OUT transfer performance for most of the FS devices.'''
  [[register.field]]
    name = "DTCT"
    bits = "10:9"
    type = "rw"
    shortdesc = '''Device Timeout Coarse Tuning (DTCT) This field is a Host mode parameter which determines how long the host waits for a response from device before considering a timeout.'''
    longdesc = '''The core first checks the DTCT value. If it is 0, then the timeout value is defined by the DTFT. If it is non-zero, then it uses the following timeout values: - 2'b00: 0 usec -> use DTFT value instead - 2'b01: 500 usec - 2'b10: 1.5 msec - 2'b11: 6.5 msec'''
  [[register.field]]
    name = "DTFT"
    bits = "8:0"
    type = "rw"
    shortdesc = '''Device Timeout Fine Tuning (DTFT) This field is a Host mode parameter which determines how long the host waits for a response from device before considering a timeout.'''
    longdesc = '''For the DTFT field to take effect, DTCT must be set to 2'b00. The DTFT value is the number of 125 MHz clocks * 256 to count before considering a device timeout. The minimum value of DTFT is 2. For example, if the mac3_clk is 125 MHz clk (8 ns period), this is calculated as follows: (DTFT value) * 256 * (8 ns) Quick Reference: - if DTFT = 0x2, 2*256*8 = 4usec timeout - if DTFT = 0x5, 5*256*8 = 10usec timeout - if DTFT = 0xA, 10*256*8 = 20usec timeout - if DTFT = 0x10, 16*256*8 = 32usec timeout - if DTFT = 0x19, 25*256*8 = 51usec timeout - if DTFT = 0x31, 49*256*8 = 100usec timeout - if DTFT = 0x62, 98*256*8 = 200usec timeout Note: When SSIC is enabled, in HS_G1_G2_G3 mode when ssic_soc_pa_clk_freq = 2'b01, then DTFT value must be calculated for 156.25 MHz clock, for example, for equivalent delay of 32usec DTFT value must be 9'h14.'''
[[register]]
  name = "GBUSERRADDRLO"
  type = "ro"
  width = 32
  description = "Gobal SoC Bus Error Address Register - Low This is an alternate register for the GBUSERRADDR register."
  default = "0x00000000"
  offset = "0x0000C130"
  [[register.field]]
    name = "BUSERRADDR"
    bits = "31:0"
    type = "ro"
    shortdesc = '''Bus Address - Low (BusAddrLo) This register contains the lower 32 bits of the first bus address that encountered a SoC bus error.'''
    longdesc = '''It is valid when the GSTS.BusErrAddrVld field is 1. It can only be cleared by resetting the core. Note: Only supported in AHB and AXI configurations.'''
[[register]]
  name = "GBUSERRADDRHI"
  type = "ro"
  width = 32
  description = "Gobal SoC Bus Error Address Register - High This is an alternate register for the GBUSERRADDR register."
  default = "0x00000000"
  offset = "0x0000C134"
  [[register.field]]
    name = "BUSERRADDR"
    bits = "31:0"
    type = "ro"
    shortdesc = '''Bus Address - High (BusAddrHi) This register contains the higher 32 bits of the first bus address that encountered a SoC bus error.'''
    longdesc = '''It is valid when the GSTS.BusErrAddrVld field is 1. It can only be cleared by resetting the core. Note: Only supported in AHB and AXI configurations.'''
[[register]]
  name = "GPRTBIMAPLO"
  type = "mixed"
  width = 32
  description = "Global SS Port to Bus Instance Mapping Register - Low This is an alternate register for the GPRTBIMAP register. Note: For reset values, refer to the corresponding values in the GPRTBIMAP register."
  default = "0x00000000"
  offset = "0x0000C138"
  [[register.field]]
    name = "BINUM8"
    bits = "31:28"
    type = "ro"
    shortdesc = '''BINUM8: SS USB Instance Number for Port 8.'''
    longdesc = '''Application-programmable ID field.'''
  [[register.field]]
    name = "BINUM7"
    bits = "27:24"
    type = "ro"
    shortdesc = '''BINUM7: SS USB Instance Number for Port 7.'''
    longdesc = '''Application-programmable ID field.'''
  [[register.field]]
    name = "BINUM6"
    bits = "23:20"
    type = "ro"
    shortdesc = '''BINUM6: SS USB Instance Number for Port 6.'''
    longdesc = '''Application-programmable ID field.'''
  [[register.field]]
    name = "BINUM5"
    bits = "19:16"
    type = "ro"
    shortdesc = '''BINUM5: SS USB Instance Number for Port 5.'''
    longdesc = '''Application-programmable ID field.'''
  [[register.field]]
    name = "BINUM4"
    bits = "15:12"
    type = "ro"
    shortdesc = '''BINUM4: SS USB Instance Number for Port 4.'''
    longdesc = '''Application-programmable ID field.'''
  [[register.field]]
    name = "BINUM3"
    bits = "11:8"
    type = "ro"
    shortdesc = '''BINUM3: SS USB Instance Number for Port 3.'''
    longdesc = '''Application-programmable ID field.'''
  [[register.field]]
    name = "BINUM2"
    bits = "7:4"
    type = "ro"
    shortdesc = '''BINUM2: SS USB Instance Number for Port 2.'''
    longdesc = '''Application-programmable ID field.'''
  [[register.field]]
    name = "BINUM1"
    bits = "3:0"
    type = "rw"
    shortdesc = '''BINUM1: SS USB Instance Number for Port 1.'''
    longdesc = '''Application-programmable ID field.'''
[[register]]
  name = "GPRTBIMAPHI"
  type = "ro"
  width = 32
  description = "Global SS Port to Bus Instance Mapping Register - High This is an alternate register for the GPRTBIMAP register. Note: For reset values, refer to the corresponding values in the GPRTBIMAP register."
  default = "0x00000000"
  offset = "0x0000C13C"
  [[register.field]]
    name = "RESERVED"
    bits = "31:28"
    type = "ro"
  [[register.field]]
    name = "BINUM15"
    bits = "27:24"
    type = "ro"
    shortdesc = '''BINUM15: SS USB Instance Number for Port 15.'''
    longdesc = '''Application-programmable ID field.'''
  [[register.field]]
    name = "BINUM14"
    bits = "23:20"
    type = "ro"
    shortdesc = '''BINUM14: SS USB Instance Number for Port 14.'''
    longdesc = '''Application-programmable ID field.'''
  [[register.field]]
    name = "BINUM13"
    bits = "19:16"
    type = "ro"
    shortdesc = '''BINUM13: SS USB Instance Number for Port 13.'''
    longdesc = '''Application-programmable ID field.'''
  [[register.field]]
    name = "BINUM12"
    bits = "15:12"
    type = "ro"
    shortdesc = '''BINUM12: SS USB Instance Number for Port 12.'''
    longdesc = '''Application-programmable ID field.'''
  [[register.field]]
    name = "BINUM11"
    bits = "11:8"
    type = "ro"
    shortdesc = '''BINUM11: SS USB Instance Number for Port 11.'''
    longdesc = '''Application-programmable ID field.'''
  [[register.field]]
    name = "BINUM10"
    bits = "7:4"
    type = "ro"
    shortdesc = '''BINUM10: SS USB Instance Number for Port 10.'''
    longdesc = '''Application-programmable ID field.'''
  [[register.field]]
    name = "BINUM9"
    bits = "3:0"
    type = "ro"
    shortdesc = '''BINUM9: SS USB Instance Number for Port 9.'''
    longdesc = '''Application-programmable ID field.'''
[[register]]
name = "GHWPARAMS0"
type = "ro"
width = 32
description = "Global Hardware Parameters Register 0 This register contains the hardware configuration options that you can select in the coreConsultant GUI. For a description of each parameter, refer to Parameters chapter in the Databook. This information is also available in coreConsultant by right-clicking the parameter label and selecting 'What's This' or by clicking the Help tab. Note: Some of the global hardware parameters are not currently modifiable in coreConsultant. These settings are in the <workspace>/src/DWC_usb3_params.v file; you must not change them."
default = "0x4020404A"
offset = "0x0000C140"
[[register.field]]
name = "USB3_AWIDTH"
bits = "31:24"
type = "ro"
[[register.field]]
name = "USB3_SDWIDTH"
bits = "23:16"
type = "ro"
[[register.field]]
name = "USB3_MDWIDTH"
bits = "15:8"
type = "ro"
[[register.field]]
name = "USB3_SBUS_TYPE"
bits = "7:6"
type = "ro"
[[register.field]]
name = "USB3_MBUS_TYPE"
bits = "5:3"
type = "ro"
[[register.field]]
name = "USB3_MODE"
bits = "2:0"
type = "ro"
[[register]]
name = "GHWPARAMS1"
type = "ro"
width = 32
description = "Global Hardware Parameters Register 1 This register contains the hardware configuration options that you can select in the coreConsultant GUI. For a description of each parameter, refer to Parameters chapter in the Databook. This information is also available in coreConsultant by right-clicking the parameter label and selecting 'What's This' or by clicking the Help tab. Note: Some of the global hardware parameters are not currently modifiable in coreConsultant. These settings are in the <workspace>/src/DWC_usb3_params.v file; you must not change them."
default = "0x8262493B"
offset = "0x0000C144"
[[register.field]]
name = "USB3_EN_DBC"
bits = "31"
type = "ro"
[[register.field]]
name = "USB3_RM_OPT_FEATURES"
bits = "30"
type = "ro"
[[register.field]]
name = "Reserved"
bits = "29"
type = "ro"
[[register.field]]
name = "USB3_RAM_BUS_CLKS_SYNC"
bits = "28"
type = "ro"
[[register.field]]
name = "USB3_MAC_RAM_CLKS_SYNC"
bits = "27"
type = "ro"
[[register.field]]
name = "USB3_MAC_PHY_CLKS_SYNC"
bits = "26"
type = "ro"
[[register.field]]
name = "USB3_EN_PWROPT"
bits = "25:24"
type = "ro"
[[register.field.enum]]
name = "PWROPT_NO"
value = 0
[[register.field.enum]]
name = "PWROPT_CLK"
value = 1
[[register.field.enum]]
name = "PWROPT_HIB"
value = 2

[[register.field]]
name = "USB3_SPRAM_TYP"
bits = "23"
type = "ro"
[[register.field]]
name = "USB3_NUM_RAMS"
bits = "22:21"
type = "ro"
[[register.field]]
name = "USB3_DEVICE_NUM_INT"
bits = "20:15"
type = "ro"
[[register.field]]
name = "USB3_ASPACEWIDTH"
bits = "14:12"
type = "ro"
[[register.field]]
name = "USB3_REQINFOWIDTH"
bits = "11:9"
type = "ro"
[[register.field]]
name = "USB3_DATAINFOWIDTH"
bits = "8:6"
type = "ro"
[[register.field]]
name = "USB3_BURSTWIDTH"
bits = "5:3"
type = "ro"
[[register.field]]
name = "USB3_IDWIDTH"
bits = "2:0"
type = "ro"
[[register]]
name = "GHWPARAMS2"
type = "ro"
width = 32
description = "Global Hardware Parameters Register 2 This register contains the hardware configuration options that you can select in the coreConsultant GUI. For a description of each parameter, refer to Parameters chapter in the Databook. This information is also available in coreConsultant by right-clicking the parameter label and selecting 'What's This' or by clicking the Help tab. Note: Some of the global hardware parameters are not currently modifiable in coreConsultant. These settings are in the <workspace>/src/DWC_usb3_params.v file; you must not change them."
default = "0x12345678"
offset = "0x0000C148"
[[register.field]]
name = "USB3_USERID"
bits = "31:0"
type = "ro"
[[register]]
name = "GHWPARAMS3"
type = "ro"
width = 32
description = "Global Hardware Parameters Register 3 This register contains the hardware configuration options that you can select in the coreConsultant GUI. For a description of each parameter, refer to Parameters chapter in the Databook. This information is also available in coreConsultant by right-clicking the parameter label and selecting 'What's This' or by clicking the Help tab. Note: Some of the global hardware parameters are not currently modifiable in coreConsultant. These settings are in the <workspace>/src/DWC_usb3_params.v file; you must not change them."
default = "0x0618C089"
offset = "0x0000C14C"
[[register.field]]
name = "RESERVED"
bits = "31"
type = "ro"
[[register.field]]
name = "USB3_CACHE_TOTAL_XFER_RESOURCES"
bits = "30:23"
type = "ro"
[[register.field]]
name = "USB3_NUM_IN_EPS"
bits = "22:18"
type = "ro"
[[register.field]]
name = "USB3_NUM_EPS"
bits = "17:12"
type = "ro"
[[register.field]]
name = "USB3_ULPI_CARKIT"
bits = "11"
type = "ro"
[[register.field]]
name = "USB3_VENDOR_CTL_INTERFACE"
bits = "10"
type = "ro"
[[register.field]]
name = "RESERVED"
bits = "9:8"
type = "ro"
[[register.field]]
name = "USB3_HSPHY_DWIDTH"
bits = "7:6"
type = "ro"
[[register.field]]
name = "USB3_FSPHY_INTERFACE"
bits = "5:4"
type = "ro"
[[register.field]]
name = "USB3_HSPHY_INTERFACE"
bits = "3:2"
type = "ro"
[[register.field]]
name = "USB3_SSPHY_INTERFACE"
bits = "1:0"
type = "ro"
[[register]]
name = "GHWPARAMS4"
type = "ro"
width = 32
description = "Global Hardware Parameters Register 4 This register contains the hardware configuration options that you can select in the coreConsultant GUI. For a description of each parameter, refer to Parameters chapter in the Databook. This information is also available in coreConsultant by right-clicking the parameter label and selecting 'What's This' or by clicking the Help tab. Note: Some of the global hardware parameters are not currently modifiable in coreConsultant. These settings are in the <workspace>/src/DWC_usb3_params.v file; you must not change them."
default = "0x47822004"
offset = "0x0000C150"
[[register.field]]
name = "USB3_BMU_LSP_DEPTH"
bits = "31:28"
type = "ro"
[[register.field]]
name = "USB3_BMU_PTL_DEPTH"
bits = "27:24"
type = "ro"
[[register.field]]
name = "USB3_EN_ISOC_SUPT"
bits = "23"
type = "ro"
[[register.field]]
name = "RESERVED"
bits = "22"
type = "ro"
[[register.field]]
name = "USB3_EXT_BUFF_CONTROL"
bits = "21"
type = "ro"
[[register.field]]
name = "USB3_NUM_SS_USB_INSTANCES"
bits = "20:17"
type = "ro"
[[register.field]]
name = "USB3_HIBER_SCRATCHBUFS"
bits = "16:13"
type = "ro"
shortdesc = '''`DWC_USB3_HIBER_SCRATCHBUFS Number of external scratchpad buffers the core requires to save its internal state in the device mode.'''
longdesc = '''Each buffer is assumed to be 4KB. The scratchpad buffer array must have this many buffer pointers.'''
[[register.field]]
name = "USB3_EN_SSIC"
bits = "12"
type = "ro"
[[register.field]]
name = "USB3_SSIC_NON_SNPS_MPHY"
bits = "11"
type = "ro"
shortdesc = '''`DWC_USB3_SSIC_NON_SNPS_MPHY This field indicates whether M-PHY or a third-party M-PHY is used with SSIC ports.'''
longdesc = '''- 1'b0: M-PHY - 1'b1: Third-party M-PHY Note: When the DWC_USB3_NUM_SSIC_PORTS parameter is set to zero, this bit is Reserved.'''
[[register.field]]
name = "USB3_SSIC_GEAR"
bits = "10:9"
type = "ro"
[[register.field]]
name = "USB3_NUM_SSIC_NUM_LANE"
bits = "8:7"
type = "ro"
[[register.field]]
name = "RESERVED"
bits = "6"
type = "ro"
[[register.field]]
name = "USB3_CACHE_TRBS_PER_TRANSFER"
bits = "5:0"
type = "ro"
[[register]]
name = "GHWPARAMS5"
type = "ro"
width = 32
description = "Global Hardware Parameters Register 5 This register contains the hardware configuration options that you can select in the coreConsultant GUI. For a description of each parameter, refer to Parameters chapter in the Databook. This information is also available in coreConsultant by right-clicking the parameter label and selecting 'What's This' or by clicking the Help tab. Note: Some of the global hardware parameters are not currently modifiable in coreConsultant. These settings are in the <workspace>/src/DWC_usb3_params.v file; you must not change them."
default = "0x04204108"
offset = "0x0000C154"
[[register.field]]
name = "RESERVED"
bits = "31:28"
type = "ro"
[[register.field]]
name = "USB3_DFQ_FIFO_DEPTH"
bits = "27:22"
type = "ro"
[[register.field]]
name = "USB3_DWQ_FIFO_DEPTH"
bits = "21:16"
type = "ro"
[[register.field]]
name = "USB3_TXQ_FIFO_DEPTH"
bits = "15:10"
type = "ro"
[[register.field]]
name = "USB3_RXQ_FIFO_DEPTH"
bits = "9:4"
type = "ro"
[[register.field]]
name = "USB3_BMU_BUSGM_DEPTH"
bits = "3:0"
type = "ro"
[[register]]
name = "GHWPARAMS6"
type = "ro"
width = 32
description = "Global Hardware Parameters Register 6 This register contains the hardware configuration options that you can select in the coreConsultant GUI. For a description of each parameter, refer to Parameters chapter in the Databook. This information is also available in coreConsultant by right-clicking the parameter label and selecting 'What's This' or by clicking the Help tab. Note: Some of the global hardware parameters are not currently modifiable in coreConsultant. These settings are in the <workspace>/src/DWC_usb3_params.v file; you must not change them."
default = "0x07BAAC20"
offset = "0x0000C158"
[[register.field]]
name = "USB3_RAM0_DEPTH"
bits = "31:16"
type = "ro"
[[register.field]]
name = "BUSFLTRSSUPPORT"
bits = "15"
type = "ro"
  [[register.field]]
    name = "BCSUPPORT"
    bits = "14"
    type = "ro"
  [[register.field]]
    name = "OTG_SS_SUPPORT"
    bits = "13"
    type = "ro"
    shortdesc = '''OTG 3.'''
    longdesc = '''0 Support Enabled This bit indicates whether the parameter `DWC_USB3_EN_OTG is set to 2. In other words, it indicates that whether the DWC_usb3 core supports OTG 3.0. - 1'b0: No OTG 3.0 support - 1'b1: Supports OTG 3.0'''
  [[register.field]]
    name = "ADPSUPPORT"
    bits = "12"
    type = "ro"
  [[register.field]]
    name = "HNPSUPPORT"
    bits = "11"
    type = "ro"
    shortdesc = '''RSP/HNP Support Enabled The application uses this bit to determine the DWC_usb3 core's RSP/HNP support.'''
    longdesc = '''If DWC_USB3_EN_OTG=2, - 1'b0: RSP and HNP support is not enabled. The only exception for this rule is for SSPC-OTG devices where RSP support is not enabled, but HNP support is enabled. (Refer to the OCFG.SSPC-OTG bit.) - 1'b1: RSP and HNP support is enabled If DWC_USB3_EN_OTG=1, - 1'b0: HNP support is not enabled; - 1'b1: HNP support is enabled; This bit is enabled only if HNP mode was specified for HNP Mode of Operation in coreConsultant (parameter DWC_USB3_EN_OTG is not 0, and DWC_USB3_MODE is DRD). Otherwise, it reads 0.'''
  [[register.field]]
    name = "SRPSUPPORT"
    bits = "10"
    type = "ro"
    shortdesc = '''SRP Support Enabled The application uses this bit to determine the DWC_usb3 core's SRP support.'''
    longdesc = '''- 1'b0: SRP support is not enabled; - 1'b1: SRP support is enabled; This bit is 1'b1 when the parameter DWC_USB3_EN_OTG is not 0.'''
[[register.field]]
name = "GHWPARAMS6_9_8"
bits = "9:8"
type = "ro"
[[register.field]]
name = "USB3_EN_FPGA"
bits = "7"
type = "ro"
[[register.field]]
name = "USB3_EN_DBG_PORTS"
bits = "6"
type = "ro"
[[register.field]]
name = "USB3_PSQ_FIFO_DEPTH"
bits = "5:0"
type = "ro"
[[register]]
name = "GHWPARAMS7"
type = "ro"
width = 32
description = "Global Hardware Parameters Register 7 This register contains the hardware configuration options that you can select in the coreConsultant GUI. For a description of each parameter, refer to Parameters chapter in the Databook. This information is also available in coreConsultant by right-clicking the parameter label and selecting 'What's This' or by clicking the Help tab. Note: Some of the global hardware parameters are not currently modifiable in coreConsultant. These settings are in the <workspace>/src/DWC_usb3_params.v file; you must not change them."
default = "0x030807D6"
offset = "0x0000C15C"
[[register.field]]
name = "USB3_RAM2_DEPTH"
bits = "31:16"
type = "ro"
[[register.field]]
name = "USB3_RAM1_DEPTH"
bits = "15:0"
type = "ro"
[[register]]
name = "GDBGFIFOSPACE"
type = "mixed"
width = 32
description = "Global Debug Queue/FIFO Space Available Register Bit Bash test should not be done on this debug register."
default = "0x00420000"
offset = "0x0000C160"
  [[register.field]]
    name = "SPACE_AVAILABLE"
    bits = "31:16"
    type = "ro"
  [[register.field]]
    name = "RESERVED"
    bits = "15:9"
    type = "ro"
  [[register.field]]
    name = "FIFO_QUEUE_SELECT"
    bits = "8:0"
    type = "rw"
    shortdesc = '''FIFO/Queue Select (or) Port-Select - FIFO/Queue Select[8:5] indicates the FIFO/Queue Type - FIFO/Queue Select[4:0] indicates the FIFO/Queue Number For example, 9'b0_0010_0001 refers to RxFIFO_1 and 9'b0_0101_1110 refers to TxReqQ_30.'''
    longdesc = '''- 9'b0_0001_1111 to 9'b0_0000_0000: TxFIFO_31 to TxFIFO_0 - 9'b0_0011_1111 to 9'b0_0010_0000: RxFIFO_31 to RxFIFO_0 - 9'b0_0101_1111 to 9'b0_0100_0000: TxReqQ_31 to TxReqQ_0 - 9'b0_0111_1111 to 9'b0_0110_0000: RxReqQ_31 to RxReqQ_0 - 9'b0_1001_1111 to 9'b0_1000_0000: RxInfoQ_31 to RxInfoQ_0 - 9'b0_1010_0000: DescFetchQ_0 (for backwards compatibility) - 9'b0_1010_0001: EventQ_0 (for backwards compatibility) - 9'b0_1010_0010: ProtocolStatusQ_0 - 9'b0_1101_1111 to 9'b0_1110_0000: DescFetchQ_31 to DescFetchQ_0 - 9'b0_1111_1111 to 9'b0_1110_0000: WriteBack/EventQ_31 to WriteBack/EventQ_0 - 9'b1_0000_0111 to 9'b1_0000_0000: AuxEventQ_7 to AuxEventQ_0 (if EN_SEPARATE_DESC_QUEUES=1) Port-Select[3:0] selects the port-number when accessing GDBGLTSSM register.'''
[[register]]
  name = "GDBGLTSSM"
  type = "ro"
  width = 32
  description = "Global Debug LTSSM Register In multi-port host configuration, the port-number is defined by Port-Select[3:0] field in the GDBGFIFOSPACE register. Note: - GDBGLTSSM register is not applicable for USB 2.0-only mode. - Bit Bash test should not be done on this debug register."
  default = "0x01000442"
  offset = "0x0000C164"
  [[register.field]]
    name = "RESERVED"
    bits = "31"
    type = "ro"
  [[register.field]]
    name = "RXELECIDLE"
    bits = "30"
    type = "ro"
  [[register.field]]
    name = "X3_XS_SWAPPING"
    bits = "29"
    type = "ro"
    shortdesc = '''a3_ds_swapping/a3_us_swapping/ b3_ds_swapping/b3_us_swapping Interpret this field based on the Port direction.'''
    longdesc = '''Note: This bit is applicable only for OTG 3.0 mode of operation and is Reserved for other modes.'''
  [[register.field]]
    name = "X3_DS_HOST_SHUTDOWN"
    bits = "28"
    type = "ro"
    shortdesc = '''a3_ds_host_shutdown/b3_ds_host_shutdown Note: This bit is applicable only for OTG 3.'''
    longdesc = '''0 mode of operation and is Reserved for other modes.'''
  [[register.field]]
    name = "PRTDIRECTION"
    bits = "27"
    type = "ro"
    shortdesc = '''Port Direction - 1'b0: Upstream - 1'b1: Downstream Note: This bit is applicable only for OTG 3.'''
    longdesc = '''0 mode of operation and is Reserved for other modes.'''
  [[register.field]]
    name = "LTDBTIMEOUT"
    bits = "26"
    type = "ro"
  [[register.field]]
    name = "LTDBLINKSTATE"
    bits = "25:22"
    type = "ro"
  [[register.field]]
    name = "LTDBSUBSTATE"
    bits = "21:18"
    type = "ro"
  [[register.field]]
    name = "ELASTICBUFFERMODE"
    bits = "17"
    type = "ro"
  [[register.field]]
    name = "TXELECLDLE"
    bits = "16"
    type = "ro"
  [[register.field]]
    name = "RXPOLARITY"
    bits = "15"
    type = "ro"
  [[register.field]]
    name = "TXDETRXLOOPBACK"
    bits = "14"
    type = "ro"
  [[register.field]]
    name = "LTDBPHYCMDSTATE"
    bits = "13:11"
    type = "ro"
    shortdesc = '''LTSSM PHY command State (LTDBPhyCmdState) - 000: PHY_IDLE (PHY command state is in IDLE.'''
    longdesc = '''No PHY request pending) - 001: PHY_DET (Request to start Receiver detection) - 010: PHY_DET_3 (Wait for Phy_Status (Receiver detection)) - 011: PHY_PWR_DLY (Delay Pipe3_PowerDown P0 -> P1/P2/P3 request) - 100: PHY_PWR_A (Delay for internal logic) - 101: PHY_PWR_B (Wait for Phy_Status(Power state change request))'''
  [[register.field]]
    name = "POWERDOWN"
    bits = "10:9"
    type = "ro"
  [[register.field]]
    name = "RXEQTRAIN"
    bits = "8"
    type = "ro"
  [[register.field]]
    name = "TXDEEMPHASIS"
    bits = "7:6"
    type = "ro"
  [[register.field]]
    name = "LTDBCLKSTATE"
    bits = "5:3"
    type = "ro"
    shortdesc = '''LTSSM Clock State (LTDBClkState) In multi-port host configuration, the port number is defined by Port-Select[3:0] field in the GDBGFIFOSPACE register.'''
    longdesc = '''Note: GDBGLTSSM register is not applicable for USB 2.0-only mode. - 000: CLK_NORM (PHY is in non-P3 state and PCLK is running) - 001: CLK_TO_P3 (P3 entry request to PHY); - 010: CLK_WAIT1 (Wait for Phy_Status (P3 request)); - 011: CLK_P3 (PHY is in P3 and PCLK is not running); - 100: CLK_TO_P0 (P3 exit request to PHY); - 101: CLK_WAIT2 (Wait for Phy_Status (P3 exit request))'''
  [[register.field]]
    name = "TXSWING"
    bits = "2"
    type = "ro"
  [[register.field]]
    name = "RXTERMINATION"
    bits = "1"
    type = "ro"
    shortdesc = '''Rx Termination (RxTermination) For details on `DWC_USB3_PIPE_RXTERM_RESET_VAL, refer to <workspace>/src/DWC_usb3_params.'''
    longdesc = '''v'''
  [[register.field]]
    name = "TXONESZEROS"
    bits = "0"
    type = "ro"
[[register]]
  name = "GDBGLNMCC"
  type = "ro"
  width = 32
  description = "Global Debug LNMCC Register Bit Bash test should not be done on this debug register."
  default = "0x00000000"
  offset = "0x0000C168"
  [[register.field]]
    name = "RESERVED"
    bits = "31:9"
    type = "ro"
  [[register.field]]
    name = "LNMCC_BERC"
    bits = "8:0"
    type = "ro"
    shortdesc = '''This field indicates the bit error rate information for the port selected in the GDBGFIFOSPACE.'''
    longdesc = '''PortSelect field. This field is for debug purposes only.'''
[[register]]
  name = "GDBGBMU"
  type = "ro"
  width = 32
  description = "Global Debug BMU Register Bit Bash test should not be done on this debug register."
  default = "0x00000000"
  offset = "0x0000C16C"
  [[register.field]]
    name = "BMU_BCU"
    bits = "31:8"
    type = "ro"
  [[register.field]]
    name = "BMU_DCU"
    bits = "7:4"
    type = "ro"
  [[register.field]]
    name = "BMU_CCU"
    bits = "3:0"
    type = "ro"
[[register]]
  name = "GDBGLSPMUX_HST"
  type = "mixed"
  width = 32
  description = "Global Debug LSP MUX Register - Host This register is for internal use only. If DWC_USB3_PRESERVE_LOGIC_ANALYZER_SELECT is enabled during core configuration, then the default values readout is X (Undefined). Bit Bash test should not be done on this debug register."
  default = "0x003F0000"
  offset = "0x0000C170"
  [[register.field]]
    name = "RESERVED"
    bits = "31:24"
    type = "ro"
  [[register.field]]
    name = "LOGIC_ANALYZER_TRACE"
    bits = "23:16"
    type = "rw"
    shortdesc = '''logic_analyzer_trace Port MUX Select Currently only bits[21:16] are used.'''
    longdesc = '''For details on how the mux controls the debug traces, refer to the 'assign logic_analyzer_trace =' code section in the DWC_usb3.v file. A value of 6'h3F drives 0s on the logic_analyzer_trace signal. If you plan to OR (instead using a mux) this signal with other trace signals in your system to generate a common trace signal, you can use this feature.'''
  [[register.field]]
    name = "RESERVED"
    bits = "15:14"
    type = "ro"
  [[register.field]]
    name = "HOSTSELECT"
    bits = "13:0"
    type = "rw"
[[register]]
  name = "GDBGLSP"
  type = "ro"
  width = 32
  description = "Global Debug LSP Register This register is for internal debug purposes only. This register is for internal use only. If DWC_USB3_PRESERVE_LOGIC_ANALYZER_SELECT is enabled during core configuration, then the default values readout is X (Undefined). Bit Bash test should not be done on this debug register."
  default = "0x00000000"
  offset = "0x0000C174"
  [[register.field]]
    name = "LSPDEBUG"
    bits = "31:0"
    type = "ro"
[[register]]
  name = "GDBGEPINFO0"
  type = "ro"
  width = 32
  description = "Global Debug Endpoint Information Register 0 This register is for internal use only. If DWC_USB3_PRESERVE_LOGIC_ANALYZER_SELECT is enabled during core configuration, then the default values readout is X (Undefined). Bit Bash test should not be done on this debug register."
  default = "0x00000000"
  offset = "0x0000C178"
  [[register.field]]
    name = "EPDEBUG"
    bits = "31:0"
    type = "ro"
[[register]]
  name = "GDBGEPINFO1"
  type = "ro"
  width = 32
  description = "Global Debug Endpoint Information Register 1 This register is for internal use only. If DWC_USB3_PRESERVE_LOGIC_ANALYZER_SELECT is enabled during core configuration, then the default values readout is X (Undefined). Bit Bash test should not be done on this debug register."
  default = "0x00800000"
  offset = "0x0000C17C"
  [[register.field]]
    name = "EPDEBUG"
    bits = "31:0"
    type = "ro"
[[register]]
  name = "GPRTBIMAP_HSLO"
  type = "mixed"
  width = 32
  description = "Global High-Speed Port to Bus Instance Mapping Register - Low This is an alternate register for the GPRTBIMAP_HS register. Note: For reset values, refer to the corresponding values in the GPRTBIMAP_HS register."
  default = "0x00000000"
  offset = "0x0000C180"
  [[register.field]]
    name = "BINUM8"
    bits = "31:28"
    type = "ro"
    shortdesc = '''BINUM8: HS USB Instance Number for Port 8.'''
    longdesc = '''Application-programmable ID field.'''
  [[register.field]]
    name = "BINUM7"
    bits = "27:24"
    type = "ro"
    shortdesc = '''BINUM7: HS USB Instance Number for Port 7.'''
    longdesc = '''Application-programmable ID field.'''
  [[register.field]]
    name = "BINUM6"
    bits = "23:20"
    type = "ro"
    shortdesc = '''BINUM6 USB Instance Number for Port 6.'''
    longdesc = '''Application-programmable ID field.'''
  [[register.field]]
    name = "BINUM5"
    bits = "19:16"
    type = "ro"
    shortdesc = '''BINUM5: HS USB Instance Number for Port 5.'''
    longdesc = '''Application-programmable ID field.'''
  [[register.field]]
    name = "BINUM4"
    bits = "15:12"
    type = "ro"
    shortdesc = '''BINUM4: HS USB Instance Number for Port 4.'''
    longdesc = '''Application-programmable ID field.'''
  [[register.field]]
    name = "BINUM3"
    bits = "11:8"
    type = "ro"
    shortdesc = '''BINUM3: HS USB Instance Number for Port 3.'''
    longdesc = '''Application-programmable ID field.'''
  [[register.field]]
    name = "BINUM2"
    bits = "7:4"
    type = "ro"
    shortdesc = '''BINUM2: HS USB Instance Number for Port 2.'''
    longdesc = '''Application-programmable ID field.'''
  [[register.field]]
    name = "BINUM1"
    bits = "3:0"
    type = "rw"
    shortdesc = '''BINUM1: HS USB Instance Number for Port 1.'''
    longdesc = '''Application-programmable ID field.'''
[[register]]
  name = "GPRTBIMAP_HSHI"
  type = "ro"
  width = 32
  description = "Global High-Speed Port to Bus Instance Mapping Register - High This is an alternate register for the GPRTBIMAP_HS register. Note: For reset values, refer to the corresponding values in the GPRTBIMAP register."
  default = "0x00000000"
  offset = "0x0000C184"
  [[register.field]]
    name = "RESERVED"
    bits = "31:28"
    type = "ro"
  [[register.field]]
    name = "BINUM15"
    bits = "27:24"
    type = "ro"
    shortdesc = '''BINUM15: HS USB Instance Number for Port 15.'''
    longdesc = '''Application-programmable ID field.'''
  [[register.field]]
    name = "BINUM14"
    bits = "23:20"
    type = "ro"
    shortdesc = '''BINUM14: HS USB Instance Number for Port 14.'''
    longdesc = '''Application-programmable ID field.'''
  [[register.field]]
    name = "BINUM13"
    bits = "19:16"
    type = "ro"
    shortdesc = '''BINUM13: HS USB Instance Number for Port 13.'''
    longdesc = '''Application-programmable ID field.'''
  [[register.field]]
    name = "BINUM12"
    bits = "15:12"
    type = "ro"
    shortdesc = '''BINUM12: HS USB Instance Number for Port 12.'''
    longdesc = '''SApplication-programmable ID field.'''
  [[register.field]]
    name = "BINUM11"
    bits = "11:8"
    type = "ro"
    shortdesc = '''BINUM11: HS USB Instance Number for 11.'''
    longdesc = '''Application-programmable ID field.'''
  [[register.field]]
    name = "BINUM10"
    bits = "7:4"
    type = "ro"
    shortdesc = '''BINUM10: HS USB Instance Number for Port 10.'''
    longdesc = '''Application-programmable ID field.'''
  [[register.field]]
    name = "BINUM9"
    bits = "3:0"
    type = "ro"
    shortdesc = '''BINUM9: HS USB Instance Number for Port 9.'''
    longdesc = '''Application-programmable ID field.'''
[[register]]
  name = "GPRTBIMAP_FSLO"
  type = "mixed"
  width = 32
  description = "Global Full-Speed Port to Bus Instance Mapping Register - Low This is an alternate register for the GPRTBIMAP_FS register. Note: For reset values, refer to the corresponding values in the GPRTBIMAP_FS register."
  default = "0x00000000"
  offset = "0x0000C188"
  [[register.field]]
    name = "BINUM8"
    bits = "31:28"
    type = "ro"
    shortdesc = '''BINUM8: FS USB Instance Number for Port 8.'''
    longdesc = '''Application-programmable ID field.'''
  [[register.field]]
    name = "BINUM7"
    bits = "27:24"
    type = "ro"
    shortdesc = '''BINUM7: FS USB Instance Number for Port 7.'''
    longdesc = '''Application-programmable ID field.'''
  [[register.field]]
    name = "BINUM6"
    bits = "23:20"
    type = "ro"
    shortdesc = '''BINUM6: FS USB Instance Number for Port 6.'''
    longdesc = '''Application-programmable ID field.'''
  [[register.field]]
    name = "BINUM5"
    bits = "19:16"
    type = "ro"
    shortdesc = '''BINUM5: FS USB Instance Number for Port 5.'''
    longdesc = '''Application-programmable ID field.'''
  [[register.field]]
    name = "BINUM4"
    bits = "15:12"
    type = "ro"
    shortdesc = '''BINUM4: FS USB Instance Number for Port 4.'''
    longdesc = '''Application-programmable ID field.'''
  [[register.field]]
    name = "BINUM3"
    bits = "11:8"
    type = "ro"
    shortdesc = '''BINUM3: FS USB Instance Number for Port 3.'''
    longdesc = '''Application-programmable ID field.'''
  [[register.field]]
    name = "BINUM2"
    bits = "7:4"
    type = "ro"
    shortdesc = '''BINUM2: FS USB Instance Number for Port 2.'''
    longdesc = '''Application-programmable ID field.'''
  [[register.field]]
    name = "BINUM1"
    bits = "3:0"
    type = "rw"
    shortdesc = '''BINUM1: FS USB Instance Number for Port 1.'''
    longdesc = '''Application-programmable ID field.'''
[[register]]
  name = "GPRTBIMAP_FSHI"
  type = "ro"
  width = 32
  description = "Global Full-Speed Port to Bus Instance Mapping Register - High This is an alternate register for the GPRTBIMAP_FS register. Note: For reset values, refer to the corresponding values in the GPRTBIMAP_FS register."
  default = "0x00000000"
  offset = "0x0000C18C"
  [[register.field]]
    name = "RESERVED"
    bits = "31:28"
    type = "ro"
  [[register.field]]
    name = "BINUM15"
    bits = "27:24"
    type = "ro"
    shortdesc = '''BINUM15: FS USB Instance Number for Port 15.'''
    longdesc = '''Application-programmable ID field'''
  [[register.field]]
    name = "BINUM14"
    bits = "23:20"
    type = "ro"
    shortdesc = '''BINUM14: FS USB Instance Number for Port 14.'''
    longdesc = '''Application-programmable ID field'''
  [[register.field]]
    name = "BINUM13"
    bits = "19:16"
    type = "ro"
    shortdesc = '''BINUM13: FS USB Instance Number for Port 13.'''
    longdesc = '''Application-programmable ID field'''
  [[register.field]]
    name = "BINUM12"
    bits = "15:12"
    type = "ro"
    shortdesc = '''BINUM12: FS USB Instance Number for Port 12.'''
    longdesc = '''Application-programmable ID field'''
  [[register.field]]
    name = "BINUM11"
    bits = "11:8"
    type = "ro"
    shortdesc = '''BINUM11: FS USB Instance Number for Port 11.'''
    longdesc = '''Application-programmable ID field'''
  [[register.field]]
    name = "BINUM10"
    bits = "7:4"
    type = "ro"
    shortdesc = '''BINUM10: FS USB Instance Number for Port 10.'''
    longdesc = '''Application-programmable ID field'''
  [[register.field]]
    name = "BINUM9"
    bits = "3:0"
    type = "ro"
    shortdesc = '''BINUM9: FS USB Instance Number for Port 9.'''
    longdesc = '''Application-programmable ID field.'''
[[register]]
  name = "RESERVED_94"
  type = "ro"
  width = 32
  description = "Future Register"
  default = "0x00000000"
  offset = "0x0000C194"
  [[register.field]]
    name = "RESERVED"
    bits = "31:0"
    type = "ro"
[[register]]
  name = "RESERVED_98"
  type = "ro"
  width = 32
  description = "Future Register"
  default = "0x00000000"
  offset = "0x0000C198"
  [[register.field]]
    name = "RESERVED"
    bits = "31:0"
    type = "ro"
[[register]]
  name = "GUSB2PHYCFG"
  type = "mixed"
  width = 32
  description = "Global USB2 PHY Configuration Register The application must program this register before starting any transactions on either the SoC bus or the USB. In Device-only configurations, only one register is needed. In Host mode, per-port registers are implemented."
  default = "0x00000000"
  offset = "0x0000C200"
  [[register.field]]
    name = "PHYSOFTRST"
    bits = "31"
    type = "rw"
    shortdesc = '''UTMI PHY Soft Reset (PHYSoftRst) Causes the usb2phy_reset signal to be asserted to reset a UTMI PHY.'''
    longdesc = '''Not applicable to ULPI because ULPI PHYs are reset via their FunctionControl.Reset register, and the core automatically writes to this register when the core is reset (vcc_reset_n, USBCMD.HCRST, DCTL.SoftReset, or GCTL.SoftReset)'''
  [[register.field]]
    name = "U2_FREECLK_EXISTS"
    bits = "30"
    type = "rw"
    shortdesc = '''U2_FREECLK_EXISTS Specifies whether your USB 2.'''
    longdesc = '''0 PHY provides a free-running PHY clock, which is active when the clock control input is active. If your USB 2.0 PHY provides a free-running PHY clock, it must be connected to the utmi_clk[0] input. The remaining utmi_clk[n] must be connected to the respective port clocks. The core uses the Port-0 clock for generating the internal mac2 clock. - 1'b0: USB 2.0 free clock does not exist - 1'b1: USB 2.0 free clock exists Note: When the core is configured as device-only (DWC_USB3_MODE = 0), do not set this bit to 1.'''
  [[register.field]]
    name = "ULPI_LPM_WITH_OPMODE_CHK"
    bits = "29"
    type = "rw"
    shortdesc = '''ULPI_LPM_WITH_OPMODE_CHK Support the LPM over ULPI without NOPID token to the ULPI PHY.'''
    longdesc = '''If this bit is set, the ULPI PHY is expected to qualify the EXT PID with OPMODE=2'b00 for LPM and not treat it as a NOPID. Check with your PHY vendor about your PHY behavior. This bit is valid only when the DWC_USB3_HSPHY_INTERFACE parameter is 2 or 3. - 1'b0: A NOPID is sent before sending an EXTPID for LPM; - 1'b1: An EXTPID is sent without previously sending a NOPID; Note: This bit is valid only in host mode. This bit should be '0' for PHY.'''
  [[register.field]]
    name = "HSIC_CON_WIDTH_ADJ"
    bits = "28:27"
    type = "ro"
    shortdesc = '''HSIC_CON_WIDTH_ADJ This bit is used in the HSIC device mode of operation.'''
    longdesc = '''By default, the connect duration for the HSIC device controller is thrice the strobe period. You can change this duration to 4, 5, or 6 times the strobe period by setting the value of this field to 1, 2, or 3. This value is added to the default connect duration.'''
  [[register.field]]
    name = "INV_SEL_HSIC"
    bits = "26"
    type = "ro"
    shortdesc = '''INV_SEL_HSIC The application driver uses this bit to control the HSIC enable/disable function.'''
    longdesc = '''When set to '1', this bit overrides and functionally inverts the 'if_select_hsic' input signal. If {INV_SEL_HSIC, if_select_hsic} is: - 00: HSIC Capability is disabled. - 01: HSIC Capability is enabled. - 10: HSIC Capability is enabled. - 11: HSIC Capability is disabled. If the controller operates as non-HSIC-capable, it can only connect to non-HSIC-capable PHYs. If it operates as HSIC-capable, it can connect to HSIC-capable PHYs. This bit is reserved if the DWC_USB3_ENABLE_HSIC parameter is set to '0'. When selecting the HSIC feature, set the host side to HSIC mode first, then set the device mode side. If the device side is set to HSIC mode first and if the host does not see a connection in HSIC mode, then you must de-select the device HSIC mode and select it again using the if_select_hsic setting or register bit GUSB2PHYCFGn[26] to ensure that the device can connect to the host.'''
  [[register.field]]
    name = "RESERVED"
    bits = "25"
    type = "ro"
  [[register.field]]
    name = "LSTRD"
    bits = "24:22"
    type = "rw"
    shortdesc = '''LS Turnaround Time (LSTRDTIM) This field indicates the value of the Rx-to-Tx packet gap for LS devices.'''
    longdesc = '''The encoding is as follows: - 0: 2 bit times - 1: 2.5 bit times - 2: 3 bit times - 3: 3.5 bit times - 4: 4 bit times - 5: 4.5 bit times - 6: 5 bit times - 7: 5.5 bit times Note: - This field is applicable only in Host mode. - For normal operation (to work with most LS devices), set the default value of this field to 3'h0 (2 bit times). - The programmable LS device inter-packet gap and turnaround delays are provided to support some legacy LS devices that might require different delays than the default/fixed ones. For instance, the Open LS mouse requires 3 bit times of inter-packet gap to work correctly. - Include your PHY delays when programming the LSIPD/LSTRDTIM values. For example, if your PHY's TxEndDelay in LS mode is 30 UTMI/ULPI CLKs, then subtract this delay (~1 LS bit time) from the device's delay requirement.'''
  [[register.field]]
    name = "LSIPD"
    bits = "21:19"
    type = "rw"
    shortdesc = '''LS Inter-Packet Time (LSIPD) This field indicates the value of Tx-to-Tx packet gap for LS devices.'''
    longdesc = '''The encoding is as follows: - 0: 2 bit times - 1: 2.5 bit times - 2: 3 bit times - 3: 3.5 bit times - 4: 4 bit times - 5: 4.5 bit times - 6: 5 bit times - 7: 5.5 bit times Note: - This field is applicable only in Host mode. - For normal operation (to work with most LS devices), set the default value of this field to 3'h2 (3 bit times). - The programmable LS device inter-packet gap and turnaround delays are provided to support some legacy LS devices that might require different delays than the default/fixed ones. For instance, the AOpen LS mouse requires 3 bit times of inter-packet gap to work correctly. - Include your PHY delays when programming the LSIPD/LSTRDTIM values. For example, if your PHY's TxEndDelay in LS mode is 30 UTMI/ULPI CLKs, then subtract this delay (~1 LS bit time) from the device's delay requirement.'''
  [[register.field]]
    name = "ULPIEXTVBUSINDIACTOR"
    bits = "18"
    type = "rw"
    shortdesc = '''ULPI External VBUS Indicator (ULPIExtVbusIndicator) Indicates the ULPI PHY VBUS over-current indicator.'''
    longdesc = '''- 1'b0: PHY uses an internal VBUS valid comparator. - 1'b1: PHY uses an external VBUS valid comparator. Valid only when RTL parameter DWC_USB3_HSPHY_INTERFACE = 2 or 3'''
  [[register.field]]
    name = "ULPIEXTVBUSDRV"
    bits = "17"
    type = "rw"
    shortdesc = '''ULPI External VBUS Drive (ULPIExtVbusDrv) Selects supply source to drive 5V on VBUS, in the ULPI PHY.'''
    longdesc = '''- 1'b0: PHY drives VBUS with internal charge pump (default). - 1'b1: PHY drives VBUS with an external supply. (Only when RTL parameter DWC_USB3_HSPHY_INTERFACE = 2 or 3)'''
  [[register.field]]
    name = "RESERVED"
    bits = "16"
    type = "ro"
  [[register.field]]
    name = "ULPIAUTORES"
    bits = "15"
    type = "rw"
    shortdesc = '''ULPI Auto Resume (ULPIAutoRes) Sets the AutoResume bit in Interface Control register on the ULPI PHY.'''
    longdesc = '''- 1'b0: PHY does not use the AutoResume feature. - 1'b1: PHY uses the AutoResume feature. Valid only when RTL parameter DWC_USB3_HSPHY_INTERFACE = 2 or 3'''
  [[register.field]]
    name = "RESERVED"
    bits = "14"
    type = "ro"
  [[register.field]]
    name = "USBTRDTIM"
    bits = "13:10"
    type = "rw"
    shortdesc = '''USB 2.'''
    longdesc = '''0 Turnaround Time (USBTrdTim) Sets the turnaround time in PHY clocks. Specifies the response time for a MAC request to the Packet FIFO Controller (PFC) to fetch data from the DFIFO (SPRAM). The following are the required values for the minimum SoC bus frequency of 60 MHz. USB turnaround time is a critical certification criteria when using long cables and five hub levels. The required values for this field: - 4'h5: When the MAC interface is 16-bit UTMI+. - 4'h9: When the MAC interface is 8-bit UTMI+/ULPI. If SoC bus clock is less than 60 MHz, and USB turnaround time is not critical, this field can be set to a larger value. Note: This field is valid only in device mode.'''
  [[register.field]]
    name = "XCVRDLY"
    bits = "9"
    type = "rw"
    shortdesc = '''Transceiver Delay: Enables a delay between the assertion of the UTMI/ULPI Transceiver Select signal (for HS) and the assertion of the TxValid signal during a HS Chirp.'''
    longdesc = '''When this bit is set to 1, a delay (of approximately 2.5 us) is introduced from the time when the Transceiver Select is set to 2'b00 (HS) to the time the TxValid is driven to 0 for sending the chirp-K. This delay is required for some UTMI/ULPI PHYs. Note: - If you enable the hibernation feature when the device core comes out of power-off, you must re-initialize this bit with the appropriate value because the core does not save and restore this bit value during hibernation. - This bit is valid only in device mode.'''
  [[register.field]]
    name = "ENBLSLPM"
    bits = "8"
    type = "rw"
    shortdesc = '''Enable utmi_sleep_n and utmi_l1_suspend_n (EnblSlpM) The application uses this bit to control utmi_sleep_n and utmi_l1_suspend_n assertion to the PHY in the L1 state.'''
    longdesc = '''- 1'b0: utmi_sleep_n and utmi_l1_suspend_n assertion from the core is not transferred to the external PHY. - 1'b1: utmi_sleep_n and utmi_l1_suspend_n assertion from the core is transferred to the external PHY. Note: This bit must be set high for Port0 if PHY is used. Note: In Device mode - Before issuing any device endpoint command when operating in 2.0 speeds, disable this bit and enable it after the command completes. Without disabling this bit, if a command is issued when the device is in L1 state and if mac2_clk (utmi_clk/ulpi_clk) is gated off, the command will not get completed.'''
  [[register.field]]
    name = "PHYSEL"
    bits = "7"
    type = "wo"
    shortdesc = '''USB 2.'''
    longdesc = '''0 High-Speed PHY or USB 1.1 Full-Speed Serial Transceiver Select The application uses this bit to select a high-speed PHY or a full-speed transceiver. - 1'b0: USB 2.0 high-speed UTMI+ or ULPI PHY. This bit is always 0, with Write Only access. - 1'b1: USB 1.1 full-speed serial transceiver. This bit is always 1, with Write Only access. If both interface types are selected in coreConsultant (that is, parameters' values are not zero), the application uses this bit to select the active interface is active, with Read-Write bit access. Note: USB 1.1 full-serial transceiver is not supported. This bit always reads as 1'b0.'''
  [[register.field]]
    name = "SUSPENDUSB20"
    bits = "6"
    type = "rw"
    shortdesc = '''Suspend USB2.'''
    longdesc = '''0 HS/FS/LS PHY (SusPHY) When set, USB2.0 PHY enters Suspend mode if Suspend conditions are valid. For DRD/OTG configurations, it is recommended that this bit is set to 0 during coreConsultant configuration. If it is set to 1, then the application must clear this bit after power-on reset. Application needs to set it to 1 after the core initialization completes. For all other configurations, this bit can be set to 1 during core configuration. Note: - In host mode, on reset, this bit is set to 1. Software can override this bit after reset. - In device mode, before issuing any device endpoint command when operating in 2.0 speeds, disable this bit and enable it after the command completes. If you issue a command without disabling this bit when the device is in L2 state and if mac2_clk (utmi_clk/ulpi_clk) is gated off, the command will not get completed.'''
  [[register.field]]
    name = "FSINTF"
    bits = "5"
    type = "ro"
    shortdesc = '''Full-Speed Serial Interface Select (FSIntf) The application uses this bit to select a unidirectional or bidirectional USB 1.'''
    longdesc = '''1 full-speed serial transceiver interface. - 1'b0: 6-pin unidirectional full-speed serial interface. This bit is set to 0 with Read Only access. - 1'b1: 3-pin bidirectional full-speed serial interface. This bit is set to 0 with Read Only access. Note: USB 1.1 full-speed serial interface is not supported. This bit always reads as 1'b0.'''
  [[register.field]]
    name = "ULPI_UTMI_SEL"
    bits = "4"
    type = "ro"
    shortdesc = '''ULPI or UTMI+ Select (ULPI_UTMI_Sel) The application uses this bit to select a UTMI+ or ULPI Interface.'''
    longdesc = '''- 1'b0: UTMI+ Interface - 1'b1: ULPI Interface This bit is writable only if UTMI+ and ULPI is specified for High-Speed PHY Interface(s) in coreConsultant configuration (DWC_USB3_HSPHY_INTERFACE = 3). Otherwise, this bit is read-only and the value depends on the interface selected through DWC_USB3_HSPHY_INTERFACE.'''
  [[register.field]]
    name = "PHYIF"
    bits = "3"
    type = "rw"
    shortdesc = '''PHY Interface (PHYIf) If UTMI+ is selected, the application uses this bit to configure the core to support a UTMI+ PHY with an 8- or 16-bit interface.'''
    longdesc = '''- 1'b0: 8 bits - 1'b1: 16 bits ULPI Mode: 1'b0 Note: - All the enabled 2.0 ports must have the same clock frequency as Port0 clock frequency (utmi_clk[0]). - The UTMI 8-bit and 16-bit modes cannot be used together for different ports at the same time (that is, all the ports must be in 8-bit mode, or all of them must be in 16-bit mode, at a time). - If any of the USB 2.0 ports is selected as ULPI port for operation, then all the USB 2.0 ports must be operating at 60 MHz.'''
  [[register.field]]
    name = "TOUTCAL"
    bits = "2:0"
    type = "rw"
    shortdesc = '''HS/FS Timeout Calibration (TOutCal) The number of PHY clocks, as indicated by the application in this field, is multiplied by a bit-time factor; this factor is added to the high-speed/full-speed interpacket timeout duration in the core to account for additional delays introduced by the PHY.'''
    longdesc = '''This may be required, since the delay introduced by the PHY in generating the linestate condition may vary among PHYs. The USB standard timeout value for high-speed operation is 736 to 816 (inclusive) bit times. The USB standard timeout value for full-speed operation is 16 to 18 (inclusive) bit times. The application must program this field based on the speed of connection. The number of bit times added per PHY clock are: High-speed operation: - One 30-MHz PHY clock = 16 bit times - One 60-MHz PHY clock = 8 bit times Full-speed operation: - One 30-MHz PHY clock = 0.4 bit times - One 60-MHz PHY clock = 0.2 bit times - One 48-MHz PHY clock = 0.25 bit times'''
[[register]]
  name = "GUSB2I2CCTL"
  type = "ro"
  width = 32
  description = "Reserved Register The application uses this register to access OTG devices connected to the OTG core through the I2C interface. It is implemented only if Enable I2C Interface was selected during coreConsultant configuration (parameter DWC_USB3_I2C_INTERFACE = 1). The I2C interface on the OTG core can read and write the register space in the attached I2C device. The following table describes the register fields. In Device-only configurations, only one register is needed. In Host mode, per-port registers are implemented."
  default = "0x00000000"
  offset = "0x0000C240"
  [[register.field]]
    name = "RESERVED"
    bits = "31:0"
    type = "ro"
[[register]]
  name = "GUSB2PHYACC_ULPI"
  type = "mixed"
  width = 32
  description = "Global USB 2.0 UTMI PHY Vendor Control Register The application used this register to access PHY registers. It is implemented only if 'Enable PHY Vendor Control Interface' was selected during coreConsultant configuration (parameter DWC_USB3_VENDOR_CTL_INTERFACE = 1). For an ULPI PHY, the core uses the ULPI interface for PHY register access. The application sets the Vendor Control register for PHY register access and times the PHY register access. The application polls the VStatus Done bit in this register for the completion of the PHY register access. In Device-only configurations, only one register is needed. In Host mode, per-port registers are implemented"
  default = "0x00000000"
  offset = "0x0000C280"
  [[register.field]]
    name = "RESERVED"
    bits = "31:27"
    type = "ro"
  [[register.field]]
    name = "DISUIPIDRVR"
    bits = "26"
    type = "ro"
  [[register.field]]
    name = "NEWREGREQ"
    bits = "25"
    type = "rw"
    shortdesc = '''New Register Request The application sets this bit for a new vendor control access.'''
    longdesc = '''Setting this bit to 1 asserts the utmi_vcontrolload_n (1'b0) on the UTMI interface.'''
  [[register.field]]
    name = "VSTSDONE"
    bits = "24"
    type = "ro"
  [[register.field]]
    name = "VSTSBSY"
    bits = "23"
    type = "rw"
  [[register.field]]
    name = "REGWR"
    bits = "22"
    type = "rw"
    shortdesc = '''Register Write The application sets this bit for register writes and clears it for register reads.'''
    longdesc = '''Note: This bit is applicable for ULPI register read/write access only.'''
  [[register.field]]
    name = "REGADDR"
    bits = "21:16"
    type = "rw"
    shortdesc = '''Register Address The 6-bit PHY register address for immediate PHY Register Set access.'''
    longdesc = '''Set to 6'h2F for Extended PHY Register Set access. Note: These bits are applicable for ULPI only.'''
  [[register.field]]
    name = "EXTREGADDR"
    bits = "15:8"
    type = "rw"
  [[register.field]]
    name = "REGDATA"
    bits = "7:0"
    type = "rw"
[[register]]
  name = "GUSB3PIPECTL"
  type = "mixed"
  width = 32
  description = "Global USB 3.0 PIPE Control Register The application uses this register to configure the USB3 PHY and PIPE interface. Device-only configuration requires only one register. In Host mode, registers are implemented for each port. For more details on GUSB3PIPECTL(#n) bits, refer to section 'GUSB3PIPECTL(#n) Register' in the DWC SuperSpeed USB 3.0 Controller User Guide. Note: - GUSB3PIPECTLn registers are not applicable for USB 2.0-only mode."
  default = "0x010C0002"
  offset = "0x0000C2C0"
  [[register.field]]
    name = "PHYSOFTRST"
    bits = "31"
    type = "rw"
  [[register.field]]
    name = "HSTPRTCMPL"
    bits = "30"
    type = "rw"
    shortdesc = '''HstPrtCmpl This feature tests the PIPE PHY compliance patterns without having to have a test fixture on the USB 3.'''
    longdesc = '''0 cable. This bit enables placing the SS port link into a compliance state. By default, this bit must be set to 1'b0. In compliance lab testing, the SS port link enters compliance after failing the first polling sequence after power on. Set this bit to 0, when you run compliance tests. The sequence for using this functionality is as follows: - 1. Disconnect any plugged in devices. - 2. Perform USBCMD.HCRST or power-on-chip reset. - 3. Set PORTSC.PP=0. - 4. Set GUSB3PIPECTL. HstPrtCmpl=1. This places the link into compliance state. To advance the compliance pattern, follow this sequence (toggle the set GUSB3PIPECTL. HstPrtCmpl): - 1. Set GUSB3PIPECTL.HstPrtCmpl=0. - 2. Set GUSB3PIPECTL.HstPrtCmpl=1. This advances the link to the next compliance pattern. To exit from the compliance state perform USBCMD.HCRST or power-on-chip reset.'''
  [[register.field]]
    name = "U2SSINACTP3OK"
    bits = "29"
    type = "rw"
    shortdesc = '''P3 OK for U2/SSInactive (u2SSInactP3ok) - 0: During link state U2/SS.'''
    longdesc = '''Inactive, put PHY in P2 (Default) - 1: During link state U2/SS.Inactive, put PHY in P3. Note: For a port, if GUSB3PIPECTL[7]=1 and GUSB3PIPECTL[29]=1, set GUSB3PIPECTL[11] to 1.'''
  [[register.field]]
    name = "DISRXDETP3"
    bits = "28"
    type = "rw"
    shortdesc = '''Disabled receiver detection in P3 (DisRxDetP3) - 0: If PHY is in P3 and Core needs to perform receiver detection, The core performs receiver detection in P3.'''
    longdesc = '''(Default) - 1: If PHY is in P3 and Core needs to perform receiver detection, The core changes the PHY power state to P2 and then performs receiver detection. After receiver detection, the cores changes PHY power state to P3.'''
  [[register.field]]
    name = "UX_EXIT_IN_PX"
    bits = "27"
    type = "rw"
    shortdesc = '''Ux Exit in Px (Ux_exit_in_Px) - 0: The core does U1/U2/U3 exit in PHY power state P0 (default behavior).'''
    longdesc = '''- 1: The core does U1/U2/U3 exit in PHY power state P1/P2/P3 respectively. This bit is added for SS PHY workaround where SS PHY injects a glitch on pipe3_RxElecIdle while receiving Ux exit LFPS, and pipe3_PowerDown change is in progress. Note: This bit is used by third-party SS PHY. It must be set to '0' for PHY. For configuration, Ux_exit_in_Px field of GUSB3PIPECTL register must never be set to 1'''
  [[register.field]]
    name = "PING_ENHANCEMENT_EN"
    bits = "26"
    type = "rw"
    shortdesc = '''Ping Enhancement Enable (ping_enhancement_en) When set, the Downstream port U1 ping receive timeout becomes 500 ms instead of 300 ms.'''
    longdesc = '''Minimum Ping.LFPS receive duration is 8 ns (one mac3_clk). This field is valid for the downstream port only. Note: This bit is used by third-party SS PHY. It must be set to '0' for PHY.'''
  [[register.field]]
    name = "U1U2EXITFAIL_TO_RECOV"
    bits = "25"
    type = "rw"
    shortdesc = '''U1U2exitfail to Recovery (u1u2exitfail_to_recov) When set, and U1/U2 LFPS handshake fails, the LTSSM transitions from U1/U2 to Recovery instead of SS Inactive.'''
    longdesc = '''If Recovery fails, then the LTSSM can enter SS.Inactive. This is an enhancement only. It prevents interoperability issue if the remote link does not do proper handshake.'''
  [[register.field]]
    name = "REQUEST_P1P2P3"
    bits = "24"
    type = "rw"
    shortdesc = '''Always Request P1/P2/P3 for U1/U2/U3 (request_p1p2p3) When set, the core always requests PHY power change from P0 to P1/P2/P3 during U0 to U1/U2/U3 transition.'''
    longdesc = '''If this bit is 0, and immediate Ux exit (remotely initiated, or locally initiated) happens, the core does not request P1/P2/P3 power state change. Note: This bit must be set to '1' for PHY. For third-party SS PHY, check with your PHY vendor.'''
  [[register.field]]
    name = "STARTRXDETU3RXDET"
    bits = "23"
    type = "wo"
    shortdesc = '''Start Receiver Detection in U3/Rx.'''
    longdesc = '''Detect (StartRxdetU3RxDet) If DWC_USB3_GUSB3PIPECTL_INIT[22] is set, and the link is in either U3 or Rx.Detect state, the core starts receiver detection on the rising edge of this bit. This can only be used for Downstream ports. This bit must be set to '0' for Upstream ports. This feature must not be enabled for normal operation. If have to use this feature, contact.'''
  [[register.field]]
    name = "DISRXDETU3RXDET"
    bits = "22"
    type = "rw"
    shortdesc = '''Disable Receiver Detection in U3/Rx.'''
    longdesc = '''Det When set, the core does not handle receiver detection in either U3 or Rx.Detect states. DWC_USB3_GUSB3PIPECTL_INIT[23] must be used to start receiver detection manually. This bit can only be used for the downstream port. This bit must be set to '0' for Upstream ports. This feature must not be enabled for normal operation. If you have to use this feature, contact.'''
  [[register.field]]
    name = "DELAYP1P2P3"
    bits = "21:19"
    type = "rw"
    shortdesc = '''Delay P1P2P3 Delay P0 to P1/P2/P3 request when entering U1/U2/U3 until (DWC_USB3_GUSB3PIPECTL_INIT[21:19]*8) 8B10B error occurs, or Pipe3_RxValid drops to 0.'''
    longdesc = '''DWC_USB3_GUSB3PIPECTL_INIT[18] must be 1 to enable this functionality.'''
  [[register.field]]
    name = "DELAYP1TRANS"
    bits = "18"
    type = "rw"
    shortdesc = '''Delay PHY power change from P0 to P1/P2/P3 when link state changing from U0 to U1/U2/U3 respectively.'''
    longdesc = '''- 1'b1: When entering U1/U2/U3, delay the transition to P1/P2/P3 until the pipe3 signals, Pipe3_RxElecIlde is 1 and pipe3_RxValid is 0 - 1'b0: When entering U1/U2/U3, transition to P1/P2/P3 without checking for Pipe3_RxElecIlde and pipe3_RxValid. Note: This bit must be set to '1' for PHY. It is also used by third-party SS PHY.'''
  [[register.field]]
    name = "SUSPENDENABLE"
    bits = "17"
    type = "rw"
    shortdesc = '''Suspend USB3.'''
    longdesc = '''0 SS PHY (Suspend_en) When set, and if Suspend conditions are valid, the USB 3.0 PHY enters Suspend mode. For DRD/OTG configurations, it is recommended that this bit is set to '0' during coreConsultant configuration. If it is set to '1', then the application must clear this bit after power-on reset. Application needs to set it to '1' after the core initialization is completed. For all other configurations, this bit can be set to '1' during core configuration.'''
  [[register.field]]
    name = "DATWIDTH"
    bits = "16:15"
    type = "ro"
    shortdesc = '''PIPE Data Width (DatWidth) - 2'b00: 32 bits - 2'b01: 16 bits - 2'b10: 8 bits One clock after reset, these bits receive the value seen on the pipe3_DataBusWidth.'''
    longdesc = '''The simulation testbench uses the coreConsultant parameter to configure the VIP. These bits in the coreConsultant parameter must match your PHY data width and the pipe3_DataBusWidth port.'''
  [[register.field]]
    name = "ABORTRXDETINU2"
    bits = "14"
    type = "rw"
    shortdesc = '''Abort Rx Detect in U2 (AbortRxDetInU2) When set, and the link state is U2, then the core will abort receiver detection if it receives U2 exit LFPS from the remote link partner.'''
    longdesc = '''This bit is for the downstream port only. Note: This bit is used by third-party SS PHY. It must be set to '0' for PHY.'''
  [[register.field]]
    name = "SKIPRXDET"
    bits = "13"
    type = "rw"
    shortdesc = '''Skip Rx Detect: When set, the core skips Rx Detection if pipe3_RxElecIdle is low.'''
    longdesc = '''Skip is defined as waiting for the appropriate timeout, then repeating the operation.'''
  [[register.field]]
    name = "LFPSP0ALGN"
    bits = "12"
    type = "rw"
    shortdesc = '''LFPS P0 Align: When set, - The core deasserts LFPS transmission on the clock edge that it requests Phy power state 0 when exiting U1, U2, or U3 low power states.'''
    longdesc = '''Otherwise, LFPS transmission is asserted one clock earlier. - The core requests symbol transmission two pipe3_rx_pclks periods after the PHY asserts PhyStatus as a result of the PHY switching from P1 or P2 state to P0 state. Currently, this bit is only used in USB 3.0 HUB with PHY. For other USB 3.0 Host, Device, and DRD cores, this bit is not required.'''
  [[register.field]]
    name = "P3P2TRANOK"
    bits = "11"
    type = "rw"
    shortdesc = '''P3 P2 Transitions OK (P3P2TranOK) When set, the core transitions directly from Phy power state P2 to P3 or from state P3 to P2.'''
    longdesc = '''When not set, P0 is always entered as an intermediate state during transitions between P2 and P3, as defined in the PIPE3 Specification. According to the PIPE3 Specification, any direct transition between P3 and P2 is illegal. Note: This bit is used by third-party SS PHY. It must be set to '0' for PHY.'''
  [[register.field]]
    name = "P3EXSIGP2"
    bits = "10"
    type = "rw"
    shortdesc = '''P3 Exit Signal in P2 (P3ExSigP2) When this bit is set, the core always changes the PHY power state to P2, before attempting a U3 exit handshake.'''
    longdesc = '''This bit is used only for some non- PHYs that cannot do LFPS in P3. Note: This bit is used by third-party SS PHY. It must be set to '0' for PHY.'''
  [[register.field]]
    name = "LFPSFILTER"
    bits = "9"
    type = "rw"
  [[register.field]]
    name = "RX_DETECT_TO_POLLING_LFPS_CONTROL"
    bits = "8"
    type = "rw"
    shortdesc = '''RX_DETECT to Polling.'''
    longdesc = '''LFPS Control - 1'b0 (Default): Enables a 400us delay to start Polling LFPS after RX_DETECT. This allows VCM offset to settle to a proper level. - 1'b1: Disables the 400us delay to start Polling LFPS after RX_DETECT. During controller certification with third party PHY it is observed that the PHY is not able to meet the Tx AC common mode voltage active (VTX-CM-ACPP_ACTIVE <100mv) if the link starts polling within 80us from the time rx.detect is performed. To meet this VTX-CM-ACPP_ACTIVE specification, the polling must be delayed further. If the PHY does not have issue then they can set this bit to 1 which allows polling to start within 80us.'''
  [[register.field]]
    name = "SSICEN"
    bits = "7"
    type = "rw"
    shortdesc = '''USB3 SSIC Enable (SSICEn) This bit is valid only when coreConsultant parameter DWC_USB3_EN_SSIC=1 else this bit needs to be set to 1'b0.'''
    longdesc = '''- 1'b0: Pipe interface is active. The RMMI interface on the corresponding port is reset by the core. - 1'b1: RMMI interface on the corresponding port connected to M-PHY is active, and pipe interface is inactive. This bit needs to be set before accessing the corresponding GUSB3RMMICTLn register. Note: When the DWC_USB3_NUM_SSIC_PORTS parameter is set to zero, the access type of this register bit is R_W, but the register bit is not functional.'''
  [[register.field]]
    name = "TX_SWING"
    bits = "6"
    type = "rw"
  [[register.field]]
    name = "TX_MARGIN"
    bits = "5:3"
    type = "rw"
  [[register.field]]
    name = "TX_DE_EPPHASIS"
    bits = "2:1"
    type = "rw"
    shortdesc = '''Tx Deemphasis (TxDeemphasis) The value driven to the PHY is controlled by the LTSSM during USB3 Compliance mode.'''
    longdesc = '''(Refer to Table 5-3 of the PIPE3 specification.)'''
  [[register.field]]
    name = "ELASTIC_BUFFER_MODE"
    bits = "0"
    type = "rw"
    shortdesc = '''Elastic Buffer Mode (ElasticBufferMode) This bit should be set during boot time and not changed afterwards (Refer to Table 5-3 of the PIPE3 specification.'''
    longdesc = ''')'''
[[register]]
  name = "GTXFIFOSIZ0"
  type = "rw"
  width = 32
  description = "Global Transmit FIFO Size Register This register specifies the RAM start address and depth (both in MDWIDTH-bit words) for each implemented TxFIFO. The number of TxFIFOs depends on the configuration parameters including the number of Device IN Endpoints, number of Host Bus Instances, and presence of Debug Capability. The register default values for each mode are assigned in coreConsultant based on the maximum packet size, number of packets to be buffered, speed of host bus instance, bus latency, and mode of operation (host, device, or, DBC). Upon reset and mode transitions, hardware automatically programs these registers to the default values. Consequently, there is typically no need for the software to modify the pre-defined default values. For the debug capability mode, the currently mapped EP0 IN and EP1 IN TxFIFO numbers can be read from the GFIFOPRIDBC register. For OTG mode of operation, when the core is transitioning to host mode, program GTXFIFOSIZ register to the correct value only after OCTL.PeriMode is programmed to 1'b0. For more details on the usage of the GTXFIFOSIZn and GRXFIFOSIZn registers for different modes of operation, refer to 'Architecture Details' chapter in the Databook."
  default = "0x00000042"
  offset = "0x0000C300"
  [[register.field]]
    name = "TXFSTADDR_N"
    bits = "31:16"
    type = "rw"
  [[register.field]]
    name = "TXFDEP_N"
    bits = "15:0"
    type = "rw"
    shortdesc = '''TxFIFO Depth This field contains the depth of TxFIFOn in MDWIDTH-bit words.'''
    longdesc = '''- Minimum value: 32 - Maximum value: 32,768 For more information, see 'Integrating the Core' chapter in the DWC SuperSpeed USB 3.0 Controller User Guide.'''
[[register]]
  name = "GTXFIFOSIZ1"
  type = "rw"
  width = 32
  description = "Register GTXFIFOSIZ 1"
  default = "0x00420184"
  offset = "0x0000C304"
  [[register.field]]
    name = "TXFSTADDR_N"
    bits = "31:16"
    type = "rw"
  [[register.field]]
    name = "TXFDEP_N"
    bits = "15:0"
    type = "rw"
[[register]]
  name = "GTXFIFOSIZ2"
  type = "rw"
  width = 32
  description = "Transmit FIFOn RAM Start Address This field contains the memory start address for TxFIFOn in MDWIDTH-bit words."
  default = "0x01C60184"
  offset = "0x0000C308"
  [[register.field]]
    name = "TXFSTADDR_N"
    bits = "31:16"
    type = "rw"
  [[register.field]]
    name = "TXFDEP_N"
    bits = "15:0"
    type = "rw"
    shortdesc = '''TxFIFO Depth This field contains the depth of TxFIFOn in MDWIDTH-bit words.'''
    longdesc = '''- Minimum value: 32 - Maximum value: 32,768 For more information, see 'Integrating the Core' chapter in the DWC SuperSpeed USB 3.0 Controller User Guide.'''
[[register]]
  name = "GTXFIFOSIZ3"
  type = "rw"
  width = 32
  description = "Register GTXFIFOSIZ 3"
  default = "0x034A0184"
  offset = "0x0000C30C"
  [[register.field]]
    name = "TXFSTADDR_N"
    bits = "31:16"
    type = "rw"
  [[register.field]]
    name = "TXFDEP_N"
    bits = "15:0"
    type = "rw"
    shortdesc = '''TXFDEP_N: TxFIFO Depth (TxFDep_n) This field contains the depth of TxFIFOn in MDWIDTH-bit words.'''
    longdesc = '''- Minimum value: 32 - Maximum value: 32,768 For more information, see 'Integrating the Core' chapter in the DWC SuperSpeed USB 3.0 Controller User Guide.'''
[[register]]
  name = "GTXFIFOSIZ4"
  type = "rw"
  width = 32
  description = "Register GTXFIFOSIZ 4"
  default = "0x04CE0184"
  offset = "0x0000C310"
  [[register.field]]
    name = "TXFSTADDR_N"
    bits = "31:16"
    type = "rw"
  [[register.field]]
    name = "TXFDEP_N"
    bits = "15:0"
    type = "rw"
    shortdesc = '''TXFDEP_N: TxFIFO Depth (TxFDep_n) This field contains the depth of TxFIFOn in MDWIDTH-bit words.'''
    longdesc = '''- Minimum value: 32 - Maximum value: 32,768 For more information, see 'Integrating the Core' chapter in the DWC SuperSpeed USB 3.0 Controller User Guide.'''
[[register]]
  name = "GTXFIFOSIZ5"
  type = "rw"
  width = 32
  description = "Register GTXFIFOSIZ 5"
  default = "0x06520184"
  offset = "0x0000C314"
  [[register.field]]
    name = "TXFSTADDR_N"
    bits = "31:16"
    type = "rw"
  [[register.field]]
    name = "TXFDEP_N"
    bits = "15:0"
    type = "rw"
    shortdesc = '''TxFIFO Depth This field contains the depth of TxFIFOn in MDWIDTH-bit words.'''
    longdesc = '''- Minimum value: 32 - Maximum value: 32,768 For more information, see 'Integrating the Core' chapter in the DWC SuperSpeed USB 3.0 Controller User Guide.'''
[[register]]
  name = "GRXFIFOSIZ0"
  type = "rw"
  width = 32
  description = "Global Receive FIFO Size Register This register specifies the RAM start address and depth (both in MDWIDTH-bit words) for each implemented RxFIFO. The number of RxFIFOs depends on the configuration parameters including the number of Host Bus Instances and presence of Debug Capability; device mode requires only one RxFIFO. The register default values for each mode are assigned in coreConsultant based on the maximum packet size, number of packets to be buffered, speed of the host bus instance, bus latency, and mode of operation (host, device, or DBC). Upon reset and mode transitions, hardware automatically programs these registers to the default values. Consequently, there is typically no need for the software to modify the pre-defined default values. For the debug capability mode, the currently mapped RxFIFO number can be read from the GFIFOPRIDBC register. For more details on the usage of the GTXFIFOSIZn and GRXFIFOSIZn registers for different modes of operation, refer to 'Architecture Details' chapter in the Databook."
  default = "0x00000185"
  offset = "0x0000C380"
  [[register.field]]
    name = "RXFSTADDR_N"
    bits = "31:16"
    type = "rw"
  [[register.field]]
    name = "RXFDEP_N"
    bits = "15:0"
    type = "rw"
    shortdesc = '''RxFIFO Depth (RxFDep_n) This field contains the depth of RxFIFOn in MDWIDTH-bit words.'''
    longdesc = '''- Minimum value: 32 - Maximum value: 16,384'''
[[register]]
  name = "GRXFIFOSIZ1"
  type = "rw"
  width = 32
  description = "Register"
  default = "0x01850000"
  offset = "0x0000C384"
  [[register.field]]
    name = "RXFSTADDR_N"
    bits = "31:16"
    type = "rw"
  [[register.field]]
    name = "RXFDEP_N"
    bits = "15:0"
    type = "rw"
    shortdesc = '''RxFIFO Depth This field contains the depth of RxFIFOn in MDWIDTH-bit words.'''
    longdesc = '''- Minimum value: 32 - Maximum value: 16,384'''
[[register]]
  name = "GRXFIFOSIZ2"
  type = "rw"
  width = 32
  description = "Register"
  default = "0x01850000"
  offset = "0x0000C388"
  [[register.field]]
    name = "RXFSTADDR_N"
    bits = "31:16"
    type = "rw"
  [[register.field]]
    name = "RXFDEP_N"
    bits = "15:0"
    type = "rw"
    shortdesc = '''RxFIFO Depth This field contains the depth of RxFIFOn in MDWIDTH-bit words.'''
    longdesc = '''- Minimum value: 32 - Maximum value: 16,384'''
[[register]]
  name = "GEVNTADRLO_0"
  type = "rw"
  width = 32
  description = "Global Event Buffer Address (Low) Register This is an alternate register for the GEVNTADRn register. Instance 0 of an array of 4."
  default = "0x00000000"
  offset = "0x0000C400"
  [[register.field]]
    name = "EVNTADRLO"
    bits = "31:0"
    type = "rw"
    shortdesc = '''Event Buffer Address (EvntAdrLo) Holds the lower 32 bits of start address of the external memory for the Event Buffer.'''
    longdesc = '''During operation, hardware does not update this address.'''
[[register]]
  name = "GEVNTADRHI_0"
  type = "rw"
  width = 32
  description = "Global Event Buffer Address (High) Register This is an alternate register for the GEVNTADRn register. Instance 0 of an array of 4."
  default = "0x00000000"
  offset = "0x0000C404"
  [[register.field]]
    name = "EVNTADRHI"
    bits = "31:0"
    type = "rw"
    shortdesc = '''Event Buffer Address (EvntAdrHi) Holds the higher 32 bits of start address of the external memory for the Event Buffer.'''
    longdesc = '''During operation, hardware does not update this address.'''
[[register]]
  name = "GEVNTSIZ_0"
  type = "mixed"
  width = 32
  description = "Global Event Buffer Size Register This register holds the Event Buffer Size and the Event Interrupt Mask bit. During power-on initialization, software must initialize the size with the number of bytes allocated for the Event Buffer. The Event Interrupt Mask will mask the interrupt, but events are still queued. After configuration, software must preserve the Event Buffer Size value when changing the Event Interrupt Mask. Instance 0 of an array of 4."
  default = "0x00000000"
  offset = "0x0000C408"
  [[register.field]]
    name = "EVNTINTRPTMASK"
    bits = "31"
    type = "rw"
    shortdesc = '''Event Interrupt Mask (EvntIntMask).'''
    longdesc = '''When set to '1', this prevents the interrupt from being generated. However, even when the mask is set, the events are queued.'''
  [[register.field]]
    name = "RESERVED"
    bits = "30:16"
    type = "ro"
  [[register.field]]
    name = "EVENTSIZ"
    bits = "15:0"
    type = "rw"
    shortdesc = '''Event Buffer Size in bytes (EVNTSiz) Holds the size of the Event Buffer in bytes; must be a multiple of four.'''
    longdesc = '''This is programmed by software once during initialization. The minimum size of the event buffer is 32 bytes.'''
[[register]]
  name = "GEVNTCOUNT_0"
  type = "mixed"
  width = 32
  description = "Global Event Buffer Count Register This register holds the number of valid bytes in the Event Buffer. During initialization, software must initialize the count by writing 0 to the Event Count field. Each time the hardware writes a new event to the Event Buffer, it increments this count. Most events are four bytes, but some events may span over multiple four byte entries. Whenever the count is greater than zero, the hardware raises the corresponding interrupt line (depending on the EvntIntMask bit in the GEVNTSIZn register). On an interrupt, software processes one or more events out of the Event Buffer. Afterwards, software must write the Event Count field with the number of bytes it processed. Clock crossing delays may result in the interrupt's continual assertion after software acknowledges the last event. Therefore, when the interrupt line is asserted, software must read the GEVNTCOUNT register and only process events if the GEVNTCOUNT is greater than 0. Instance 0 of an array of 4."
  default = "0x00000000"
  offset = "0x0000C40C"
  [[register.field]]
    name = "RESERVED"
    bits = "31:16"
    type = "ro"
  [[register.field]]
    name = "EVNTCOUNT"
    bits = "15:0"
    type = "rw"
    shortdesc = '''Event Count (EVNTCount) When read, returns the number of valid events in the Event Buffer (in bytes).'''
    longdesc = '''When written, hardware decrements the count by the value written. The interrupt line remains high when count is not 0.'''
[[register]]
  name = "GEVNTADRLO_1"
  type = "rw"
  width = 32
  description = "Global Event Buffer Address (Low) Register This is an alternate register for the GEVNTADRn register. Instance 1 of an array of 4."
  default = "0x00000000"
  offset = "0x0000C410"
  [[register.field]]
    name = "EVNTADRLO"
    bits = "31:0"
    type = "rw"
    shortdesc = '''Event Buffer Address (EvntAdrLo) Holds the lower 32 bits of start address of the external memory for the Event Buffer.'''
    longdesc = '''During operation, hardware does not update this address.'''
[[register]]
  name = "GEVNTADRHI_1"
  type = "rw"
  width = 32
  description = "Global Event Buffer Address (High) Register This is an alternate register for the GEVNTADRn register. Instance 1 of an array of 4."
  default = "0x00000000"
  offset = "0x0000C414"
  [[register.field]]
    name = "EVNTADRHI"
    bits = "31:0"
    type = "rw"
    shortdesc = '''Event Buffer Address (EvntAdrHi) Holds the higher 32 bits of start address of the external memory for the Event Buffer.'''
    longdesc = '''During operation, hardware does not update this address.'''
[[register]]
  name = "GEVNTSIZ_1"
  type = "mixed"
  width = 32
  description = "Global Event Buffer Size Register This register holds the Event Buffer Size and the Event Interrupt Mask bit. During power-on initialization, software must initialize the size with the number of bytes allocated for the Event Buffer. The Event Interrupt Mask will mask the interrupt, but events are still queued. After configuration, software must preserve the Event Buffer Size value when changing the Event Interrupt Mask. Instance 1 of an array of 4."
  default = "0x00000000"
  offset = "0x0000C418"
  [[register.field]]
    name = "EVNTINTRPTMASK"
    bits = "31"
    type = "rw"
    shortdesc = '''Event Interrupt Mask (EvntIntMask).'''
    longdesc = '''When set to '1', this prevents the interrupt from being generated. However, even when the mask is set, the events are queued.'''
  [[register.field]]
    name = "RESERVED"
    bits = "30:16"
    type = "ro"
  [[register.field]]
    name = "EVENTSIZ"
    bits = "15:0"
    type = "rw"
    shortdesc = '''Event Buffer Size in bytes (EVNTSiz) Holds the size of the Event Buffer in bytes; must be a multiple of four.'''
    longdesc = '''This is programmed by software once during initialization. The minimum size of the event buffer is 32 bytes.'''
[[register]]
  name = "GEVNTCOUNT_1"
  type = "mixed"
  width = 32
  description = "Global Event Buffer Count Register This register holds the number of valid bytes in the Event Buffer. During initialization, software must initialize the count by writing 0 to the Event Count field. Each time the hardware writes a new event to the Event Buffer, it increments this count. Most events are four bytes, but some events may span over multiple four byte entries. Whenever the count is greater than zero, the hardware raises the corresponding interrupt line (depending on the EvntIntMask bit in the GEVNTSIZn register). On an interrupt, software processes one or more events out of the Event Buffer. Afterwards, software must write the Event Count field with the number of bytes it processed. Clock crossing delays may result in the interrupt's continual assertion after software acknowledges the last event. Therefore, when the interrupt line is asserted, software must read the GEVNTCOUNT register and only process events if the GEVNTCOUNT is greater than 0. Instance 1 of an array of 4."
  default = "0x00000000"
  offset = "0x0000C41C"
  [[register.field]]
    name = "RESERVED"
    bits = "31:16"
    type = "ro"
  [[register.field]]
    name = "EVNTCOUNT"
    bits = "15:0"
    type = "rw"
    shortdesc = '''Event Count (EVNTCount) When read, returns the number of valid events in the Event Buffer (in bytes).'''
    longdesc = '''When written, hardware decrements the count by the value written. The interrupt line remains high when count is not 0.'''
[[register]]
  name = "GEVNTADRLO_2"
  type = "rw"
  width = 32
  description = "Global Event Buffer Address (Low) Register This is an alternate register for the GEVNTADRn register. Instance 2 of an array of 4."
  default = "0x00000000"
  offset = "0x0000C420"
  [[register.field]]
    name = "EVNTADRLO"
    bits = "31:0"
    type = "rw"
    shortdesc = '''Event Buffer Address (EvntAdrLo) Holds the lower 32 bits of start address of the external memory for the Event Buffer.'''
    longdesc = '''During operation, hardware does not update this address.'''
[[register]]
  name = "GEVNTADRHI_2"
  type = "rw"
  width = 32
  description = "Global Event Buffer Address (High) Register This is an alternate register for the GEVNTADRn register. Instance 2 of an array of 4."
  default = "0x00000000"
  offset = "0x0000C424"
  [[register.field]]
    name = "EVNTADRHI"
    bits = "31:0"
    type = "rw"
    shortdesc = '''Event Buffer Address (EvntAdrHi) Holds the higher 32 bits of start address of the external memory for the Event Buffer.'''
    longdesc = '''During operation, hardware does not update this address.'''
[[register]]
  name = "GEVNTSIZ_2"
  type = "mixed"
  width = 32
  description = "Global Event Buffer Size Register This register holds the Event Buffer Size and the Event Interrupt Mask bit. During power-on initialization, software must initialize the size with the number of bytes allocated for the Event Buffer. The Event Interrupt Mask will mask the interrupt, but events are still queued. After configuration, software must preserve the Event Buffer Size value when changing the Event Interrupt Mask. Instance 2 of an array of 4."
  default = "0x00000000"
  offset = "0x0000C428"
  [[register.field]]
    name = "EVNTINTRPTMASK"
    bits = "31"
    type = "rw"
    shortdesc = '''Event Interrupt Mask (EvntIntMask).'''
    longdesc = '''When set to '1', this prevents the interrupt from being generated. However, even when the mask is set, the events are queued.'''
  [[register.field]]
    name = "RESERVED"
    bits = "30:16"
    type = "ro"
  [[register.field]]
    name = "EVENTSIZ"
    bits = "15:0"
    type = "rw"
    shortdesc = '''Event Buffer Size in bytes (EVNTSiz) Holds the size of the Event Buffer in bytes; must be a multiple of four.'''
    longdesc = '''This is programmed by software once during initialization. The minimum size of the event buffer is 32 bytes.'''
[[register]]
  name = "GEVNTCOUNT_2"
  type = "mixed"
  width = 32
  description = "Global Event Buffer Count Register This register holds the number of valid bytes in the Event Buffer. During initialization, software must initialize the count by writing 0 to the Event Count field. Each time the hardware writes a new event to the Event Buffer, it increments this count. Most events are four bytes, but some events may span over multiple four byte entries. Whenever the count is greater than zero, the hardware raises the corresponding interrupt line (depending on the EvntIntMask bit in the GEVNTSIZn register). On an interrupt, software processes one or more events out of the Event Buffer. Afterwards, software must write the Event Count field with the number of bytes it processed. Clock crossing delays may result in the interrupt's continual assertion after software acknowledges the last event. Therefore, when the interrupt line is asserted, software must read the GEVNTCOUNT register and only process events if the GEVNTCOUNT is greater than 0. Instance 2 of an array of 4."
  default = "0x00000000"
  offset = "0x0000C42C"
  [[register.field]]
    name = "RESERVED"
    bits = "31:16"
    type = "ro"
  [[register.field]]
    name = "EVNTCOUNT"
    bits = "15:0"
    type = "rw"
    shortdesc = '''Event Count (EVNTCount) When read, returns the number of valid events in the Event Buffer (in bytes).'''
    longdesc = '''When written, hardware decrements the count by the value written. The interrupt line remains high when count is not 0.'''
[[register]]
  name = "GEVNTADRLO_3"
  type = "rw"
  width = 32
  description = "Global Event Buffer Address (Low) Register This is an alternate register for the GEVNTADRn register. Instance 3 of an array of 4."
  default = "0x00000000"
  offset = "0x0000C430"
  [[register.field]]
    name = "EVNTADRLO"
    bits = "31:0"
    type = "rw"
    shortdesc = '''Event Buffer Address (EvntAdrLo) Holds the lower 32 bits of start address of the external memory for the Event Buffer.'''
    longdesc = '''During operation, hardware does not update this address.'''
[[register]]
  name = "GEVNTADRHI_3"
  type = "rw"
  width = 32
  description = "Global Event Buffer Address (High) Register This is an alternate register for the GEVNTADRn register. Instance 3 of an array of 4."
  default = "0x00000000"
  offset = "0x0000C434"
  [[register.field]]
    name = "EVNTADRHI"
    bits = "31:0"
    type = "rw"
    shortdesc = '''Event Buffer Address (EvntAdrHi) Holds the higher 32 bits of start address of the external memory for the Event Buffer.'''
    longdesc = '''During operation, hardware does not update this address.'''
[[register]]
  name = "GEVNTSIZ_3"
  type = "mixed"
  width = 32
  description = "Global Event Buffer Size Register This register holds the Event Buffer Size and the Event Interrupt Mask bit. During power-on initialization, software must initialize the size with the number of bytes allocated for the Event Buffer. The Event Interrupt Mask will mask the interrupt, but events are still queued. After configuration, software must preserve the Event Buffer Size value when changing the Event Interrupt Mask. Instance 3 of an array of 4."
  default = "0x00000000"
  offset = "0x0000C438"
  [[register.field]]
    name = "EVNTINTRPTMASK"
    bits = "31"
    type = "rw"
    shortdesc = '''Event Interrupt Mask (EvntIntMask).'''
    longdesc = '''When set to '1', this prevents the interrupt from being generated. However, even when the mask is set, the events are queued.'''
  [[register.field]]
    name = "RESERVED"
    bits = "30:16"
    type = "ro"
  [[register.field]]
    name = "EVENTSIZ"
    bits = "15:0"
    type = "rw"
    shortdesc = '''Event Buffer Size in bytes (EVNTSiz) Holds the size of the Event Buffer in bytes; must be a multiple of four.'''
    longdesc = '''This is programmed by software once during initialization. The minimum size of the event buffer is 32 bytes.'''
[[register]]
  name = "GEVNTCOUNT_3"
  type = "mixed"
  width = 32
  description = "Global Event Buffer Count Register This register holds the number of valid bytes in the Event Buffer. During initialization, software must initialize the count by writing 0 to the Event Count field. Each time the hardware writes a new event to the Event Buffer, it increments this count. Most events are four bytes, but some events may span over multiple four byte entries. Whenever the count is greater than zero, the hardware raises the corresponding interrupt line (depending on the EvntIntMask bit in the GEVNTSIZn register). On an interrupt, software processes one or more events out of the Event Buffer. Afterwards, software must write the Event Count field with the number of bytes it processed. Clock crossing delays may result in the interrupt's continual assertion after software acknowledges the last event. Therefore, when the interrupt line is asserted, software must read the GEVNTCOUNT register and only process events if the GEVNTCOUNT is greater than 0. Instance 3 of an array of 4."
  default = "0x00000000"
  offset = "0x0000C43C"
  [[register.field]]
    name = "RESERVED"
    bits = "31:16"
    type = "ro"
  [[register.field]]
    name = "EVNTCOUNT"
    bits = "15:0"
    type = "rw"
    shortdesc = '''Event Count (EVNTCount) When read, returns the number of valid events in the Event Buffer (in bytes).'''
    longdesc = '''When written, hardware decrements the count by the value written. The interrupt line remains high when count is not 0.'''
[[register]]
  name = "GHWPARAMS8"
  type = "ro"
  width = 32
  description = "Global Hardware Parameters Register 8 This register contains the hardware configuration options that you can select in the coreConsultant GUI. For a description of each parameter, refer to Parameters chapter in the Databook. This information is also available in coreConsultant by right-clicking the parameter label and selecting 'What's This' or by clicking the Help tab. Note: Some of the global hardware parameters are not currently modifiable in coreConsultant. These settings are in the <workspace>/src/DWC_usb3_params.v file; you must not change them."
  default = "0x000007BA"
  offset = "0x0000C600"
  [[register.field]]
    name = "GHWPARAMS8_32_0"
    bits = "31:0"
    type = "ro"
[[register]]
  name = "GTXFIFOPRIDEV"
  type = "mixed"
  width = 32
  description = "Global Device TX FIFO DMA Priority Register This register specifies the relative DMA priority level among the Device TXFIFOs (one per IN endpoint). Each register bit[n] controls the priority (1: high, 0: low) of each TXFIFO[n]. When multiple TXFIFOs compete for DMA service at a given time (that is, multiple TXQs contain TX DMA requests and their corresponding TXFIFOs have space available), the TX DMA arbiter grants access on a packet-basis in the following manner: - 1. High-priority TXFIFOs are granted access using round-robin arbitration - 2. Low-priority TXFIFOs are granted access using round-robin arbitration only after the high-priority TXFIFOs have no further processing to do (that is, either the TXQs are empty or the corresponding TXFIFOs are full). For scatter-gather packets, the arbiter grants successive DMA requests to the same FIFO until the entire packet is completed. When configuring periodic IN endpoints, software must set register bit[n]=1, where n is the TXFIFO assignment. This ensures that the DMA for isochronous or interrupt IN endpoints are prioritized over bulk or control IN endpoints. This register is present only when the core is configured to operate in the device mode (includes DRD and OTG modes). The register size corresponds to the number of Device IN endpoints. Note - Since the device mode uses only one RXFIFO, there is no Device RXFIFO DMA Priority Register."
  default = "0x00000000"
  offset = "0x0000C610"
  [[register.field]]
    name = "RESERVED"
    bits = "31:6"
    type = "ro"
  [[register.field]]
    name = "GTXFIFOPRIDEV"
    bits = "5:0"
    type = "rw"
[[register]]
  name = "GTXFIFOPRIHST"
  type = "mixed"
  width = 32
  description = "Global Host TX FIFO DMA Priority Register This register specifies the relative DMA priority level among the Host TXFIFOs (one per USB bus instance) within the associated speed group (SS or HS/FSLS). Each register bit[n] controls the priority (1: high, 0: low) of TXFIFO[n] within a speed group. When multiple TXFIFOs compete for DMA service at a given time (i.e., multiple TXQs contain TX DMA requests and their corresponding TXFIFOs have space available), the TX DMA arbiter grants access on a packet-basis in the following manner: - 1. Among the FIFOs in the same speed group (SS or HS/FSLS): a. High-priority TXFIFOs are granted access using round-robin arbitration b. Low-priority TXFIFOs are granted access using round-robin arbitration only after the high-priority TXFIFOs have no further processing to do (that is, either the TXQs are empty or the corresponding TXFIFOs are full). - 2. The TX DMA arbiter prioritizes the SS speed group or HS/FSLS speed group according to the ratio programmed in the GDMAHLRATIO register. For scatter-gather packets, the arbiter grants successive DMA requests to the same FIFO until the entire packet is completed. This register is present only when the core is configured to operate in the host mode (includes DRD and OTG modes). The register size corresponds to the number of configured USB bus instances; for example, in the default configuration, there are 3 USB bus instances (1 SS, 1 HS, and 1 FSLS)."
  default = "0x00000000"
  offset = "0x0000C618"
  [[register.field]]
    name = "RESERVED"
    bits = "31:4"
    type = "ro"
  [[register.field]]
    name = "GTXFIFOPRIHST"
    bits = "3:0"
    type = "rw"
[[register]]
  name = "GRXFIFOPRIHST"
  type = "mixed"
  width = 32
  description = "Global Host RX FIFO DMA Priority Register This register specifies the relative DMA priority level among the Host RXFIFOs (one per USB bus instance) within the associated speed group (SS or HS/FSLS). Each register bit[n] controls the priority (1: high, 0: low) of RXFIFO[n] within a speed group. When multiple RXFIFOs compete for DMA service at a given time (i.e., multiple RXQs contain RX DMA requests and their corresponding RXFIFOs have data available), the RX DMA arbiter grants access on a packet-basis in the following manner: - 1. Among the FIFOs in the same speed group (SS or HS/FSLS): a. High-priority RXFIFOs are granted access using round-robin arbitration b. Low-priority RXFIFOs are granted access using round-robin arbitration only after high-priority RXFIFOs have no further processing to do (that is, either the RXQs are empty or the corresponding RXFIFOs do not have the required data). - 2. The RX DMA arbiter prioritizes the SS speed group or HS/FSLS speed group according to the ratio programmed in the GDMAHLRATIO register. For scatter-gather packets, the arbiter grants successive DMA requests to the same FIFO until the entire packet is completed. This register is present only when the core is configured to operate in the host mode (includes DRD and OTG modes). The register size corresponds to the number of configured USB bus instances; for example, in the default configuration, there are 3 USB bus instances (1 SS, 1 HS, and 1 FSLS)."
  default = "0x00000000"
  offset = "0x0000C61C"
  [[register.field]]
    name = "RESERVED"
    bits = "31:3"
    type = "ro"
  [[register.field]]
    name = "GRXFIFOPRIHST"
    bits = "2:0"
    type = "rw"
[[register]]
  name = "GFIFOPRIDBC"
  type = "mixed"
  width = 32
  description = "Global Host Debug Capability DMA Priority Register This register specifies the relative priority of the RXFIFOs and TXFIFOs associated with the DbC mode. It overrides the priority assigned in the corresponding indexes of the Host RXFIFO and TXFIFO DMA priority registers, when the DbC mode is enabled. Priority settings are specified in relation to the low-priority SS speed group: - 1. Normal priority indicates that the DbC FIFOs are considered identical to the Host SS low-priority FIFOs. - 2. Low priority indicates that the DbC FIFOs are considered to have lower priority than all Host SS FIFOs. - 3. High priority indicates that the DbC FIFOs are considered higher priority than the Host SS low-priority FIFOs but lower priority than the Host SS high-priority FIFOs. This register is present only when the core is configured to operate in Host Debug Capability (DbC) mode."
  default = "0x00000000"
  offset = "0x0000C620"
  [[register.field]]
    name = "RESERVED"
    bits = "31:2"
    type = "ro"
  [[register.field]]
    name = "GFIFOPRIDBC"
    bits = "1:0"
    type = "rw"
[[register]]
  name = "GDMAHLRATIO"
  type = "mixed"
  width = 32
  description = "Global Host FIFO DMA High-Low Priority Ratio Register This register specifies the relative priority of the SS FIFOs with respect to the HS/FSLS FIFOs. The DMA arbiter prioritizes the HS/FSLS round-robin arbiter group every DMA High-Low Priority Ratio grants as indicated in the register separately for TX and RX. To illustrate, consider that all FIFOs are requesting access simultaneously, and the ratio is 4. SS gets priority for 4 packets, HS/FSLS gets priority for 1 packet, SS gets priority for 4 packets, HS/FSLS gets priority for 1 packet, and so on. If FIFOs from both speed groups are not requesting access simultaneously then, - if SS got grants 4 out of the last 4 times, then HS/FSLS get the priority on any future request. - if HS/FSLS got the grant last time, SS gets the priority on the next request. - if there is a valid request on either SS or HS/FSLS, a grant is always awarded; there is no idle. This register is present if the core is configured to operate in host mode (includes DRD and OTG)."
  default = "0x00000000"
  offset = "0x0000C624"
  [[register.field]]
    name = "RESERVED"
    bits = "31:13"
    type = "ro"
  [[register.field]]
    name = "HSTRXFIFO"
    bits = "12:8"
    type = "rw"
  [[register.field]]
    name = "RESERVED"
    bits = "7:5"
    type = "ro"
  [[register.field]]
    name = "HSTTXFIFO"
    bits = "4:0"
    type = "rw"
[[register]]
  name = "GFLADJ"
  type = "mixed"
  width = 32
  description = "Global Frame Length Adjustment Register This register provides options for the software to control the core behavior with respect to SOF (Start of Frame) and ITP (Isochronous Timestamp Packet) timers and frame timer functionality. It provides an option to override the fladj_30mhz_reg sideband signal. In addition, it enables running SOF or ITP frame timer counters completely from the ref_clk. This facilitates hardware LPM in host mode with the SOF or ITP counters being run from the ref_clk signal."
  default = "0x00000000"
  offset = "0x0000C630"
  [[register.field]]
    name = "GFLADJ_REFCLK_240MHZDECR_PLS1"
    bits = "31"
    type = "rw"
    shortdesc = '''GFLADJ_REFCLK_240MHZDECR_PLS1 This field indicates that the decrement value that the controller applies for each ref_clk must be GFLADJ_REFCLK_240MHZ_DECR and GFLADJ_REFCLK_240MHZ_DECR +1 alternatively on each ref_clk.'''
    longdesc = '''Set this bit to a '1' only if GFLADJ_REFCLK_LPM_SEL is set to '1' and the fractional component of 240/ref_frequency is greater than or equal to 0.5. Examples: If the ref_clk is 19.2 MHz then - GUCTL.REF_CLK_PERIOD = 52 - GFLADJ.GFLADJ_REFCLK_240MHZ_DECR = (240/19.2) = 12.5 - GFLADJ.GFLADJ_REFCLK_240MHZDECR_PLS1 = 1 If the ref_clk is 24 MHz then - GUCTL.REF_CLK_PERIOD = 41 - GFLADJ.GFLADJ_REFCLK_240MHZ_DECR = (240/24) = 10 - GFLADJ.GFLADJ_REFCLK_240MHZDECR_PLS1 = 0'''
  [[register.field]]
    name = "GFLADJ_REFCLK_240MHZ_DECR"
    bits = "30:24"
    type = "rw"
    shortdesc = '''This field indicates the decrement value that the controller applies for each ref_clk in order to derive a frame timer in terms of a 240-MHz clock.'''
    longdesc = '''This field must be programmed to a non-zero value only if GFLADJ_REFCLK_LPM_SEL is set to '1'. The value is derived as follows: GFLADJ_REFCLK_240MHZ_DECR = 240/ref_clk_frequency Examples: If the ref_clk is 24 MHz then - GUCTL.REF_CLK_PERIOD = 41 - GFLADJ.GFLADJ_REFCLK_240MHZ_DECR = 240/24 = 10 If the ref_clk is 48 MHz then - GUCTL.REF_CLK_PERIOD = 20 - GFLADJ.GFLADJ_REFCLK_240MHZ_DECR = 240/48 = 5 If the ref_clk is 17 MHz then - GUCTL.REF_CLK_PERIOD = 58 - GFLADJ.GFLADJ_REFCLK_240MHZ_DECR = 240/17 = 14'''
  [[register.field]]
    name = "GFLADJ_REFCLK_LPM_SEL"
    bits = "23"
    type = "rw"
    shortdesc = '''This bit enables the functionality of running SOF/ITP counters on the ref_clk.'''
    longdesc = '''This bit must not be set to '1' if GCTL.SOFITPSYNC bit is set to '1'. Similarly, if GFLADJ_REFCLK_LPM_SEL set to '1', GCTL.SOFITPSYNC must not be set to '1'. When GFLADJ_REFCLK_LPM_SEL is set to '1' the overloading of the suspend control of the USB 2.0 first port PHY (UTMI/ULPI) with USB 3.0 port states is removed. For example, for PHY, the COMMONONN signal can be tied to '1'. Note that the ref_clk frequencies supported in this mode are 16/17/19.2/20/24/39.7/40 MHz. The utmi_clk[0] signal of the core must be connected to the FREECLK of the PHY. Note: If you set this bit to '1', the GUSB2PHYCFG.U2_FREECLK_EXISTS bit must be set to '0'.'''
  [[register.field]]
    name = "RESERVED"
    bits = "22"
    type = "ro"
  [[register.field]]
    name = "GFLADJ_REFCLK_FLADJ"
    bits = "21:8"
    type = "rw"
    shortdesc = '''This field indicates the frame length adjustment to be applied when SOF/ITP counter is running on the ref_clk.'''
    longdesc = '''This register value is used to adjust the ITP interval when GCTL[SOFITPSYNC] is set to '1'; SOF and ITP interval when GLADJ.GFLADJ_REFCLK_LPM_SEL is set to '1'. This field must be programmed to a non-zero value only if GFLADJ_REFCLK_LPM_SEL is set to '1' or GCTL.SOFITPSYNC is set to '1'. The value is derived as follows: FLADJ_REF_CLK_FLADJ=((125000/ref_clk_period_integer)-(125000/ref_clk_period)) * ref_clk_period where - the ref_clk_period_integer is the integer value of the ref_clk period got by truncating the decimal (fractional) value that is programmed in the GUCTL.REF_CLK_PERIOD field. - the ref_clk_period is the ref_clk period including the fractional value. Examples: If the ref_clk is 24 MHz then - GUCTL.REF_CLK_PERIOD = 41 - GFLADJ.GLADJ_REFCLK_FLADJ = ((125000/41)-(125000/41.6666))*41.6666 = 2032 (ignoring the fractional value) If the ref_clk is 48 MHz then - GUCTL.REF_CLK_PERIOD = 20 - GFLADJ.GLADJ_REFCLK_FLADJ = ((125000/20)-(125000/20.8333))*20.8333 = 5208 (ignoring the fractional value)'''
  [[register.field]]
    name = "GFLADJ_30MHZ_SDBND_SEL"
    bits = "7"
    type = "rw"
    shortdesc = '''GFLADJ_30MHZ_SDBND_SEL This field selects whether to use the input signal fladj_30mhz_reg or the GFLADJ.'''
    longdesc = '''GFLADJ_30MHZ to adjust the frame length for the SOF/ITP. When this bit is set to, - 1, the controller uses the register field GFLADJ.GFLADJ_30MHZ value - 0, the controller uses the input signal fladj_30mhz_reg value'''
  [[register.field]]
    name = "RESERVED"
    bits = "6"
    type = "ro"
  [[register.field]]
    name = "GFLADJ_30MHZ"
    bits = "5:0"
    type = "rw"
    shortdesc = '''GFLADJ_30MHZ This field indicates the value that is used for frame length adjustment instead of considering from the sideband input signal fladj_30mhz_reg.'''
    longdesc = '''This enables post-silicon frame length adjustment in case the input signal fladj_30mhz_reg is connected to a wrong value or is not valid. For details on how to set this value, refer to section 5.2.4, 'Frame Length Adjustment Register (FLADJ),' of the xHCI Specification.'''
[[register]]
  name = "DCFG"
  type = "mixed"
  width = 32
  description = "Device Configuration Register. This register configures the core in Device mode after power-on or after certain control commands or enumeration. Do not make changes to this register after initial programming."
  default = "0x00000800"
  offset = "0x0000C700"
  [[register.field]]
    name = "RESERVED"
    bits = "31:25"
    type = "ro"
  [[register.field]]
    name = "RESERVED"
    bits = "24"
    type = "ro"
  [[register.field]]
    name = "IGNSTRMPP"
    bits = "23"
    type = "rw"
    shortdesc = '''IgnoreStreamPP This bit only affects stream-capable bulk endpoints.'''
    longdesc = '''When this bit is set to '0' and the controller receives a Data Packet with the Packet Pending (PP) bit set to 0 for OUT endpoints, or it receives an ACK with the NumP field set to 0 and PP set to 0 for IN endpoints, the core attempts to search for another stream (CStream) to initiate to the host. However, there are two situations where this behavior is not optimal: - When the host is setting PP=0 even though it has not finished the stream, or - When the endpoint on the device is configured with one transfer resource and therefore does not have any other streams to initiate to the host. When this bit is set to '1', the core ignores the Packet Pending bit for the purposes of stream selection and does not search for another stream when it receives DP(PP=0) or ACK(NumP=0, PP=0). This can enhance the performance when the device system bus bandwidth is low or the host responds to the core's ERDY transmission very quickly.'''
  [[register.field]]
    name = "LPMCAP"
    bits = "22"
    type = "rw"
    shortdesc = '''LPM Capable The application uses this bit to control the DWC_usb3 core LPM capabilities.'''
    longdesc = '''If the core operates as a non-LPM-capable device, it cannot respond to LPM transactions. - 1'b0: LPM capability is not enabled. - 1'b1: LPM capability is enabled.'''
  [[register.field]]
    name = "NUMP"
    bits = "21:17"
    type = "rw"
    shortdesc = '''Number of Receive Buffers.'''
    longdesc = '''This bit indicates the number of receive buffers to be reported in the ACK TP. The DWC_usb3 controller uses this field if GRXTHRCFG.USBRxPktCntSel is set to '0'. The application can program this value based on RxFIFO size, buffer sizes programmed in descriptors, and system latency. For an OUT endpoint, this field controls the number of receive buffers reported in the NumP field of the ACK TP transmitted by the core. Note: This bit is used in host mode when Debug Capability is enabled.'''
  [[register.field]]
    name = "INTRNUM"
    bits = "16:12"
    type = "rw"
  [[register.field]]
    name = "RESERVED"
    bits = "11:10"
    type = "ro"
  [[register.field]]
    name = "DEVADDR"
    bits = "9:3"
    type = "rw"
    shortdesc = '''Device Address.'''
    longdesc = '''The application must perform the following: - Program this field after every SetAddress request. - Reset this field to zero after USB reset.'''
  [[register.field]]
    name = "DEVSPD"
    bits = "2:0"
    type = "rw"
    shortdesc = '''Device Speed.'''
    longdesc = '''Indicates the speed at which the application requires the core to connect, or the maximum speed the application can support. However, the actual bus speed is determined only after the chirp sequence is completed, and is based on the speed of the USB host to which the core is connected. - 3'b100: SuperSpeed (USB 3.0 PHY clock is 125 MHz or 250 MHz) - 3'b000: High-speed (USB 2.0 PHY clock is 30 MHz or 60 MHz) - 3'b001: Full-speed (USB 2.0 PHY clock is 30 MHz or 60 MHz)'''
[[register]]
  name = "DCTL"
  type = "mixed"
  width = 32
  description = "Device Control Register Note: When Hibernation is not enabled using GCTL.GblHibernationEn field, - you can write any value to CSS, CRS, L1HibernationEn, and KeepConnect fields - L1HibernationEn, and KeepConnect fields always return 0 when read in this hibernation-disabled state"
  default = "0x00000000"
  offset = "0x0000C704"
  [[register.field]]
    name = "RUN_STOP"
    bits = "31"
    type = "rw"
    shortdesc = '''Run/Stop The software writes 1 to this bit to start the device controller operation.'''
    longdesc = '''To stop the device controller operation, the software must remove any active transfers and write 0 to this bit. When the controller is stopped, it sets the DSTS.DevCtrlHlt bit when the core is idle and the lower layer finishes the disconnect process. The Run/Stop bit must be used in following cases as specified: - After power-on reset and CSR initialization, the software must write 1 to this bit to start the device controller. The controller does not signal connect to the host until this bit is set. - The software uses this bit to control the device controller to perform a soft disconnect. When the software writes 0 to this bit, the host does not see that the device is connected. The device controller stays in the disconnected state until the software writes 1 to this bit. The minimum duration of keeping this bit cleared is specified in the Note below. If the software attempts a connect after the soft disconnect or detects a disconnect event, it must set DCTL[8:5] to 5 before reasserting the Run/Stop bit. - When the USB or Link is in a lower power state and the Two Power Rails configuration is selected, software writes 0 to this bit to indicate that it is going to turn off the Core Power Rail. After the software turns on the Core Power Rail again and re-initializes the device controller, it must set this bit to start the device controller. For more details, see 'Low Power Operation' section of the Databook. Note: The following is the minimum duration under various conditions for which the soft disconnect (SftDiscon) bit must be set for the USB host to detect a device disconnect: 30ms: - For SuperSpeed, when the device state is Suspended, Idle, Transmit, or Receive. 10ms: - For high-speed, when the device state is Suspended, Idle, or not Idle/Suspended (performing transactions) - For full-speed/low-speed, when the device state is Suspended, Idle, or not Idle/Supended (performing transactions) To accommodate clock jitter, it is recommended that the application add extra delay to the specified minimum duration.'''
  [[register.field]]
    name = "CSFTRST"
    bits = "30"
    type = "rw"
    shortdesc = '''Core Soft Reset Resets the all clock domains as follows: - This bit clears the interrupts and all the CSRs except GSTS, GSNPSID, GGPIO, GUID, GUSB2PHYCFGn registers, GUSB3PIPECTLn registers, DCFG, DCTL, DEVTEN, and DSTS registers.'''
    longdesc = '''- All module state machines (except the SoC Bus Slave Unit) are reset to the IDLE state, and all the TxFIFOs and the RxFIFO are flushed. - Any transactions on the SoC bus Master are terminated as soon as possible, after gracefully completing the last data phase of a SoC bus transfer. Any transactions on the USB are terminated immediately. The application can write this bit at any time to reset the core. This is a self-clearing bit; the core clears this bit after all necessary logic is reset in the core, which may take several clocks depending on the core's current state. Once this bit is cleared, the software must wait at least 3 PHY clocks before accessing the PHY domain (synchronization delay). Typically, software reset is used during software development and also when you dynamically change the PHY selection bits in the USB configuration registers listed above. When you change the PHY, the corresponding clock for the PHY is selected and used in the PHY domain. Once a new clock is selected, the PHY domain must be reset for proper operation. Note: Programming this field with random data causes side effect. Bit Bash register testing is not recommended.'''
  [[register.field]]
    name = "RESERVED"
    bits = "29"
    type = "ro"
  [[register.field]]
    name = "HIRDTHRES"
    bits = "28:24"
    type = "rw"
    shortdesc = '''HIRD Threshold (HIRD_Thres) The core asserts output signals utmi_l1_suspend_n and utmi_sleep_n (see 'LPM Interface Signals' table in the Databook) on the basis of this signal: The core asserts utmi_l1_suspend_n to put the PHY into Deep Low-Power mode in L1 when both of the following are true: - HIRD value is greater than or equal to the value in DCTL.'''
    longdesc = '''HIRD_Thres[3:0] - HIRD_Thres[4] is set to 1'b1. The core asserts utmi_sleep_n on L1 when one of the following is true: - If the HIRD value is less than HIRD_Thres[3:0] or - HIRD_Thres[4] is set to 1'b0. Note: This field must be set to '0' during SuperSpeed mode of operation.'''
  [[register.field]]
    name = "LPM_NYET_THRES"
    bits = "23:20"
    type = "rw"
    shortdesc = '''LPM NYET Threshold When LPM Errata is enabled: Bits [23:20]: LPM NYET Response Threshold (LPM_NYET_thres) Handshake response to LPM token specified by device application.'''
    longdesc = '''Response depends on DCFG.LPMCap. - DCFG.LPMCap is 1'b0 - The core always responds with Timeout (that is, no response). - DCFG.LPMCap is 1'b1 - The core responds with an ACK on successful LPM transaction, which requires that all of the following are satisfied: - There are no PID or CRC5 errors in both the EXT token and the LPM token (if not true, inactivity results in a timeout ERROR). - No data is pending in the Transmit FIFO and OUT endpoints not in flow controlled state (else NYET). - The BESL value in the LPM token is less than or equal to LPM_NYET_thres[3:0]'''
  [[register.field]]
    name = "KEEPCONNECT"
    bits = "19"
    type = "rw"
    shortdesc = '''When '1', this bit enables the save and restore programming model by preventing the core from disconnecting from the host when DCTL.'''
    longdesc = '''RunStop is set to '0'. It also enables the Hibernation Request Event to be generated when the link goes to U3 or L2. The device core disconnects from the host when DCTL.RunStop is set to '0'. This bit indicates whether to preserve this behavior ('0'), or if the core must not disconnect when RunStop is set to 0 ('1'). This bit also prevents the LTSSM from automatically going to U0/L0 when the host requests resume from U3/L2.'''
  [[register.field]]
    name = "L1HIBERNATIONEN"
    bits = "18"
    type = "rw"
    shortdesc = '''When this bit is set along with KeepConnect, the device core generates a Hibernation Request Event if L1 is enabled and the HIRD value in the LPM token is larger than the threshold programmed in DCTL.'''
    longdesc = '''HIRD_Thres. The core does not exit the LPM L1 state until software writes Recovery into the DCTL.ULStChngReq field. This prevents corner cases where the device is entering hibernation at the same time the host is attempting to exit L1.'''
  [[register.field]]
    name = "CRS"
    bits = "17"
    type = "rw"
    shortdesc = '''Controller Restore State (CRS) This command is similar to the USBCMD.'''
    longdesc = '''CRS bit in host mode and initiates the restore process. When software sets this bit to '1', the controller immediately sets DSTS.RSS to '1'. When the controller has finished the restore process, it sets DSTS.RSS to '0'. Note: When read, this field always returns '0'.'''
  [[register.field]]
    name = "CSS"
    bits = "16"
    type = "rw"
    shortdesc = '''Controller Save State (CSS) This command is similar to the USBCMD.'''
    longdesc = '''CSS bit in host mode and initiates the save process. When software sets this bit to '1', the controller immediately sets DSTS.SSS to '1'. When the controller has finished the save process, it sets DSTS.SSS to '0'. Note: When read, this field always returns '0'.'''
  [[register.field]]
    name = "RESERVED"
    bits = "15:13"
    type = "ro"
  [[register.field]]
    name = "INITU2ENA"
    bits = "12"
    type = "rw"
    shortdesc = '''Initiate U2 Enable - 1'b0: May not initiate U2 (default) - 1'b1: May initiate U2 On USB reset, hardware clears this bit to 0.'''
    longdesc = '''Software sets this bit after receiving SetFeature(U2_ENABLE), and clears this bit when ClearFeature(U2_ENABLE) is received. If DCTL[11] (AcceptU2Ena) is 0, the link immediately exits U2 state.'''
  [[register.field]]
    name = "ACCEPTU2ENA"
    bits = "11"
    type = "rw"
    shortdesc = '''Accept U2 Enable - 1'b0: Reject U2 except when Force_LinkPM_Accept bit is set (default) - 1'b1: Core accepts transition to U2 state if nothing is pending on the application side.'''
    longdesc = '''On USB reset, hardware clears this bit to 0. Software sets this bit after receiving a SetConfiguration command.'''
  [[register.field]]
    name = "INITU1ENA"
    bits = "10"
    type = "rw"
    shortdesc = '''Initiate U1 Enable - 1'b0: May not initiate U1 (default); - 1'b1: May initiate U1.'''
    longdesc = '''On USB reset, hardware clears this bit to 0. Software sets this bit after receiving SetFeature(U1_ENABLE), and clears this bit when ClearFeature(U1_ENABLE) is received. If DCTL[9] (AcceptU1Ena) is 0, the link immediately exits U1 state.'''
  [[register.field]]
    name = "ACCEPTU1ENA"
    bits = "9"
    type = "rw"
    shortdesc = '''Accept U1 Enable - 1'b0: Core rejects U1 except when Force_LinkPM_Accept bit is set (default) - 1'b1: Core accepts transition to U1 state if nothing is pending on the application side.'''
    longdesc = '''On USB reset, hardware clears this bit to 0. Software sets this bit after receiving a SetConfiguration command.'''
  [[register.field]]
    name = "ULSTCHNGREQ"
    bits = "8:5"
    type = "wo"
    shortdesc = '''ULSTCHNGREQ Software writes this field to issue a USB/Link state change request.'''
    longdesc = '''A change in this field indicates a new request to the core. If software wants to issue the same request back-to-back, it must write a 0 to this field between the two requests. The result of the state change request is reflected in the USB/Link State in DSTS. These bits are self-cleared on the MAC Layer exiting suspended state. If software is updating other fields of the DCTL register and not intending to force any link state change, then it must write a 0 to this field. SS Compliance mode is normally entered and controlled by the remote link partner. Refer to the USB 3.0 specification. Alternatively, you can force the local link directly into compliance mode, by resetting the SS link with the RUN/STOP bit set to zero. If you then write '10' to the USB/Link State Change field and '1' to RUN/STOP, the link goes to compliance mode. Once you are in compliance, you may alternately write zero and '10' to this field to advance the compliance pattern. In SS mode: - Value Requested Link State Transition/Action - 0 No Action - 4 SS.Disabled - 5 Rx.Detect - 6 SS.Inactive - 8 Recovery - 10 Compliance - Others: Reserved In HS/FS/LS mode: - ValueRequested USB state transition - 8 Remote wakeup request - Others: Reserved The Remote wakeup request must be issued 2us after the device goes into suspend state (DSTS[21:18] is 3 - refer to Table 'Fields for Register: DSTS' in the Databook). Note: After coming out of hibernation, software must write 8 (Recovery) into this field to confirm exit from the suspended state.'''
  [[register.field]]
    name = "TSTCTL"
    bits = "4:1"
    type = "rw"
  [[register.field]]
    name = "RESERVED"
    bits = "0"
    type = "ro"
[[register]]
  name = "DEVTEN"
  type = "mixed"
  width = 32
  description = "Device Event Enable Register This register controls the generation of device-specific events (see 'Event Buffer Content for Device-Specific Events (DEVT)' section in the Databook). If an enable bit is set to 0, the event will not be generated."
  default = "0x00000000"
  offset = "0x0000C708"
  [[register.field]]
    name = "RESERVED"
    bits = "31:14"
    type = "ro"
  [[register.field]]
    name = "VENDEVTSTRCVDEN"
    bits = "12"
    type = "rw"
  [[register.field]]
    name = "RESERVED"
    bits = "11"
    type = "ro"
  [[register.field]]
    name = "RESERVED"
    bits = "10"
    type = "ro"
  [[register.field]]
    name = "ERRTICERREVTEN"
    bits = "9"
    type = "rw"
  [[register.field]]
    name = "RESERVED"
    bits = "8"
    type = "ro"
  [[register.field]]
    name = "SOFTEVTEN"
    bits = "7"
    type = "rw"
  [[register.field]]
    name = "U3L2L1SUSPEN"
    bits = "6"
    type = "rw"
  [[register.field]]
    name = "HIBERNATIONREQEVTEN"
    bits = "5"
    type = "rw"
  [[register.field]]
    name = "WKUPEVTEN"
    bits = "4"
    type = "rw"
  [[register.field]]
    name = "ULSTCNGEN"
    bits = "3"
    type = "rw"
  [[register.field]]
    name = "CONNECTDONEEVTEN"
    bits = "2"
    type = "rw"
  [[register.field]]
    name = "USBRSTEVTEN"
    bits = "1"
    type = "rw"
  [[register.field]]
    name = "DISSCONNEVTEN"
    bits = "0"
    type = "rw"
[[register]]
  name = "DSTS"
  type = "mixed"
  width = 32
  description = "Device Status Register This register indicates the status of the device controller with respect to USB-related events. Note: When Hibernation is not enabled, RSS and SSS fields always return 0 when read."
  default = "0x00000000"
  offset = "0x0000C70C"
  [[register.field]]
    name = "RESERVED"
    bits = "31:30"
    type = "ro"
  [[register.field]]
    name = "DCNRD"
    bits = "29"
    type = "ro"
    shortdesc = '''Device Controller Not Ready The bit indicates that the core is in the process of completing the state transitions after exiting from hibernation.'''
    longdesc = '''To complete the state transitions, it takes 256 bus clock cycles from the time DCTL[31].Run/Stop is set. During hibernation, if the UTMI/ULPI PHY is in suspended state, then the 256-bus clock cycle delay starts after the PHY exited suspended state. Software must set DCTL[31].Run/Stop to '1' and wait for this bit to be de-asserted to zero before processing DSTS.USBLnkSt. This bit is valid only when DWC_USB3_EN_PWROPT is set to 2 and GCTL[1].GblHibernationEn =1.'''
  [[register.field]]
    name = "SRE"
    bits = "28"
    type = "wtc"
    shortdesc = '''Save Restore Error.'''
    longdesc = '''Currently not supported.'''
  [[register.field]]
    name = "RESERVED"
    bits = "27:26"
    type = "ro"
  [[register.field]]
    name = "RSS"
    bits = "25"
    type = "ro"
    shortdesc = '''RSS Restore State Status This bit is similar to the USBSTS.'''
    longdesc = '''RSS in host mode. When the controller finishes the restore process, it completes the command by setting DSTS.RSS to '0'.'''
  [[register.field]]
    name = "SSS"
    bits = "24"
    type = "ro"
    shortdesc = '''SSS Save State Status This bit is similar to the USBSTS.'''
    longdesc = '''SSS in host mode. When the controller has finished the save process, it completes the command by setting DSTS.SSS to '0'.'''
  [[register.field]]
    name = "COREIDLE"
    bits = "23"
    type = "ro"
    shortdesc = '''Core Idle The bit indicates that the core finished transferring all RxFIFO data to system memory, writing out all completed descriptors, and all Event Counts are zero.'''
    longdesc = '''Note: While testing for Reset values, mask out the read value. This bit represents the changing state of the core and does not hold a static value.'''
  [[register.field]]
    name = "DEVCTRLHLT"
    bits = "22"
    type = "ro"
    shortdesc = '''Device Controller Halted This bit is set to 0 when the Run/Stop bit in the DCTL register is set to 1.'''
    longdesc = '''The core sets this bit to 1 when, after SW sets Run/Stop to 0, the core is idle and the lower layer finishes the disconnect process. When Halted=1, the core does not generate Device events. Note: The core does not set this bit to 1 if GEVNTCOUNTn has some valid value. Software needs to acknowledge the events that are generated (by writing to GEVNTCOUNTn) while it is waiting for this bit to be set to 1.'''
  [[register.field]]
    name = "USBLNKST"
  bits = "21:18"
  type = "ro"
  shortdesc = '''USBLNKST.'''
  longdesc = '''USB/Link State In SS mode: LTSSM State - 4'h0: U0 - 4'h1: U1 - 4'h2: U2 - 4'h3: U3 - 4'h5: RX_DET - 4'h6: SS_INACT - 4'h7: POLL - 4'h8: RECOV - 4'h9: HRESET - 4'ha: CMPLY - 4'hb: LPBK - 4'hf: Resume/Reset In HS/FS/LS mode: - 4'h0: On state - 4'h2: Sleep (L1) state - 4'h3: Suspend (L2) state - 4'h4: Disconnected state (Default state) - 4'h5: Early Suspend state (valid only when Hibernation is disabled, GCTL[1].GblHibernationEn = 0) - 4'he: Reset (valid only when Hibernation is enabled, GCTL[1].GblHibernationEn = 1) - 4'hf: Resume (valid only when Hibernation is enabled, GCTL[1].GblHibernationEn = 1) The link state Resume/Reset indicates that the core received a resume or USB reset request from the host while the link was in hibernation. Software must write '8' (Recovery) to the DCTL.ULStChngReq field to acknowledge the resume/reset request. When Hibernation is enabled, GCTL[1].GblHibernationEn = 1, this field USBLnkSt is valid only when DCTL[31].Run/Stop set to '1' and DSTS[29].DCNRD = 0. Note: If SSIC is enabled, while exiting a low power state, the USBLnkSt field indicates Resume/Reset even for a disconnect condition because a resume precedes the disconnect.'''
[[register.field]]
name = "RXFIFOEMPTY"
bits = "17"
type = "ro"
[[register.field]]
name = "SOFFN"
bits = "16:3"
type = "ro"
shortdesc = '''Frame/Microframe Number of the Received SOF.'''
longdesc = '''When the core is operating at high-speed, - [16:6] indicates the frame number - [5:3] indicates the microframe number When the core is operating at full-speed, - [16:14] is not used. Software can ignore these 3 bits - [13:3] indicates the frame number'''
[[register.field]]
name = "CONNECTSPD"
bits = "2:0"
type = "ro"
shortdesc = '''Connected Speed (ConnectSpd) Indicates the speed at which the DWC_usb3 core has come up after speed detection through a chirp sequence.'''
longdesc = '''- 3'b100: SuperSpeed (PHY clock is running at 125 or 250 MHz) - 3'b000: High-speed (PHY clock is running at 30 or 60 MHz) - 3'b001: Full-speed (PHY clock is running at 30 or 60 MHz) - 3'b010: Low-speed (PHY clock is running at 6 MHz) - 3'b011: Full-speed (PHY clock is running at 48 MHz) Low-speed is not supported for devices using a UTMI+ PHY.'''
[[register.field.enum]]
name = "HIGH_SPEED"
value = 0
[[register.field.enum]]
name = "FULL_SPEED"
value = 1
[[register.field.enum]]
name = "LOW_SPEED"
value = 2
[[register.field.enum]]
name = "FULL_SPEED_NO_LOW"
value = 3
[[register.field.enum]]
name = "SUPER_SPEED"
value = 4

[[register]]
name = "DGCMDPAR"
type = "rw"
width = 32
description = "Device Generic Command Parameter Register This register indicates the device command parameter. This must be programmed before or along with the device command. The available device commands are listed in DGCMD register."
default = "0x00000000"
offset = "0x0000C710"
[[register.field]]
name = "PARAMETER"
bits = "31:0"
type = "rw"
[[register]]
name = "DGCMD"
type = "mixed"
width = 32
description = "Device Generic Command Register This register enables software to program the core using a single generic command interface to send link management packets and notifications. This register contains command, control, and status fields relevant to the current generic command, while the DGCMDPAR register provides the command parameter."
default = "0x00000000"
offset = "0x0000C714"
[[register.field]]
    name = "RESERVED"
    bits = "31:16"
    type = "ro"
  [[register.field]]
    name = "CMDSTATUS"
    bits = "15:12"
    type = "ro"
    shortdesc = '''Command Status - 1: CmdErr: Indicates that the device controller encountered an error while processing the command.'''
    longdesc = '''- 0: Indicates command success'''
  [[register.field]]
    name = "RESERVED"
    bits = "11"
    type = "ro"
  [[register.field]]
    name = "CMDACT"
    bits = "10"
    type = "rw"
    shortdesc = '''Command Active The software sets this bit to 1 to enable the device controller to execute the generic command.'''
    longdesc = '''The device controller sets this bit to 0 after executing the command.'''
  [[register.field]]
    name = "RESERVED"
    bits = "9"
    type = "ro"
  [[register.field]]
    name = "CMDIOC"
    bits = "8"
    type = "rw"
    shortdesc = '''Command Interrupt on Complete When this bit is set, the device controller issues a Generic Command Completion event after executing the command.'''
    longdesc = '''Note that this interrupt is mapped to DCFG.IntrNum. Note: This field must not set to '1' if the DCTL.RunStop field is '0'.'''
  [[register.field]]
    name = "CMDTYP"
    bits = "7:0"
    type = "rw"
    shortdesc = '''CMDTYP.'''
    longdesc = '''Command Type Specifies the type of command the software driver is requesting the core to perform. - 00h: Reserved - 01h: Set Endpoint Configuration - 64 or 96-bit Parameter - 02h: Set Endpoint Transfer Resource Configuration - 32-bit Parameter - 03h: Get Endpoint State - No Parameter Needed - 05h: Clear Stall (see Set Stall) - No Parameter Needed - 06h: Start Transfer - 64-bit Parameter - 07h: Update Transfer - No Parameter Needed - 08h: End Transfer - No Parameter Needed - 09h: Start New Configuration - No Parameter Needed'''
[[register]]
  name = "DALEPENA"
  type = "rw"
  width = 32
  description = "Device Active USB Endpoint Enable Register. This register indicates whether a USB endpoint is active in a given configuration or interface."
  default = "0x00000000"
  offset = "0x0000C720"
[[register.field]]
name = "USBACTEP"
bits = "31:0"
type = "rw"
shortdesc = '''USBACTEP USB Active Endpoints (USBActEP) This field indicates if a USB endpoint is active in the current configuration and interface.'''
longdesc = '''It applies to USB IN endpoints 0.15 and OUT endpoints 0.15, with one bit for each of the 32 possible endpoints. Even numbers are for USB OUT endpoints, and odd numbers are for USB IN endpoints, as follows: - Bit[0]: USB EP0-OUT - Bit[1]: USB EP0-IN - Bit[2]: USB EP1-OUT - Bit[3]: USB EP1-IN The entity programming this register must set bits 0 and 1 because they enable control endpoints that map to physical endpoints (resources) after USBReset. Hardware clears these bits for all endpoints (other than EP0-OUT and EP0-IN) after detecting a USB reset event. After receiving SetConfiguration and SetInterface requests, the application must program endpoint registers accordingly and set these bits.'''
[[register]]
name = "RSVD0"
type = "ro"
width = 32
description = "RESERVED"
default = "0x00000000"
offset = "0x0000C724"
[[register.field]]
name = "RESERVED"
bits = "31:0"
type = "ro"
[[register]]
name = "RSVD1"
type = "ro"
width = 32
description = "RESERVED"
default = "0x00000000"
offset = "0x0000C728"
[[register.field]]
name = "RESERVED"
bits = "31:0"
type = "ro"
[[register]]
name = "RSVD2"
type = "ro"
width = 32
description = "RESERVED"
default = "0x00000000"
offset = "0x0000C72C"
[[register.field]]
name = "RESERVED"
bits = "31:0"
type = "ro"
[[register]]
name = "RSVD3"
type = "ro"
width = 32
description = "RESERVED"
default = "0x00000000"
offset = "0x0000C730"
[[register.field]]
name = "RESERVED"
bits = "31:0"
type = "ro"
[[register]]
name = "RSVD4"
type = "ro"
width = 32
description = "RESERVED"
default = "0x00000000"
offset = "0x0000C734"
[[register.field]]
name = "RESERVED"
bits = "31:0"
type = "ro"
[[register]]
name = "RSVD5"
type = "ro"
width = 32
description = "RESERVED"
default = "0x00000000"
offset = "0x0000C738"
[[register.field]]
name = "RESERVED"
bits = "31:0"
type = "ro"
[[register]]
name = "RSVD6"
type = "ro"
width = 32
description = "RESERVED"
default = "0x00000000"
offset = "0x0000C73C"
[[register.field]]
name = "RESERVED"
bits = "31:0"
type = "ro"
[[register]]
name = "RSVD7"
type = "ro"
width = 32
description = "RESERVED"
default = "0x00000000"
offset = "0x0000C740"
[[register.field]]
name = "RESERVED"
bits = "31:0"
type = "ro"
[[register]]
name = "RSVD8"
type = "ro"
width = 32
description = "RESERVED"
default = "0x00000000"
offset = "0x0000C744"
[[register.field]]
name = "RESERVED"
bits = "31:0"
type = "ro"
[[register]]
name = "RSVD9"
type = "ro"
width = 32
description = "RESERVED"
default = "0x00000000"
offset = "0x0000C748"
[[register.field]]
name = "RESERVED"
bits = "31:0"
type = "ro"
[[register]]
name = "RSVD10"
type = "ro"
width = 32
description = "RESERVED"
default = "0x00000000"
offset = "0x0000C74C"
[[register.field]]
name = "RESERVED"
bits = "31:0"
type = "ro"
[[register]]
name = "RSVD11"
type = "ro"
width = 32
description = "RESERVED"
default = "0x00000000"
offset = "0x0000C750"
[[register.field]]
name = "RESERVED"
bits = "31:0"
type = "ro"
[[register]]
name = "RSVD12"
type = "ro"
width = 32
description = "RESERVED"
default = "0x00000000"
offset = "0x0000C754"
[[register.field]]
name = "RESERVED"
bits = "31:0"
type = "ro"
[[register]]
name = "RSVD13"
type = "ro"
width = 32
description = "RESERVED"
default = "0x00000000"
offset = "0x0000C758"
[[register.field]]
name = "RESERVED"
bits = "31:0"
type = "ro"
[[register]]
name = "RSVD14"
type = "ro"
width = 32
description = "RESERVED"
default = "0x00000000"
offset = "0x0000C75C"
[[register.field]]
name = "RESERVED"
bits = "31:0"
type = "ro"
[[register]]
name = "RSVD15"
type = "ro"
width = 32
description = "RESERVED"
default = "0x00000000"
offset = "0x0000C760"
[[register.field]]
name = "RESERVED"
bits = "31:0"
type = "ro"
[[register]]
name = "RSVD16"
type = "ro"
width = 32
description = "RESERVED"
default = "0x00000000"
offset = "0x0000C764"
[[register.field]]
name = "RESERVED"
bits = "31:0"
type = "ro"
[[register]]
name = "RSVD17"
type = "ro"
width = 32
description = "RESERVED"
default = "0x00000000"
offset = "0x0000C768"
[[register.field]]
name = "RESERVED"
bits = "31:0"
type = "ro"
[[register]]
name = "RSVD18"
type = "ro"
width = 32
description = "RESERVED"
default = "0x00000000"
offset = "0x0000C76C"
[[register.field]]
name = "RESERVED"
bits = "31:0"
type = "ro"
[[register]]
name = "RSVD19"
type = "ro"
width = 32
description = "RESERVED"
default = "0x00000000"
offset = "0x0000C770"
[[register.field]]
name = "RESERVED"
bits = "31:0"
type = "ro"
[[register]]
name = "RSVD20"
type = "ro"
width = 32
description = "RESERVED"
default = "0x00000000"
offset = "0x0000C774"
[[register.field]]
name = "RESERVED"
bits = "31:0"
type = "ro"
[[register]]
name = "RSVD21"
type = "ro"
width = 32
description = "RESERVED"
default = "0x00000000"
offset = "0x0000C778"
[[register.field]]
name = "RESERVED"
bits = "31:0"
type = "ro"
[[register]]
name = "RSVD22"
type = "ro"
width = 32
description = "RESERVED"
default = "0x00000000"
offset = "0x0000C77C"
[[register.field]]
name = "RESERVED"
bits = "31:0"
type = "ro"
[[register]]
name = "RSVD23"
type = "ro"
width = 32
description = "RESERVED"
default = "0x00000000"
offset = "0x0000C780"
[[register.field]]
name = "RESERVED"
bits = "31:0"
type = "ro"
[[register]]
name = "RSVD24"
type = "ro"
width = 32
description = "RESERVED"
default = "0x00000000"
offset = "0x0000C784"
[[register.field]]
name = "RESERVED"
bits = "31:0"
type = "ro"
[[register]]
name = "RSVD25"
type = "ro"
width = 32
description = "RESERVED"
default = "0x00000000"
offset = "0x0000C788"
[[register.field]]
name = "RESERVED"
bits = "31:0"
type = "ro"
[[register]]
name = "RSVD26"
type = "ro"
width = 32
description = "RESERVED"
default = "0x00000000"
offset = "0x0000C78C"
[[register.field]]
name = "RESERVED"
bits = "31:0"
type = "ro"
[[register]]
name = "RSVD27"
type = "ro"
width = 32
description = "RESERVED"
default = "0x00000000"
offset = "0x0000C790"
[[register.field]]
name = "RESERVED"
bits = "31:0"
type = "ro"
[[register]]
name = "RSVD28"
type = "ro"
width = 32
description = "RESERVED"
default = "0x00000000"
offset = "0x0000C794"
[[register.field]]
name = "RESERVED"
bits = "31:0"
type = "ro"
[[register]]
name = "RSVD29"
type = "ro"
width = 32
description = "RESERVED"
default = "0x00000000"
offset = "0x0000C798"
[[register.field]]
name = "RESERVED"
bits = "31:0"
type = "ro"
[[register]]
name = "RSVD30"
type = "ro"
width = 32
description = "RESERVED"
default = "0x00000000"
offset = "0x0000C79C"
[[register.field]]
name = "RESERVED"
bits = "31:0"
type = "ro"
[[register]]
name = "RSVD31"
type = "ro"
width = 32
description = "RESERVED"
default = "0x00000000"
offset = "0x0000C7A0"
[[register.field]]
name = "RESERVED"
bits = "31:0"
type = "ro"
[[register]]
  name = "DEPCMDPAR2_0"
  type = "rw"
  width = 32
  description = "Device Physical Endpoint-n Command Parameter 2 Register (DEPCMDPAR2n) This register indicates the physical endpoint command Parameter 2. It must be programmed before issuing the command. Instance 0 of an array of 12."
  default = "0x00000000"
  offset = "0x0000C800"
  [[register.field]]
    name = "PARAMETER"
    bits = "31:0"
    type = "rw"
[[register]]
  name = "DEPCMDPAR1_0"
  type = "rw"
  width = 32
  description = "Device Physical Endpoint-n Command Parameter 1 Register (DEPCMDPAR1n) Instance 0 of an array of 12."
  default = "0x00000000"
  offset = "0x0000C804"
  [[register.field]]
    name = "PARAMETER"
    bits = "31:0"
    type = "rw"
[[register]]
  name = "DEPCMDPAR0_0"
  type = "rw"
  width = 32
  description = "Device Physical Endpoint-n Command Parameter 0 Register (DEPCMDPAR0n) Instance 0 of an array of 12."
  default = "0x00000000"
  offset = "0x0000C808"
  [[register.field]]
    name = "PARAMETER"
    bits = "31:0"
    type = "rw"
[[register]]
  name = "DEPCMD_0"
  type = "mixed"
  width = 32
  description = "Device Physical Endpoint-n Command Register This register enables software to issue physical endpoint-specific commands. This register contains command, control, and status fields relevant to the current generic command, while the DEPCMDPAR[2:0]n registers provide command parameters and return status information. Several fields (including Command Type) are write-only, so their read values are undefined. After power-on, prior to issuing the first endpoint command, the read value of this register is undefined. In particular, the CmdAct bit may be set after power-on. In this case, it is safe to issue an endpoint command. Instance 0 of an array of 12."
  default = "0x00000000"
  offset = "0x0000C80C"
  [[register.field]]
    name = "COMMANDPARAM"
    bits = "31:16"
    type = "rw"
    shortdesc = '''Command Parameters or Event Parameters Command Parameters (CommandParam), when this register is written: For Start Transfer command: - [31:16]: StreamID.'''
    longdesc = '''The USB StreamID assigned to this transfer For Start Transfer command applied to an isochronous endpoint - [31:16]: StartMicroFramNum: Indicates the (micro)frame number to which the first TRB applies. For Update Transfer, End Transfer, and Start New Configuration commands - [22:16]: Transfer Resource Index (XferRscIdx). The hardware-assigned transfer resource index for the transfer, which was returned in response to the Start Transfer command. The application software-assigned transfer resource index for a Start New Configuration command. Event Parameters (EventParam), when this register is read. Refer to bits [31:16] in Table 'Device Endpoint-n Events: DEPEVT' of the Databook.'''
  [[register.field]]
    name = "CMDSTATUS"
    bits = "15:12"
    type = "rw"
    shortdesc = '''Command Completion Status (CmdStatus) Additional information about the completion of this command is available in this field.'''
    longdesc = '''The information is in the same format as bits 15:12 of the Endpoint Command Complete event, see 'Device Endpoint-n Events: DEPEVT' table in the Databook.'''
  [[register.field]]
    name = "HIPRI_FORCERM"
    bits = "11"
    type = "rw"
    shortdesc = '''HighPriority/ForceRM (HiPri_ForceRM) - HighPriority: Only valid for Start Transfer command - ForceRM: Only valid for End Transfer command - ClearPendIN: Only valid for Clear Stall command.'''
    longdesc = '''Software sets this bit to clear any pending IN transaction (on that endpoint) stuck at the lower layers when a Clear Stall command is issued.'''
  [[register.field]]
    name = "CMDACT"
    bits = "10"
    type = "rw"
    shortdesc = '''Command Active (CmdAct) Software sets this bit to 1 to enable the device endpoint controller to execute the generic command.'''
    longdesc = '''The device controller sets this bit to 0 when the CmdStatus field is valid and the endpoint is ready to accept another command. This does not imply that all the effects of the previously-issued command have taken place.'''
  [[register.field]]
    name = "RESERVED"
    bits = "9"
    type = "ro"
  [[register.field]]
    name = "CMDIOC"
    bits = "8"
    type = "rw"
    shortdesc = '''CMDIOC Command Interrupt on Complete (CmdIOC) When this bit is set, the device controller issues a generic Endpoint Command Complete event after executing the command.'''
    longdesc = '''Note that this interrupt is mapped to DEPCFG.IntrNum. When the DEPCFG command is executed, the command interrupt on completion goes to the interrupt pointed by the DEPCFG.IntrNum in the current command. Note: This field must not set to 1 if the DCTL.RunStop field is 0.'''
  [[register.field]]
    name = "RESERVED"
    bits = "7:4"
    type = "ro"
  [[register.field]]
    name = "CMDTYP"
    bits = "3:0"
    type = "rw"
    shortdesc = '''Command Type Specifies the type of command the software driver is requesting the core to perform.'''
    longdesc = '''- 00h: Reserved - 01h: Set Endpoint Configuration - -64 or 96-bit Parameter - 02h: Set Endpoint Transfer Resource Configuration - 32-bit Parameter - 03h: Get Endpoint State - No Parameter Needed - 04h: Set Stall - No Parameter Needed - 05h: Clear Stall (see Set Stall) - No Parameter Needed - 06h: Start Transfer - 64-bit Parameter - 07h: Update Transfer - No Parameter Needed - 08h: End Transfer - No Parameter Needed - 09h: Start New Configuration - No Parameter Needed'''
[[register]]
  name = "DEPCMDPAR2_1"
  type = "rw"
  width = 32
  description = "Device Physical Endpoint-n Command Parameter 2 Register (DEPCMDPAR2n) This register indicates the physical endpoint command Parameter 2. It must be programmed before issuing the command. Instance 1 of an array of 12."
  default = "0x00000000"
  offset = "0x0000C810"
  [[register.field]]
    name = "PARAMETER"
    bits = "31:0"
    type = "rw"
[[register]]
  name = "DEPCMDPAR1_1"
  type = "rw"
  width = 32
  description = "Device Physical Endpoint-n Command Parameter 1 Register (DEPCMDPAR1n) Instance 1 of an array of 12."
  default = "0x00000000"
  offset = "0x0000C814"
  [[register.field]]
    name = "PARAMETER"
    bits = "31:0"
    type = "rw"
[[register]]
  name = "DEPCMDPAR0_1"
  type = "rw"
  width = 32
  description = "Device Physical Endpoint-n Command Parameter 0 Register (DEPCMDPAR0n) Instance 1 of an array of 12."
  default = "0x00000000"
  offset = "0x0000C818"
  [[register.field]]
    name = "PARAMETER"
    bits = "31:0"
    type = "rw"
[[register]]
  name = "DEPCMD_1"
  type = "mixed"
  width = 32
  description = "Device Physical Endpoint-n Command Register This register enables software to issue physical endpoint-specific commands. This register contains command, control, and status fields relevant to the current generic command, while the DEPCMDPAR[2:0]n registers provide command parameters and return status information. Several fields (including Command Type) are write-only, so their read values are undefined. After power-on, prior to issuing the first endpoint command, the read value of this register is undefined. In particular, the CmdAct bit may be set after power-on. In this case, it is safe to issue an endpoint command. Instance 1 of an array of 12."
  default = "0x00000000"
  offset = "0x0000C81C"
  [[register.field]]
    name = "COMMANDPARAM"
    bits = "31:16"
    type = "rw"
    shortdesc = '''Command Parameters or Event Parameters Command Parameters (CommandParam), when this register is written: For Start Transfer command: - [31:16]: StreamID.'''
    longdesc = '''The USB StreamID assigned to this transfer For Start Transfer command applied to an isochronous endpoint - [31:16]: StartMicroFramNum: Indicates the (micro)frame number to which the first TRB applies. For Update Transfer, End Transfer, and Start New Configuration commands - [22:16]: Transfer Resource Index (XferRscIdx). The hardware-assigned transfer resource index for the transfer, which was returned in response to the Start Transfer command. The application software-assigned transfer resource index for a Start New Configuration command. Event Parameters (EventParam), when this register is read. Refer to bits [31:16] in Table 'Device Endpoint-n Events: DEPEVT' of the Databook.'''
  [[register.field]]
    name = "CMDSTATUS"
    bits = "15:12"
    type = "rw"
    shortdesc = '''Command Completion Status (CmdStatus) Additional information about the completion of this command is available in this field.'''
    longdesc = '''The information is in the same format as bits 15:12 of the Endpoint Command Complete event, see 'Device Endpoint-n Events: DEPEVT' table in the Databook.'''
  [[register.field]]
    name = "HIPRI_FORCERM"
    bits = "11"
    type = "rw"
    shortdesc = '''HighPriority/ForceRM (HiPri_ForceRM) - HighPriority: Only valid for Start Transfer command - ForceRM: Only valid for End Transfer command - ClearPendIN: Only valid for Clear Stall command.'''
    longdesc = '''Software sets this bit to clear any pending IN transaction (on that endpoint) stuck at the lower layers when a Clear Stall command is issued.'''
  [[register.field]]
    name = "CMDACT"
    bits = "10"
    type = "rw"
    shortdesc = '''Command Active (CmdAct) Software sets this bit to 1 to enable the device endpoint controller to execute the generic command.'''
    longdesc = '''The device controller sets this bit to 0 when the CmdStatus field is valid and the endpoint is ready to accept another command. This does not imply that all the effects of the previously-issued command have taken place.'''
  [[register.field]]
    name = "RESERVED"
    bits = "9"
    type = "ro"
  [[register.field]]
    name = "CMDIOC"
    bits = "8"
    type = "rw"
    shortdesc = '''CMDIOC Command Interrupt on Complete (CmdIOC) When this bit is set, the device controller issues a generic Endpoint Command Complete event after executing the command.'''
    longdesc = '''Note that this interrupt is mapped to DEPCFG.IntrNum. When the DEPCFG command is executed, the command interrupt on completion goes to the interrupt pointed by the DEPCFG.IntrNum in the current command. Note: This field must not set to 1 if the DCTL.RunStop field is 0.'''
  [[register.field]]
    name = "RESERVED"
    bits = "7:4"
    type = "ro"
  [[register.field]]
    name = "CMDTYP"
    bits = "3:0"
    type = "rw"
    shortdesc = '''Command Type Specifies the type of command the software driver is requesting the core to perform.'''
    longdesc = '''- 00h: Reserved - 01h: Set Endpoint Configuration - -64 or 96-bit Parameter - 02h: Set Endpoint Transfer Resource Configuration - 32-bit Parameter - 03h: Get Endpoint State - No Parameter Needed - 04h: Set Stall - No Parameter Needed - 05h: Clear Stall (see Set Stall) - No Parameter Needed - 06h: Start Transfer - 64-bit Parameter - 07h: Update Transfer - No Parameter Needed - 08h: End Transfer - No Parameter Needed - 09h: Start New Configuration - No Parameter Needed'''
[[register]]
  name = "DEPCMDPAR2_2"
  type = "rw"
  width = 32
  description = "Device Physical Endpoint-n Command Parameter 2 Register (DEPCMDPAR2n) This register indicates the physical endpoint command Parameter 2. It must be programmed before issuing the command. Instance 2 of an array of 12."
  default = "0x00000000"
  offset = "0x0000C820"
  [[register.field]]
    name = "PARAMETER"
    bits = "31:0"
    type = "rw"
[[register]]
  name = "DEPCMDPAR1_2"
  type = "rw"
  width = 32
  description = "Device Physical Endpoint-n Command Parameter 1 Register (DEPCMDPAR1n) Instance 2 of an array of 12."
  default = "0x00000000"
  offset = "0x0000C824"
  [[register.field]]
    name = "PARAMETER"
    bits = "31:0"
    type = "rw"
[[register]]
  name = "DEPCMDPAR0_2"
  type = "rw"
  width = 32
  description = "Device Physical Endpoint-n Command Parameter 0 Register (DEPCMDPAR0n) Instance 2 of an array of 12."
  default = "0x00000000"
  offset = "0x0000C828"
  [[register.field]]
    name = "PARAMETER"
    bits = "31:0"
    type = "rw"
[[register]]
  name = "DEPCMD_2"
  type = "mixed"
  width = 32
  description = "Device Physical Endpoint-n Command Register This register enables software to issue physical endpoint-specific commands. This register contains command, control, and status fields relevant to the current generic command, while the DEPCMDPAR[2:0]n registers provide command parameters and return status information. Several fields (including Command Type) are write-only, so their read values are undefined. After power-on, prior to issuing the first endpoint command, the read value of this register is undefined. In particular, the CmdAct bit may be set after power-on. In this case, it is safe to issue an endpoint command. Instance 2 of an array of 12."
  default = "0x00000000"
  offset = "0x0000C82C"
  [[register.field]]
    name = "COMMANDPARAM"
    bits = "31:16"
    type = "rw"
    shortdesc = '''Command Parameters or Event Parameters Command Parameters (CommandParam), when this register is written: For Start Transfer command: - [31:16]: StreamID.'''
    longdesc = '''The USB StreamID assigned to this transfer For Start Transfer command applied to an isochronous endpoint - [31:16]: StartMicroFramNum: Indicates the (micro)frame number to which the first TRB applies. For Update Transfer, End Transfer, and Start New Configuration commands - [22:16]: Transfer Resource Index (XferRscIdx). The hardware-assigned transfer resource index for the transfer, which was returned in response to the Start Transfer command. The application software-assigned transfer resource index for a Start New Configuration command. Event Parameters (EventParam), when this register is read. Refer to bits [31:16] in Table 'Device Endpoint-n Events: DEPEVT' of the Databook.'''
  [[register.field]]
    name = "CMDSTATUS"
    bits = "15:12"
    type = "rw"
    shortdesc = '''Command Completion Status (CmdStatus) Additional information about the completion of this command is available in this field.'''
    longdesc = '''The information is in the same format as bits 15:12 of the Endpoint Command Complete event, see 'Device Endpoint-n Events: DEPEVT' table in the Databook.'''
  [[register.field]]
    name = "HIPRI_FORCERM"
    bits = "11"
    type = "rw"
    shortdesc = '''HighPriority/ForceRM (HiPri_ForceRM) - HighPriority: Only valid for Start Transfer command - ForceRM: Only valid for End Transfer command - ClearPendIN: Only valid for Clear Stall command.'''
    longdesc = '''Software sets this bit to clear any pending IN transaction (on that endpoint) stuck at the lower layers when a Clear Stall command is issued.'''
  [[register.field]]
    name = "CMDACT"
    bits = "10"
    type = "rw"
    shortdesc = '''Command Active (CmdAct) Software sets this bit to 1 to enable the device endpoint controller to execute the generic command.'''
    longdesc = '''The device controller sets this bit to 0 when the CmdStatus field is valid and the endpoint is ready to accept another command. This does not imply that all the effects of the previously-issued command have taken place.'''
  [[register.field]]
    name = "RESERVED"
    bits = "9"
    type = "ro"
  [[register.field]]
    name = "CMDIOC"
    bits = "8"
    type = "rw"
    shortdesc = '''CMDIOC Command Interrupt on Complete (CmdIOC) When this bit is set, the device controller issues a generic Endpoint Command Complete event after executing the command.'''
    longdesc = '''Note that this interrupt is mapped to DEPCFG.IntrNum. When the DEPCFG command is executed, the command interrupt on completion goes to the interrupt pointed by the DEPCFG.IntrNum in the current command. Note: This field must not set to 1 if the DCTL.RunStop field is 0.'''
  [[register.field]]
    name = "RESERVED"
    bits = "7:4"
    type = "ro"
  [[register.field]]
    name = "CMDTYP"
    bits = "3:0"
    type = "rw"
    shortdesc = '''Command Type Specifies the type of command the software driver is requesting the core to perform.'''
    longdesc = '''- 00h: Reserved - 01h: Set Endpoint Configuration - -64 or 96-bit Parameter - 02h: Set Endpoint Transfer Resource Configuration - 32-bit Parameter - 03h: Get Endpoint State - No Parameter Needed - 04h: Set Stall - No Parameter Needed - 05h: Clear Stall (see Set Stall) - No Parameter Needed - 06h: Start Transfer - 64-bit Parameter - 07h: Update Transfer - No Parameter Needed - 08h: End Transfer - No Parameter Needed - 09h: Start New Configuration - No Parameter Needed'''
[[register]]
  name = "DEPCMDPAR2_3"
  type = "rw"
  width = 32
  description = "Device Physical Endpoint-n Command Parameter 2 Register (DEPCMDPAR2n) This register indicates the physical endpoint command Parameter 2. It must be programmed before issuing the command. Instance 3 of an array of 12."
  default = "0x00000000"
  offset = "0x0000C830"
  [[register.field]]
    name = "PARAMETER"
    bits = "31:0"
    type = "rw"
[[register]]
  name = "DEPCMDPAR1_3"
  type = "rw"
  width = 32
  description = "Device Physical Endpoint-n Command Parameter 1 Register (DEPCMDPAR1n) Instance 3 of an array of 12."
  default = "0x00000000"
  offset = "0x0000C834"
  [[register.field]]
    name = "PARAMETER"
    bits = "31:0"
    type = "rw"
[[register]]
  name = "DEPCMDPAR0_3"
  type = "rw"
  width = 32
  description = "Device Physical Endpoint-n Command Parameter 0 Register (DEPCMDPAR0n) Instance 3 of an array of 12."
  default = "0x00000000"
  offset = "0x0000C838"
  [[register.field]]
    name = "PARAMETER"
    bits = "31:0"
    type = "rw"
[[register]]
  name = "DEPCMD_3"
  type = "mixed"
  width = 32
  description = "Device Physical Endpoint-n Command Register This register enables software to issue physical endpoint-specific commands. This register contains command, control, and status fields relevant to the current generic command, while the DEPCMDPAR[2:0]n registers provide command parameters and return status information. Several fields (including Command Type) are write-only, so their read values are undefined. After power-on, prior to issuing the first endpoint command, the read value of this register is undefined. In particular, the CmdAct bit may be set after power-on. In this case, it is safe to issue an endpoint command. Instance 3 of an array of 12."
  default = "0x00000000"
  offset = "0x0000C83C"
  [[register.field]]
    name = "COMMANDPARAM"
    bits = "31:16"
    type = "rw"
    shortdesc = '''Command Parameters or Event Parameters Command Parameters (CommandParam), when this register is written: For Start Transfer command: - [31:16]: StreamID.'''
    longdesc = '''The USB StreamID assigned to this transfer For Start Transfer command applied to an isochronous endpoint - [31:16]: StartMicroFramNum: Indicates the (micro)frame number to which the first TRB applies. For Update Transfer, End Transfer, and Start New Configuration commands - [22:16]: Transfer Resource Index (XferRscIdx). The hardware-assigned transfer resource index for the transfer, which was returned in response to the Start Transfer command. The application software-assigned transfer resource index for a Start New Configuration command. Event Parameters (EventParam), when this register is read. Refer to bits [31:16] in Table 'Device Endpoint-n Events: DEPEVT' of the Databook.'''
  [[register.field]]
    name = "CMDSTATUS"
    bits = "15:12"
    type = "rw"
    shortdesc = '''Command Completion Status (CmdStatus) Additional information about the completion of this command is available in this field.'''
    longdesc = '''The information is in the same format as bits 15:12 of the Endpoint Command Complete event, see 'Device Endpoint-n Events: DEPEVT' table in the Databook.'''
  [[register.field]]
    name = "HIPRI_FORCERM"
    bits = "11"
    type = "rw"
    shortdesc = '''HighPriority/ForceRM (HiPri_ForceRM) - HighPriority: Only valid for Start Transfer command - ForceRM: Only valid for End Transfer command - ClearPendIN: Only valid for Clear Stall command.'''
    longdesc = '''Software sets this bit to clear any pending IN transaction (on that endpoint) stuck at the lower layers when a Clear Stall command is issued.'''
  [[register.field]]
    name = "CMDACT"
    bits = "10"
    type = "rw"
    shortdesc = '''Command Active (CmdAct) Software sets this bit to 1 to enable the device endpoint controller to execute the generic command.'''
    longdesc = '''The device controller sets this bit to 0 when the CmdStatus field is valid and the endpoint is ready to accept another command. This does not imply that all the effects of the previously-issued command have taken place.'''
  [[register.field]]
    name = "RESERVED"
    bits = "9"
    type = "ro"
  [[register.field]]
    name = "CMDIOC"
    bits = "8"
    type = "rw"
    shortdesc = '''CMDIOC Command Interrupt on Complete (CmdIOC) When this bit is set, the device controller issues a generic Endpoint Command Complete event after executing the command.'''
    longdesc = '''Note that this interrupt is mapped to DEPCFG.IntrNum. When the DEPCFG command is executed, the command interrupt on completion goes to the interrupt pointed by the DEPCFG.IntrNum in the current command. Note: This field must not set to 1 if the DCTL.RunStop field is 0.'''
  [[register.field]]
    name = "RESERVED"
    bits = "7:4"
    type = "ro"
  [[register.field]]
    name = "CMDTYP"
    bits = "3:0"
    type = "rw"
    shortdesc = '''Command Type Specifies the type of command the software driver is requesting the core to perform.'''
    longdesc = '''- 00h: Reserved - 01h: Set Endpoint Configuration - -64 or 96-bit Parameter - 02h: Set Endpoint Transfer Resource Configuration - 32-bit Parameter - 03h: Get Endpoint State - No Parameter Needed - 04h: Set Stall - No Parameter Needed - 05h: Clear Stall (see Set Stall) - No Parameter Needed - 06h: Start Transfer - 64-bit Parameter - 07h: Update Transfer - No Parameter Needed - 08h: End Transfer - No Parameter Needed - 09h: Start New Configuration - No Parameter Needed'''
[[register]]
  name = "DEPCMDPAR2_4"
  type = "rw"
  width = 32
  description = "Device Physical Endpoint-n Command Parameter 2 Register (DEPCMDPAR2n) This register indicates the physical endpoint command Parameter 2. It must be programmed before issuing the command. Instance 4 of an array of 12."
  default = "0x00000000"
  offset = "0x0000C840"
  [[register.field]]
    name = "PARAMETER"
    bits = "31:0"
    type = "rw"
[[register]]
  name = "DEPCMDPAR1_4"
  type = "rw"
  width = 32
  description = "Device Physical Endpoint-n Command Parameter 1 Register (DEPCMDPAR1n) Instance 4 of an array of 12."
  default = "0x00000000"
  offset = "0x0000C844"
  [[register.field]]
    name = "PARAMETER"
    bits = "31:0"
    type = "rw"
[[register]]
  name = "DEPCMDPAR0_4"
  type = "rw"
  width = 32
  description = "Device Physical Endpoint-n Command Parameter 0 Register (DEPCMDPAR0n) Instance 4 of an array of 12."
  default = "0x00000000"
  offset = "0x0000C848"
  [[register.field]]
    name = "PARAMETER"
    bits = "31:0"
    type = "rw"
[[register]]
  name = "DEPCMD_4"
  type = "mixed"
  width = 32
  description = "Device Physical Endpoint-n Command Register This register enables software to issue physical endpoint-specific commands. This register contains command, control, and status fields relevant to the current generic command, while the DEPCMDPAR[2:0]n registers provide command parameters and return status information. Several fields (including Command Type) are write-only, so their read values are undefined. After power-on, prior to issuing the first endpoint command, the read value of this register is undefined. In particular, the CmdAct bit may be set after power-on. In this case, it is safe to issue an endpoint command. Instance 4 of an array of 12."
  default = "0x00000000"
  offset = "0x0000C84C"
  [[register.field]]
    name = "COMMANDPARAM"
    bits = "31:16"
    type = "rw"
    shortdesc = '''Command Parameters or Event Parameters Command Parameters (CommandParam), when this register is written: For Start Transfer command: - [31:16]: StreamID.'''
    longdesc = '''The USB StreamID assigned to this transfer For Start Transfer command applied to an isochronous endpoint - [31:16]: StartMicroFramNum: Indicates the (micro)frame number to which the first TRB applies. For Update Transfer, End Transfer, and Start New Configuration commands - [22:16]: Transfer Resource Index (XferRscIdx). The hardware-assigned transfer resource index for the transfer, which was returned in response to the Start Transfer command. The application software-assigned transfer resource index for a Start New Configuration command. Event Parameters (EventParam), when this register is read. Refer to bits [31:16] in Table 'Device Endpoint-n Events: DEPEVT' of the Databook.'''
  [[register.field]]
    name = "CMDSTATUS"
    bits = "15:12"
    type = "rw"
    shortdesc = '''Command Completion Status (CmdStatus) Additional information about the completion of this command is available in this field.'''
    longdesc = '''The information is in the same format as bits 15:12 of the Endpoint Command Complete event, see 'Device Endpoint-n Events: DEPEVT' table in the Databook.'''
  [[register.field]]
    name = "HIPRI_FORCERM"
    bits = "11"
    type = "rw"
    shortdesc = '''HighPriority/ForceRM (HiPri_ForceRM) - HighPriority: Only valid for Start Transfer command - ForceRM: Only valid for End Transfer command - ClearPendIN: Only valid for Clear Stall command.'''
    longdesc = '''Software sets this bit to clear any pending IN transaction (on that endpoint) stuck at the lower layers when a Clear Stall command is issued.'''
  [[register.field]]
    name = "CMDACT"
    bits = "10"
    type = "rw"
    shortdesc = '''Command Active (CmdAct) Software sets this bit to 1 to enable the device endpoint controller to execute the generic command.'''
    longdesc = '''The device controller sets this bit to 0 when the CmdStatus field is valid and the endpoint is ready to accept another command. This does not imply that all the effects of the previously-issued command have taken place.'''
  [[register.field]]
    name = "RESERVED"
    bits = "9"
    type = "ro"
  [[register.field]]
    name = "CMDIOC"
    bits = "8"
    type = "rw"
    shortdesc = '''CMDIOC Command Interrupt on Complete (CmdIOC) When this bit is set, the device controller issues a generic Endpoint Command Complete event after executing the command.'''
    longdesc = '''Note that this interrupt is mapped to DEPCFG.IntrNum. When the DEPCFG command is executed, the command interrupt on completion goes to the interrupt pointed by the DEPCFG.IntrNum in the current command. Note: This field must not set to 1 if the DCTL.RunStop field is 0.'''
  [[register.field]]
    name = "RESERVED"
    bits = "7:4"
    type = "ro"
  [[register.field]]
    name = "CMDTYP"
    bits = "3:0"
    type = "rw"
    shortdesc = '''Command Type Specifies the type of command the software driver is requesting the core to perform.'''
    longdesc = '''- 00h: Reserved - 01h: Set Endpoint Configuration - -64 or 96-bit Parameter - 02h: Set Endpoint Transfer Resource Configuration - 32-bit Parameter - 03h: Get Endpoint State - No Parameter Needed - 04h: Set Stall - No Parameter Needed - 05h: Clear Stall (see Set Stall) - No Parameter Needed - 06h: Start Transfer - 64-bit Parameter - 07h: Update Transfer - No Parameter Needed - 08h: End Transfer - No Parameter Needed - 09h: Start New Configuration - No Parameter Needed'''
[[register]]
  name = "DEPCMDPAR2_5"
  type = "rw"
  width = 32
  description = "Device Physical Endpoint-n Command Parameter 2 Register (DEPCMDPAR2n) This register indicates the physical endpoint command Parameter 2. It must be programmed before issuing the command. Instance 5 of an array of 12."
  default = "0x00000000"
  offset = "0x0000C850"
  [[register.field]]
    name = "PARAMETER"
    bits = "31:0"
    type = "rw"
[[register]]
  name = "DEPCMDPAR1_5"
  type = "rw"
  width = 32
  description = "Device Physical Endpoint-n Command Parameter 1 Register (DEPCMDPAR1n) Instance 5 of an array of 12."
  default = "0x00000000"
  offset = "0x0000C854"
  [[register.field]]
    name = "PARAMETER"
    bits = "31:0"
    type = "rw"
[[register]]
  name = "DEPCMDPAR0_5"
  type = "rw"
  width = 32
  description = "Device Physical Endpoint-n Command Parameter 0 Register (DEPCMDPAR0n) Instance 5 of an array of 12."
  default = "0x00000000"
  offset = "0x0000C858"
  [[register.field]]
    name = "PARAMETER"
    bits = "31:0"
    type = "rw"
[[register]]
  name = "DEPCMD_5"
  type = "mixed"
  width = 32
  description = "Device Physical Endpoint-n Command Register This register enables software to issue physical endpoint-specific commands. This register contains command, control, and status fields relevant to the current generic command, while the DEPCMDPAR[2:0]n registers provide command parameters and return status information. Several fields (including Command Type) are write-only, so their read values are undefined. After power-on, prior to issuing the first endpoint command, the read value of this register is undefined. In particular, the CmdAct bit may be set after power-on. In this case, it is safe to issue an endpoint command. Instance 5 of an array of 12."
  default = "0x00000000"
  offset = "0x0000C85C"
  [[register.field]]
    name = "COMMANDPARAM"
    bits = "31:16"
    type = "rw"
    shortdesc = '''Command Parameters or Event Parameters Command Parameters (CommandParam), when this register is written: For Start Transfer command: - [31:16]: StreamID.'''
    longdesc = '''The USB StreamID assigned to this transfer For Start Transfer command applied to an isochronous endpoint - [31:16]: StartMicroFramNum: Indicates the (micro)frame number to which the first TRB applies. For Update Transfer, End Transfer, and Start New Configuration commands - [22:16]: Transfer Resource Index (XferRscIdx). The hardware-assigned transfer resource index for the transfer, which was returned in response to the Start Transfer command. The application software-assigned transfer resource index for a Start New Configuration command. Event Parameters (EventParam), when this register is read. Refer to bits [31:16] in Table 'Device Endpoint-n Events: DEPEVT' of the Databook.'''
  [[register.field]]
    name = "CMDSTATUS"
    bits = "15:12"
    type = "rw"
    shortdesc = '''Command Completion Status (CmdStatus) Additional information about the completion of this command is available in this field.'''
    longdesc = '''The information is in the same format as bits 15:12 of the Endpoint Command Complete event, see 'Device Endpoint-n Events: DEPEVT' table in the Databook.'''
  [[register.field]]
    name = "HIPRI_FORCERM"
    bits = "11"
    type = "rw"
    shortdesc = '''HighPriority/ForceRM (HiPri_ForceRM) - HighPriority: Only valid for Start Transfer command - ForceRM: Only valid for End Transfer command - ClearPendIN: Only valid for Clear Stall command.'''
    longdesc = '''Software sets this bit to clear any pending IN transaction (on that endpoint) stuck at the lower layers when a Clear Stall command is issued.'''
  [[register.field]]
    name = "CMDACT"
    bits = "10"
    type = "rw"
    shortdesc = '''Command Active (CmdAct) Software sets this bit to 1 to enable the device endpoint controller to execute the generic command.'''
    longdesc = '''The device controller sets this bit to 0 when the CmdStatus field is valid and the endpoint is ready to accept another command. This does not imply that all the effects of the previously-issued command have taken place.'''
  [[register.field]]
    name = "RESERVED"
    bits = "9"
    type = "ro"
  [[register.field]]
    name = "CMDIOC"
    bits = "8"
    type = "rw"
    shortdesc = '''CMDIOC Command Interrupt on Complete (CmdIOC) When this bit is set, the device controller issues a generic Endpoint Command Complete event after executing the command.'''
    longdesc = '''Note that this interrupt is mapped to DEPCFG.IntrNum. When the DEPCFG command is executed, the command interrupt on completion goes to the interrupt pointed by the DEPCFG.IntrNum in the current command. Note: This field must not set to 1 if the DCTL.RunStop field is 0.'''
  [[register.field]]
    name = "RESERVED"
    bits = "7:4"
    type = "ro"
  [[register.field]]
    name = "CMDTYP"
    bits = "3:0"
    type = "rw"
    shortdesc = '''Command Type Specifies the type of command the software driver is requesting the core to perform.'''
    longdesc = '''- 00h: Reserved - 01h: Set Endpoint Configuration - -64 or 96-bit Parameter - 02h: Set Endpoint Transfer Resource Configuration - 32-bit Parameter - 03h: Get Endpoint State - No Parameter Needed - 04h: Set Stall - No Parameter Needed - 05h: Clear Stall (see Set Stall) - No Parameter Needed - 06h: Start Transfer - 64-bit Parameter - 07h: Update Transfer - No Parameter Needed - 08h: End Transfer - No Parameter Needed - 09h: Start New Configuration - No Parameter Needed'''
[[register]]
  name = "DEPCMDPAR2_6"
  type = "rw"
  width = 32
  description = "Device Physical Endpoint-n Command Parameter 2 Register (DEPCMDPAR2n) This register indicates the physical endpoint command Parameter 2. It must be programmed before issuing the command. Instance 6 of an array of 12."
  default = "0x00000000"
  offset = "0x0000C860"
  [[register.field]]
    name = "PARAMETER"
    bits = "31:0"
    type = "rw"
[[register]]
  name = "DEPCMDPAR1_6"
  type = "rw"
  width = 32
  description = "Device Physical Endpoint-n Command Parameter 1 Register (DEPCMDPAR1n) Instance 6 of an array of 12."
  default = "0x00000000"
  offset = "0x0000C864"
  [[register.field]]
    name = "PARAMETER"
    bits = "31:0"
    type = "rw"
[[register]]
  name = "DEPCMDPAR0_6"
  type = "rw"
  width = 32
  description = "Device Physical Endpoint-n Command Parameter 0 Register (DEPCMDPAR0n) Instance 6 of an array of 12."
  default = "0x00000000"
  offset = "0x0000C868"
  [[register.field]]
    name = "PARAMETER"
    bits = "31:0"
    type = "rw"
[[register]]
  name = "DEPCMD_6"
  type = "mixed"
  width = 32
  description = "Device Physical Endpoint-n Command Register This register enables software to issue physical endpoint-specific commands. This register contains command, control, and status fields relevant to the current generic command, while the DEPCMDPAR[2:0]n registers provide command parameters and return status information. Several fields (including Command Type) are write-only, so their read values are undefined. After power-on, prior to issuing the first endpoint command, the read value of this register is undefined. In particular, the CmdAct bit may be set after power-on. In this case, it is safe to issue an endpoint command. Instance 6 of an array of 12."
  default = "0x00000000"
  offset = "0x0000C86C"
  [[register.field]]
    name = "COMMANDPARAM"
    bits = "31:16"
    type = "rw"
    shortdesc = '''Command Parameters or Event Parameters Command Parameters (CommandParam), when this register is written: For Start Transfer command: - [31:16]: StreamID.'''
    longdesc = '''The USB StreamID assigned to this transfer For Start Transfer command applied to an isochronous endpoint - [31:16]: StartMicroFramNum: Indicates the (micro)frame number to which the first TRB applies. For Update Transfer, End Transfer, and Start New Configuration commands - [22:16]: Transfer Resource Index (XferRscIdx). The hardware-assigned transfer resource index for the transfer, which was returned in response to the Start Transfer command. The application software-assigned transfer resource index for a Start New Configuration command. Event Parameters (EventParam), when this register is read. Refer to bits [31:16] in Table 'Device Endpoint-n Events: DEPEVT' of the Databook.'''
  [[register.field]]
    name = "CMDSTATUS"
    bits = "15:12"
    type = "rw"
    shortdesc = '''Command Completion Status (CmdStatus) Additional information about the completion of this command is available in this field.'''
    longdesc = '''The information is in the same format as bits 15:12 of the Endpoint Command Complete event, see 'Device Endpoint-n Events: DEPEVT' table in the Databook.'''
  [[register.field]]
    name = "HIPRI_FORCERM"
    bits = "11"
    type = "rw"
    shortdesc = '''HighPriority/ForceRM (HiPri_ForceRM) - HighPriority: Only valid for Start Transfer command - ForceRM: Only valid for End Transfer command - ClearPendIN: Only valid for Clear Stall command.'''
    longdesc = '''Software sets this bit to clear any pending IN transaction (on that endpoint) stuck at the lower layers when a Clear Stall command is issued.'''
  [[register.field]]
    name = "CMDACT"
    bits = "10"
    type = "rw"
    shortdesc = '''Command Active (CmdAct) Software sets this bit to 1 to enable the device endpoint controller to execute the generic command.'''
    longdesc = '''The device controller sets this bit to 0 when the CmdStatus field is valid and the endpoint is ready to accept another command. This does not imply that all the effects of the previously-issued command have taken place.'''
  [[register.field]]
    name = "RESERVED"
    bits = "9"
    type = "ro"
  [[register.field]]
    name = "CMDIOC"
    bits = "8"
    type = "rw"
    shortdesc = '''CMDIOC Command Interrupt on Complete (CmdIOC) When this bit is set, the device controller issues a generic Endpoint Command Complete event after executing the command.'''
    longdesc = '''Note that this interrupt is mapped to DEPCFG.IntrNum. When the DEPCFG command is executed, the command interrupt on completion goes to the interrupt pointed by the DEPCFG.IntrNum in the current command. Note: This field must not set to 1 if the DCTL.RunStop field is 0.'''
  [[register.field]]
    name = "RESERVED"
    bits = "7:4"
    type = "ro"
  [[register.field]]
    name = "CMDTYP"
    bits = "3:0"
    type = "rw"
    shortdesc = '''Command Type Specifies the type of command the software driver is requesting the core to perform.'''
    longdesc = '''- 00h: Reserved - 01h: Set Endpoint Configuration - -64 or 96-bit Parameter - 02h: Set Endpoint Transfer Resource Configuration - 32-bit Parameter - 03h: Get Endpoint State - No Parameter Needed - 04h: Set Stall - No Parameter Needed - 05h: Clear Stall (see Set Stall) - No Parameter Needed - 06h: Start Transfer - 64-bit Parameter - 07h: Update Transfer - No Parameter Needed - 08h: End Transfer - No Parameter Needed - 09h: Start New Configuration - No Parameter Needed'''
[[register]]
  name = "DEPCMDPAR2_7"
  type = "rw"
  width = 32
  description = "Device Physical Endpoint-n Command Parameter 2 Register (DEPCMDPAR2n) This register indicates the physical endpoint command Parameter 2. It must be programmed before issuing the command. Instance 7 of an array of 12."
  default = "0x00000000"
  offset = "0x0000C870"
  [[register.field]]
    name = "PARAMETER"
    bits = "31:0"
    type = "rw"
[[register]]
  name = "DEPCMDPAR1_7"
  type = "rw"
  width = 32
  description = "Device Physical Endpoint-n Command Parameter 1 Register (DEPCMDPAR1n) Instance 7 of an array of 12."
  default = "0x00000000"
  offset = "0x0000C874"
  [[register.field]]
    name = "PARAMETER"
    bits = "31:0"
    type = "rw"
[[register]]
  name = "DEPCMDPAR0_7"
  type = "rw"
  width = 32
  description = "Device Physical Endpoint-n Command Parameter 0 Register (DEPCMDPAR0n) Instance 7 of an array of 12."
  default = "0x00000000"
  offset = "0x0000C878"
  [[register.field]]
    name = "PARAMETER"
    bits = "31:0"
    type = "rw"
[[register]]
  name = "DEPCMD_7"
  type = "mixed"
  width = 32
  description = "Device Physical Endpoint-n Command Register This register enables software to issue physical endpoint-specific commands. This register contains command, control, and status fields relevant to the current generic command, while the DEPCMDPAR[2:0]n registers provide command parameters and return status information. Several fields (including Command Type) are write-only, so their read values are undefined. After power-on, prior to issuing the first endpoint command, the read value of this register is undefined. In particular, the CmdAct bit may be set after power-on. In this case, it is safe to issue an endpoint command. Instance 7 of an array of 12."
  default = "0x00000000"
  offset = "0x0000C87C"
  [[register.field]]
    name = "COMMANDPARAM"
    bits = "31:16"
    type = "rw"
    shortdesc = '''Command Parameters or Event Parameters Command Parameters (CommandParam), when this register is written: For Start Transfer command: - [31:16]: StreamID.'''
    longdesc = '''The USB StreamID assigned to this transfer For Start Transfer command applied to an isochronous endpoint - [31:16]: StartMicroFramNum: Indicates the (micro)frame number to which the first TRB applies. For Update Transfer, End Transfer, and Start New Configuration commands - [22:16]: Transfer Resource Index (XferRscIdx). The hardware-assigned transfer resource index for the transfer, which was returned in response to the Start Transfer command. The application software-assigned transfer resource index for a Start New Configuration command. Event Parameters (EventParam), when this register is read. Refer to bits [31:16] in Table 'Device Endpoint-n Events: DEPEVT' of the Databook.'''
  [[register.field]]
    name = "CMDSTATUS"
    bits = "15:12"
    type = "rw"
    shortdesc = '''Command Completion Status (CmdStatus) Additional information about the completion of this command is available in this field.'''
    longdesc = '''The information is in the same format as bits 15:12 of the Endpoint Command Complete event, see 'Device Endpoint-n Events: DEPEVT' table in the Databook.'''
  [[register.field]]
    name = "HIPRI_FORCERM"
    bits = "11"
    type = "rw"
    shortdesc = '''HighPriority/ForceRM (HiPri_ForceRM) - HighPriority: Only valid for Start Transfer command - ForceRM: Only valid for End Transfer command - ClearPendIN: Only valid for Clear Stall command.'''
    longdesc = '''Software sets this bit to clear any pending IN transaction (on that endpoint) stuck at the lower layers when a Clear Stall command is issued.'''
  [[register.field]]
    name = "CMDACT"
    bits = "10"
    type = "rw"
    shortdesc = '''Command Active (CmdAct) Software sets this bit to 1 to enable the device endpoint controller to execute the generic command.'''
    longdesc = '''The device controller sets this bit to 0 when the CmdStatus field is valid and the endpoint is ready to accept another command. This does not imply that all the effects of the previously-issued command have taken place.'''
  [[register.field]]
    name = "RESERVED"
    bits = "9"
    type = "ro"
  [[register.field]]
    name = "CMDIOC"
    bits = "8"
    type = "rw"
    shortdesc = '''CMDIOC Command Interrupt on Complete (CmdIOC) When this bit is set, the device controller issues a generic Endpoint Command Complete event after executing the command.'''
    longdesc = '''Note that this interrupt is mapped to DEPCFG.IntrNum. When the DEPCFG command is executed, the command interrupt on completion goes to the interrupt pointed by the DEPCFG.IntrNum in the current command. Note: This field must not set to 1 if the DCTL.RunStop field is 0.'''
  [[register.field]]
    name = "RESERVED"
    bits = "7:4"
    type = "ro"
  [[register.field]]
    name = "CMDTYP"
    bits = "3:0"
    type = "rw"
    shortdesc = '''Command Type Specifies the type of command the software driver is requesting the core to perform.'''
    longdesc = '''- 00h: Reserved - 01h: Set Endpoint Configuration - -64 or 96-bit Parameter - 02h: Set Endpoint Transfer Resource Configuration - 32-bit Parameter - 03h: Get Endpoint State - No Parameter Needed - 04h: Set Stall - No Parameter Needed - 05h: Clear Stall (see Set Stall) - No Parameter Needed - 06h: Start Transfer - 64-bit Parameter - 07h: Update Transfer - No Parameter Needed - 08h: End Transfer - No Parameter Needed - 09h: Start New Configuration - No Parameter Needed'''
[[register]]
  name = "DEPCMDPAR2_8"
  type = "rw"
  width = 32
  description = "Device Physical Endpoint-n Command Parameter 2 Register (DEPCMDPAR2n) This register indicates the physical endpoint command Parameter 2. It must be programmed before issuing the command. Instance 8 of an array of 12."
  default = "0x00000000"
  offset = "0x0000C880"
  [[register.field]]
    name = "PARAMETER"
    bits = "31:0"
    type = "rw"
[[register]]
  name = "DEPCMDPAR1_8"
  type = "rw"
  width = 32
  description = "Device Physical Endpoint-n Command Parameter 1 Register (DEPCMDPAR1n) Instance 8 of an array of 12."
  default = "0x00000000"
  offset = "0x0000C884"
  [[register.field]]
    name = "PARAMETER"
    bits = "31:0"
    type = "rw"
[[register]]
  name = "DEPCMDPAR0_8"
  type = "rw"
  width = 32
  description = "Device Physical Endpoint-n Command Parameter 0 Register (DEPCMDPAR0n) Instance 8 of an array of 12."
  default = "0x00000000"
  offset = "0x0000C888"
  [[register.field]]
    name = "PARAMETER"
    bits = "31:0"
    type = "rw"
[[register]]
  name = "DEPCMD_8"
  type = "mixed"
  width = 32
  description = "Device Physical Endpoint-n Command Register This register enables software to issue physical endpoint-specific commands. This register contains command, control, and status fields relevant to the current generic command, while the DEPCMDPAR[2:0]n registers provide command parameters and return status information. Several fields (including Command Type) are write-only, so their read values are undefined. After power-on, prior to issuing the first endpoint command, the read value of this register is undefined. In particular, the CmdAct bit may be set after power-on. In this case, it is safe to issue an endpoint command. Instance 8 of an array of 12."
  default = "0x00000000"
  offset = "0x0000C88C"
  [[register.field]]
    name = "COMMANDPARAM"
    bits = "31:16"
    type = "rw"
    shortdesc = '''Command Parameters or Event Parameters Command Parameters (CommandParam), when this register is written: For Start Transfer command: - [31:16]: StreamID.'''
    longdesc = '''The USB StreamID assigned to this transfer For Start Transfer command applied to an isochronous endpoint - [31:16]: StartMicroFramNum: Indicates the (micro)frame number to which the first TRB applies. For Update Transfer, End Transfer, and Start New Configuration commands - [22:16]: Transfer Resource Index (XferRscIdx). The hardware-assigned transfer resource index for the transfer, which was returned in response to the Start Transfer command. The application software-assigned transfer resource index for a Start New Configuration command. Event Parameters (EventParam), when this register is read. Refer to bits [31:16] in Table 'Device Endpoint-n Events: DEPEVT' of the Databook.'''
  [[register.field]]
    name = "CMDSTATUS"
    bits = "15:12"
    type = "rw"
    shortdesc = '''Command Completion Status (CmdStatus) Additional information about the completion of this command is available in this field.'''
    longdesc = '''The information is in the same format as bits 15:12 of the Endpoint Command Complete event, see 'Device Endpoint-n Events: DEPEVT' table in the Databook.'''
  [[register.field]]
    name = "HIPRI_FORCERM"
    bits = "11"
    type = "rw"
    shortdesc = '''HighPriority/ForceRM (HiPri_ForceRM) - HighPriority: Only valid for Start Transfer command - ForceRM: Only valid for End Transfer command - ClearPendIN: Only valid for Clear Stall command.'''
    longdesc = '''Software sets this bit to clear any pending IN transaction (on that endpoint) stuck at the lower layers when a Clear Stall command is issued.'''
  [[register.field]]
    name = "CMDACT"
    bits = "10"
    type = "rw"
    shortdesc = '''Command Active (CmdAct) Software sets this bit to 1 to enable the device endpoint controller to execute the generic command.'''
    longdesc = '''The device controller sets this bit to 0 when the CmdStatus field is valid and the endpoint is ready to accept another command. This does not imply that all the effects of the previously-issued command have taken place.'''
  [[register.field]]
    name = "RESERVED"
    bits = "9"
    type = "ro"
  [[register.field]]
    name = "CMDIOC"
    bits = "8"
    type = "rw"
    shortdesc = '''CMDIOC Command Interrupt on Complete (CmdIOC) When this bit is set, the device controller issues a generic Endpoint Command Complete event after executing the command.'''
    longdesc = '''Note that this interrupt is mapped to DEPCFG.IntrNum. When the DEPCFG command is executed, the command interrupt on completion goes to the interrupt pointed by the DEPCFG.IntrNum in the current command. Note: This field must not set to 1 if the DCTL.RunStop field is 0.'''
  [[register.field]]
    name = "RESERVED"
    bits = "7:4"
    type = "ro"
  [[register.field]]
    name = "CMDTYP"
    bits = "3:0"
    type = "rw"
    shortdesc = '''Command Type Specifies the type of command the software driver is requesting the core to perform.'''
    longdesc = '''- 00h: Reserved - 01h: Set Endpoint Configuration - -64 or 96-bit Parameter - 02h: Set Endpoint Transfer Resource Configuration - 32-bit Parameter - 03h: Get Endpoint State - No Parameter Needed - 04h: Set Stall - No Parameter Needed - 05h: Clear Stall (see Set Stall) - No Parameter Needed - 06h: Start Transfer - 64-bit Parameter - 07h: Update Transfer - No Parameter Needed - 08h: End Transfer - No Parameter Needed - 09h: Start New Configuration - No Parameter Needed'''
[[register]]
  name = "DEPCMDPAR2_9"
  type = "rw"
  width = 32
  description = "Device Physical Endpoint-n Command Parameter 2 Register (DEPCMDPAR2n) This register indicates the physical endpoint command Parameter 2. It must be programmed before issuing the command. Instance 9 of an array of 12."
  default = "0x00000000"
  offset = "0x0000C890"
  [[register.field]]
    name = "PARAMETER"
    bits = "31:0"
    type = "rw"
[[register]]
  name = "DEPCMDPAR1_9"
  type = "rw"
  width = 32
  description = "Device Physical Endpoint-n Command Parameter 1 Register (DEPCMDPAR1n) Instance 9 of an array of 12."
  default = "0x00000000"
  offset = "0x0000C894"
  [[register.field]]
    name = "PARAMETER"
    bits = "31:0"
    type = "rw"
[[register]]
  name = "DEPCMDPAR0_9"
  type = "rw"
  width = 32
  description = "Device Physical Endpoint-n Command Parameter 0 Register (DEPCMDPAR0n) Instance 9 of an array of 12."
  default = "0x00000000"
  offset = "0x0000C898"
  [[register.field]]
    name = "PARAMETER"
    bits = "31:0"
    type = "rw"
[[register]]
  name = "DEPCMD_9"
  type = "mixed"
  width = 32
  description = "Device Physical Endpoint-n Command Register This register enables software to issue physical endpoint-specific commands. This register contains command, control, and status fields relevant to the current generic command, while the DEPCMDPAR[2:0]n registers provide command parameters and return status information. Several fields (including Command Type) are write-only, so their read values are undefined. After power-on, prior to issuing the first endpoint command, the read value of this register is undefined. In particular, the CmdAct bit may be set after power-on. In this case, it is safe to issue an endpoint command. Instance 9 of an array of 12."
  default = "0x00000000"
  offset = "0x0000C89C"
  [[register.field]]
    name = "COMMANDPARAM"
    bits = "31:16"
    type = "rw"
    shortdesc = '''Command Parameters or Event Parameters Command Parameters (CommandParam), when this register is written: For Start Transfer command: - [31:16]: StreamID.'''
    longdesc = '''The USB StreamID assigned to this transfer For Start Transfer command applied to an isochronous endpoint - [31:16]: StartMicroFramNum: Indicates the (micro)frame number to which the first TRB applies. For Update Transfer, End Transfer, and Start New Configuration commands - [22:16]: Transfer Resource Index (XferRscIdx). The hardware-assigned transfer resource index for the transfer, which was returned in response to the Start Transfer command. The application software-assigned transfer resource index for a Start New Configuration command. Event Parameters (EventParam), when this register is read. Refer to bits [31:16] in Table 'Device Endpoint-n Events: DEPEVT' of the Databook.'''
  [[register.field]]
    name = "CMDSTATUS"
    bits = "15:12"
    type = "rw"
    shortdesc = '''Command Completion Status (CmdStatus) Additional information about the completion of this command is available in this field.'''
    longdesc = '''The information is in the same format as bits 15:12 of the Endpoint Command Complete event, see 'Device Endpoint-n Events: DEPEVT' table in the Databook.'''
  [[register.field]]
    name = "HIPRI_FORCERM"
    bits = "11"
    type = "rw"
    shortdesc = '''HighPriority/ForceRM (HiPri_ForceRM) - HighPriority: Only valid for Start Transfer command - ForceRM: Only valid for End Transfer command - ClearPendIN: Only valid for Clear Stall command.'''
    longdesc = '''Software sets this bit to clear any pending IN transaction (on that endpoint) stuck at the lower layers when a Clear Stall command is issued.'''
  [[register.field]]
    name = "CMDACT"
    bits = "10"
    type = "rw"
    shortdesc = '''Command Active (CmdAct) Software sets this bit to 1 to enable the device endpoint controller to execute the generic command.'''
    longdesc = '''The device controller sets this bit to 0 when the CmdStatus field is valid and the endpoint is ready to accept another command. This does not imply that all the effects of the previously-issued command have taken place.'''
  [[register.field]]
    name = "RESERVED"
    bits = "9"
    type = "ro"
  [[register.field]]
    name = "CMDIOC"
    bits = "8"
    type = "rw"
    shortdesc = '''CMDIOC Command Interrupt on Complete (CmdIOC) When this bit is set, the device controller issues a generic Endpoint Command Complete event after executing the command.'''
    longdesc = '''Note that this interrupt is mapped to DEPCFG.IntrNum. When the DEPCFG command is executed, the command interrupt on completion goes to the interrupt pointed by the DEPCFG.IntrNum in the current command. Note: This field must not set to 1 if the DCTL.RunStop field is 0.'''
  [[register.field]]
    name = "RESERVED"
    bits = "7:4"
    type = "ro"
  [[register.field]]
    name = "CMDTYP"
    bits = "3:0"
    type = "rw"
    shortdesc = '''Command Type Specifies the type of command the software driver is requesting the core to perform.'''
    longdesc = '''- 00h: Reserved - 01h: Set Endpoint Configuration - -64 or 96-bit Parameter - 02h: Set Endpoint Transfer Resource Configuration - 32-bit Parameter - 03h: Get Endpoint State - No Parameter Needed - 04h: Set Stall - No Parameter Needed - 05h: Clear Stall (see Set Stall) - No Parameter Needed - 06h: Start Transfer - 64-bit Parameter - 07h: Update Transfer - No Parameter Needed - 08h: End Transfer - No Parameter Needed - 09h: Start New Configuration - No Parameter Needed'''
[[register]]
  name = "DEPCMDPAR2_10"
  type = "rw"
  width = 32
  description = "Device Physical Endpoint-n Command Parameter 2 Register (DEPCMDPAR2n) This register indicates the physical endpoint command Parameter 2. It must be programmed before issuing the command. Instance 10 of an array of 12."
  default = "0x00000000"
  offset = "0x0000C8A0"
  [[register.field]]
    name = "PARAMETER"
    bits = "31:0"
    type = "rw"
[[register]]
  name = "DEPCMDPAR1_10"
  type = "rw"
  width = 32
  description = "Device Physical Endpoint-n Command Parameter 1 Register (DEPCMDPAR1n) Instance 10 of an array of 12."
  default = "0x00000000"
  offset = "0x0000C8A4"
  [[register.field]]
    name = "PARAMETER"
    bits = "31:0"
    type = "rw"
[[register]]
  name = "DEPCMDPAR0_10"
  type = "rw"
  width = 32
  description = "Device Physical Endpoint-n Command Parameter 0 Register (DEPCMDPAR0n) Instance 10 of an array of 12."
  default = "0x00000000"
  offset = "0x0000C8A8"
  [[register.field]]
    name = "PARAMETER"
    bits = "31:0"
    type = "rw"
[[register]]
  name = "DEPCMD_10"
  type = "mixed"
  width = 32
  description = "Device Physical Endpoint-n Command Register This register enables software to issue physical endpoint-specific commands. This register contains command, control, and status fields relevant to the current generic command, while the DEPCMDPAR[2:0]n registers provide command parameters and return status information. Several fields (including Command Type) are write-only, so their read values are undefined. After power-on, prior to issuing the first endpoint command, the read value of this register is undefined. In particular, the CmdAct bit may be set after power-on. In this case, it is safe to issue an endpoint command. Instance 10 of an array of 12."
  default = "0x00000000"
  offset = "0x0000C8AC"
  [[register.field]]
    name = "COMMANDPARAM"
    bits = "31:16"
    type = "rw"
    shortdesc = '''Command Parameters or Event Parameters Command Parameters (CommandParam), when this register is written: For Start Transfer command: - [31:16]: StreamID.'''
    longdesc = '''The USB StreamID assigned to this transfer For Start Transfer command applied to an isochronous endpoint - [31:16]: StartMicroFramNum: Indicates the (micro)frame number to which the first TRB applies. For Update Transfer, End Transfer, and Start New Configuration commands - [22:16]: Transfer Resource Index (XferRscIdx). The hardware-assigned transfer resource index for the transfer, which was returned in response to the Start Transfer command. The application software-assigned transfer resource index for a Start New Configuration command. Event Parameters (EventParam), when this register is read. Refer to bits [31:16] in Table 'Device Endpoint-n Events: DEPEVT' of the Databook.'''
  [[register.field]]
    name = "CMDSTATUS"
    bits = "15:12"
    type = "rw"
    shortdesc = '''Command Completion Status (CmdStatus) Additional information about the completion of this command is available in this field.'''
    longdesc = '''The information is in the same format as bits 15:12 of the Endpoint Command Complete event, see 'Device Endpoint-n Events: DEPEVT' table in the Databook.'''
  [[register.field]]
    name = "HIPRI_FORCERM"
    bits = "11"
    type = "rw"
    shortdesc = '''HighPriority/ForceRM (HiPri_ForceRM) - HighPriority: Only valid for Start Transfer command - ForceRM: Only valid for End Transfer command - ClearPendIN: Only valid for Clear Stall command.'''
    longdesc = '''Software sets this bit to clear any pending IN transaction (on that endpoint) stuck at the lower layers when a Clear Stall command is issued.'''
  [[register.field]]
    name = "CMDACT"
    bits = "10"
    type = "rw"
    shortdesc = '''Command Active (CmdAct) Software sets this bit to 1 to enable the device endpoint controller to execute the generic command.'''
    longdesc = '''The device controller sets this bit to 0 when the CmdStatus field is valid and the endpoint is ready to accept another command. This does not imply that all the effects of the previously-issued command have taken place.'''
  [[register.field]]
    name = "RESERVED"
    bits = "9"
    type = "ro"
  [[register.field]]
    name = "CMDIOC"
    bits = "8"
    type = "rw"
    shortdesc = '''CMDIOC Command Interrupt on Complete (CmdIOC) When this bit is set, the device controller issues a generic Endpoint Command Complete event after executing the command.'''
    longdesc = '''Note that this interrupt is mapped to DEPCFG.IntrNum. When the DEPCFG command is executed, the command interrupt on completion goes to the interrupt pointed by the DEPCFG.IntrNum in the current command. Note: This field must not set to 1 if the DCTL.RunStop field is 0.'''
  [[register.field]]
    name = "RESERVED"
    bits = "7:4"
    type = "ro"
  [[register.field]]
    name = "CMDTYP"
    bits = "3:0"
    type = "rw"
    shortdesc = '''Command Type Specifies the type of command the software driver is requesting the core to perform.'''
    longdesc = '''- 00h: Reserved - 01h: Set Endpoint Configuration - -64 or 96-bit Parameter - 02h: Set Endpoint Transfer Resource Configuration - 32-bit Parameter - 03h: Get Endpoint State - No Parameter Needed - 04h: Set Stall - No Parameter Needed - 05h: Clear Stall (see Set Stall) - No Parameter Needed - 06h: Start Transfer - 64-bit Parameter - 07h: Update Transfer - No Parameter Needed - 08h: End Transfer - No Parameter Needed - 09h: Start New Configuration - No Parameter Needed'''
[[register]]
  name = "DEPCMDPAR2_11"
  type = "rw"
  width = 32
  description = "Device Physical Endpoint-n Command Parameter 2 Register (DEPCMDPAR2n) This register indicates the physical endpoint command Parameter 2. It must be programmed before issuing the command. Instance 11 of an array of 12."
  default = "0x00000000"
  offset = "0x0000C8B0"
  [[register.field]]
    name = "PARAMETER"
    bits = "31:0"
    type = "rw"
[[register]]
  name = "DEPCMDPAR1_11"
  type = "rw"
  width = 32
  description = "Device Physical Endpoint-n Command Parameter 1 Register (DEPCMDPAR1n) Instance 11 of an array of 12."
  default = "0x00000000"
  offset = "0x0000C8B4"
  [[register.field]]
    name = "PARAMETER"
    bits = "31:0"
    type = "rw"
[[register]]
  name = "DEPCMDPAR0_11"
  type = "rw"
  width = 32
  description = "Device Physical Endpoint-n Command Parameter 0 Register (DEPCMDPAR0n) Instance 11 of an array of 12."
  default = "0x00000000"
  offset = "0x0000C8B8"
  [[register.field]]
    name = "PARAMETER"
    bits = "31:0"
    type = "rw"
[[register]]
  name = "DEPCMD_11"
  type = "mixed"
  width = 32
  description = "Device Physical Endpoint-n Command Register This register enables software to issue physical endpoint-specific commands. This register contains command, control, and status fields relevant to the current generic command, while the DEPCMDPAR[2:0]n registers provide command parameters and return status information. Several fields (including Command Type) are write-only, so their read values are undefined. After power-on, prior to issuing the first endpoint command, the read value of this register is undefined. In particular, the CmdAct bit may be set after power-on. In this case, it is safe to issue an endpoint command. Instance 11 of an array of 12."
  default = "0x00000000"
  offset = "0x0000C8BC"
  [[register.field]]
    name = "COMMANDPARAM"
    bits = "31:16"
    type = "rw"
    shortdesc = '''Command Parameters or Event Parameters Command Parameters (CommandParam), when this register is written: For Start Transfer command: - [31:16]: StreamID.'''
    longdesc = '''The USB StreamID assigned to this transfer For Start Transfer command applied to an isochronous endpoint - [31:16]: StartMicroFramNum: Indicates the (micro)frame number to which the first TRB applies. For Update Transfer, End Transfer, and Start New Configuration commands - [22:16]: Transfer Resource Index (XferRscIdx). The hardware-assigned transfer resource index for the transfer, which was returned in response to the Start Transfer command. The application software-assigned transfer resource index for a Start New Configuration command. Event Parameters (EventParam), when this register is read. Refer to bits [31:16] in Table 'Device Endpoint-n Events: DEPEVT' of the Databook.'''
  [[register.field]]
    name = "CMDSTATUS"
    bits = "15:12"
    type = "rw"
    shortdesc = '''Command Completion Status (CmdStatus) Additional information about the completion of this command is available in this field.'''
    longdesc = '''The information is in the same format as bits 15:12 of the Endpoint Command Complete event, see 'Device Endpoint-n Events: DEPEVT' table in the Databook.'''
  [[register.field]]
    name = "HIPRI_FORCERM"
    bits = "11"
    type = "rw"
    shortdesc = '''HighPriority/ForceRM (HiPri_ForceRM) - HighPriority: Only valid for Start Transfer command - ForceRM: Only valid for End Transfer command - ClearPendIN: Only valid for Clear Stall command.'''
    longdesc = '''Software sets this bit to clear any pending IN transaction (on that endpoint) stuck at the lower layers when a Clear Stall command is issued.'''
  [[register.field]]
    name = "CMDACT"
    bits = "10"
    type = "rw"
    shortdesc = '''Command Active (CmdAct) Software sets this bit to 1 to enable the device endpoint controller to execute the generic command.'''
    longdesc = '''The device controller sets this bit to 0 when the CmdStatus field is valid and the endpoint is ready to accept another command. This does not imply that all the effects of the previously-issued command have taken place.'''
  [[register.field]]
    name = "RESERVED"
    bits = "9"
    type = "ro"
  [[register.field]]
    name = "CMDIOC"
    bits = "8"
    type = "rw"
    shortdesc = '''CMDIOC Command Interrupt on Complete (CmdIOC) When this bit is set, the device controller issues a generic Endpoint Command Complete event after executing the command.'''
    longdesc = '''Note that this interrupt is mapped to DEPCFG.IntrNum. When the DEPCFG command is executed, the command interrupt on completion goes to the interrupt pointed by the DEPCFG.IntrNum in the current command. Note: This field must not set to 1 if the DCTL.RunStop field is 0.'''
  [[register.field]]
    name = "RESERVED"
    bits = "7:4"
    type = "ro"
  [[register.field]]
    name = "CMDTYP"
    bits = "3:0"
    type = "rw"
    shortdesc = '''Command Type Specifies the type of command the software driver is requesting the core to perform.'''
    longdesc = '''- 00h: Reserved - 01h: Set Endpoint Configuration - -64 or 96-bit Parameter - 02h: Set Endpoint Transfer Resource Configuration - 32-bit Parameter - 03h: Get Endpoint State - No Parameter Needed - 04h: Set Stall - No Parameter Needed - 05h: Clear Stall (see Set Stall) - No Parameter Needed - 06h: Start Transfer - 64-bit Parameter - 07h: Update Transfer - No Parameter Needed - 08h: End Transfer - No Parameter Needed - 09h: Start New Configuration - No Parameter Needed'''
[[register]]
  name = "OCFG"
  type = "mixed"
  width = 32
  description = "OTG Configuration Register This register specifies the HNP and SRP capability of the DWC_usb3 core."
  default = "0x00000000"
  offset = "0x0000CC00"
  [[register.field]]
    name = "RESERVED"
    bits = "31:6"
    type = "ro"
  [[register.field]]
    name = "DISPRTPWRCUTOFF"
    bits = "5"
    type = "rw"
    shortdesc = '''OTG Disable Port Power Cut Off (DisPrtPwrCutoff) - 0: The core automatically turns off the VBUS by clearing the OCTL.'''
    longdesc = '''PrtPwrCtl after A_WAIT_BCON Timeout whenever the port is disconnected in disconnected state. If Hibernation is enabled and when a hibernation request is received in disconnected state, the core switches off VBUS instantly by clearing the OCTL.PrtPwrCtl. - 1: The core maintains VBUS ON even after A_WAIT_BCON Timeout when port is in disconnected state. The core is in a A_WAIT_BCON state continuously waiting for a Connect. If hibernation is enabled and when hibernation request is received in disconnected state, the core maintains VBUS ON and continues to drive VBUS even in hibernation.'''
  [[register.field]]
    name = "OTGHIBDISMASK"
    bits = "4"
    type = "rw"
    shortdesc = '''OTG Hibernation Disable Mask.'''
    longdesc = '''- 0 - Any change in PHY input signals relevant to OTG (ID, Vbus-valid, B-Valid) are masked from generating a corresponding event when the core receives Hibernation Save request from Host or Device Driver. The change in signals is masked until the Host or Device Run/Stop is programmed to 1. - 1 - The PHY input signals are not masked even after the core receives the Hibernation Save request from Host or Device Driver. For normal functionality, this bit must be 1'b0.'''
  [[register.field]]
    name = "OTGSFTRSTMSK"
    bits = "3"
    type = "rw"
    shortdesc = '''OTG Soft Reset Mask.'''
    longdesc = '''This bit is used to mask specific soft resets from affecting the OTG functionality of the core. When set, the xHCI-based USBCMD.HCRST in host mode and DCTL.CSftRst in device mode is masked from affecting reset signal outputs sent to the PHY, the OTG FSM logic of the core and also the resets to the VBUS filters inside the core. - 1'b0: The xHCI-based USBCMD.HCRST and DCTL.CSftRst resets the OTG logic of the core. - 1'b1: The xHCI-based USBCMD.HCRST and DCTL.CSftRst is masked from the OTG logic of the core. This bit can be programmed to allow existing xHCI flows (with USBCMD.HCRST programming) to function in OTG scenarios without any software changes. This bit must be programmed only when GCTL.PrtCapDir = 2'b11. Otherwise it must be set at 1'b0. Note: When using the core for OTG2 or OTG3 applications, it is not recommended to program USBCMD.HCRST during role switch.'''
  [[register.field]]
    name = "OTG_VERSION"
    bits = "2"
    type = "rw"
  [[register.field]]
    name = "HNPCAP"
    bits = "1"
    type = "rw"
    shortdesc = '''RSP/HNP Capability.'''
    longdesc = '''The terminology RSP is used when the core is operating in SS mode, and HNP is used when the core is operating in non-SS mode. The application uses this bit to control the DWC_usb3 core's RSP/HNP capabilities. - 1'b0: RSP/HNP capability is not enabled. - 1'b1: RSP/HNP capability is enabled. Note: This bit is writable only if RSP/HNP mode is specified for Mode of Operation in coreConsultant, that is when DWC_USB3_EN_OTG != 0 and DWC_USB3_MODE = DRD. If RSP/HNP mode is not specified, this bit is Read Only, and is set to 1'b0.'''
  [[register.field]]
    name = "SRPCAP"
    bits = "0"
    type = "rw"
    shortdesc = '''SRP Capability.'''
    longdesc = '''The application uses this bit to control the DWC_usb3 core's SRP capabilities. - 1'b0: SRP capability is not enabled. - 1'b1: SRP capability is enabled. If this bit is not set for B-device, it cannot request the connected A-device (host) to activate Vbus and start a session. If this bit is not set for A-device, it cannot detect the SRP from B-device (device) to activate Vbus and start a session. Note: This bit is writable only if OTG is enabled in coreConsultant (DWC_USB3_EN_OTG != 0). If OTG is not enabled, then this bit is Read Only and is set to 1'b0.'''
[[register]]
  name = "OCTL"
  type = "mixed"
  width = 32
  description = "OTG Control Register The OTG Control register controls the behavior of the OTG function of the core."
  default = "0x00000000"
  offset = "0x0000CC04"
  [[register.field]]
    name = "RESERVED"
    bits = "31:8"
    type = "ro"
  [[register.field]]
    name = "OTG3_GOERR"
    bits = "7"
    type = "rw"
    shortdesc = '''OTG3_GOERR When set, this instructs the core's LTSSM to go to the error state during OTG 3.'''
    longdesc = '''0 RSP. The software must set this bit when TRSP_ACK_ERR, TRSP_CNF_ERR, or TRSP_WRST_ERR timeout occurs. This bit is self-cleared by the core when the LTSSM moves to the error state.'''
  [[register.field]]
    name = "PERIMODE"
    bits = "6"
    type = "rw"
    shortdesc = '''Peripheral Mode The application uses this bit to program the core to work as a peripheral or as a host.'''
    longdesc = '''- 1'b0: The OTG device acts as a host - 1'b1: The OTG device acts as a peripheral'''
  [[register.field]]
    name = "PRTPWRCTL"
    bits = "5"
    type = "rw"
    shortdesc = '''Port Power Control Application sets this bit to initiate Vbus drive when it is an A-device.'''
    longdesc = '''The application must clear this bit only if it wants to switch off the Vbus to B-device. The core clears this bit in the following conditions: Transition from any state to A-IDLE state defined in OTG2.0 state machine: - When AIDL_BDIS_TOUT occurs in A_SUSPEND; - When A_WAIT_BCON_TOUT occurs in A_WAIT_BCON; - Transition to any B- state defined in OTG2.0 state machine;'''
  [[register.field]]
    name = "HNPREQ"
    bits = "4"
    type = "rw"
    shortdesc = '''HNP Request - 1'b0: No HNP request - 1'b1: HNP request The application sets this bit to initiate a HNP request to the connected USB host.'''
    longdesc = '''The application clears this bit by writing a 1'b0 when either of the following is detected: - OEVT.OTGBDevBHostEndEvnt - OEVT.OTGBDevVBusChngEvnt'''
  [[register.field]]
    name = "SESREQ"
    bits = "3"
    type = "wo"
    shortdesc = '''Session Request - 1'b0: No session request - 1'b1: Session request The application sets this bit to initiate a session request on the USB.'''
    longdesc = '''Writing 1'b1 to this field triggers the core to send SRP (data line pulsing) on the PHY interface. In the absence of OEVT.OTGBDevSessVldDetEvnt after a session request, the application must wait for atleast TB_SRP_FAIL time (6 secs) before initiating another session request. This field returns 1'b0 when read.'''
  [[register.field]]
    name = "TERMSELDLPULSE"
    bits = "2"
    type = "rw"
    shortdesc = '''TermSel DLine Pulsing Selection This bit selects utmi_termselect to drive data line pulse during SRP.'''
    longdesc = '''- 1'b0: Data line pulsing using utmi_txvalid (default). - 1'b1: Data line pulsing using utmi_termsel.'''
  [[register.field]]
    name = "DEVSETHNPEN"
    bits = "1"
    type = "rw"
    shortdesc = '''Device Set RSP/HNP Enable - 1'b0: RSP/HNP is not enabled in the application.'''
    longdesc = '''- 1'b1: RSP/HNP is enabled in the application. The application sets this bit in the following scenario: - In HS/FS mode, when it successfully receives a SetFeature.SetHNPEnable command from the connected USB host. - In SS mode, when it has sent a b3_ntf_hst_rel to the A-device, or the A-device has sent an a3_ntf_host_req. Note: The terminology RSP is used when the core is operating in SS mode, and HNP is used when the core is operating in non-SS mode.'''
  [[register.field]]
    name = "HSTSETHNPEN"
    bits = "0"
    type = "rw"
    shortdesc = '''Host Set RSP/HNP Enable.'''
    longdesc = '''- 1'b0: Host Set RSP/HNP is not enabled; - 1'b1: Host Set RSP/HNP is enabled; The application sets this bit in the following scenario: - In HS/FS mode, when it has successfully enabled HNP (using the SetFeature.SetHNPEnable command) from the connected device. - In SS mode, when it has successfully enabled the b3_rsp_enable feature in RSP-capable Device using SetFeature command while operating as an A-Host, or when it has received a b3_ntf_hst_rel through the SetFeature command while operating as A-peripheral. Note: The terminology RSP is used when the core is operating in SS mode, and HNP is used when the core is operating in non-SS mode.'''
[[register]]
  name = "OEVT"
  type = "mixed"
  width = 32
  description = "OTG Events Register Any event set in this register will cause otg_interrupt signal to go high. Writing 1'b1 to the event information bit in this register clears the register bit and the associated interrupt. The otg_interrupt signal goes low when there are no more pending OTG events."
  default = "0x00000000"
  offset = "0x0000CC08"
  [[register.field]]
    name = "DEVICEMODE"
    bits = "31"
    type = "ro"
  [[register.field]]
    name = "RESERVED"
    bits = "30:28"
    type = "ro"
  [[register.field]]
    name = "OTGXHCIRUNSTPSETEVNT"
    bits = "27"
    type = "wtc"
    shortdesc = '''OTG Host Run Stop Set Event This event is set when the Host Driver programs the USBCMD.'''
    longdesc = '''Run/Stop to 1'b1. Note: - During Hibernation Exit, upon receiving this event, the OTG Driver can start register accesses to the core. - This bit is applicable for OTG 2.0 and OTG 3.0 modes of operation.'''
  [[register.field]]
    name = "OTGDEVRUNSTPSETEVNT"
    bits = "26"
    type = "wtc"
    shortdesc = '''OTG Device Run Stop Set Event This event is set when the Device Driver programs the DCTL.'''
    longdesc = '''Run/Stop to 1'b1. Note: During Hibernation Exit, upon receiving this event, the OTG Driver can start register accesses to the core.'''
  [[register.field]]
    name = "OTGHIBENTRYEVNT"
    bits = "25"
    type = "wtc"
    shortdesc = '''OTG Hibernation Entry Event: - A-Device mode: This event is set when there is hibernation save request from the Host Driver by programming USBCMD.'''
    longdesc = '''CSS bit to 1 when USBCMD.RunStp is 0. - B-Device mode: This event is set when there the Device Driver by programming DCTL.RunStp bit to 0. When this event is generated, the OTG Driver must disable all register accesses to the core.'''
  [[register.field]]
    name = "OTGCONIDSTSCHNGEVNT"
    bits = "24"
    type = "wtc"
    shortdesc = '''Connector ID Status Change Event Set in both A-Dev/B-Dev Mode.'''
    longdesc = '''This event is generated when there is a change in connector ID status. When this bit is set, OEVT.OTGConIDStsChngEvnt is enabled. If not, the event is disabled.'''
  [[register.field]]
    name = "HRRCONFNOTIFEVNT"
    bits = "23"
    type = "wtc"
    shortdesc = '''Host Role Request Confirm Notifier Event The core sets this bit after receiving a Host Role Request Device Notification TP with Confirm field set while operating as either an A-host or a B-host.'''
    longdesc = '''Note: - This bit is applicable only when operating in SS mode. - This bit is applicable only for OTG 3.0 mode of operation.'''
  [[register.field]]
    name = "HRRINITNOTIFEVNT"
    bits = "22"
    type = "wtc"
  [[register.field]]
    name = "OTGADEVIDLEEVNT"
    bits = "21"
    type = "wtc"
    shortdesc = '''A-device A-IDLE Event Set in A-device Mode Only.'''
    longdesc = '''The event is generated when A-device enters A-IDLE state. This event is set when the OTG 2.0 FSM of the core enters A-IDLE state from any other OTG state. A-device A-IDLE Event When this bit is set, OEVT.OTGADevIdleEvnt is enabled. If not, the event is disabled.'''
  [[register.field]]
    name = "OTGADEVBHOSTENDEVNT"
    bits = "20"
    type = "wtc"
    shortdesc = '''A-device B-Host End Event Set in A-device Mode Only.'''
    longdesc = '''The event is generated when B-device has completed its host role. Note: This bit is applicable for OTG 2.0 and OTG 3.0 modes of operation. When this bit is set, OEVT.OTGADevBHostEndEvnt is enabled. If not, the event is disabled.'''
  [[register.field]]
    name = "OTGADEVHOSTEVNT"
    bits = "19"
    type = "wtc"
    shortdesc = '''A-device host event Set in A-device Mode Only.'''
    longdesc = '''This event is generated when A-device enters host role. In HS/FS mode, it occurs after the initial connect to a B-device as A-host as well as when there is a role change from A-peripheral to A-host. Note: This bit is applicable only for OTG 2.0 mode of operation.'''
  [[register.field]]
    name = "OTGADEVHNPCHNGEVNT"
    bits = "18"
    type = "wtc"
    shortdesc = '''A-Dev HNP Change Event Set in A-device Mode Only.'''
    longdesc = '''The event is generated when there is an HNP attempt. Note: This bit is applicable only for OTG 2.0 mode of operation. A-Dev HNP Change EventEn (OTGADevHNPChngEvntEn) When this bit is set, OEVT.OTGADevHNPChngEvnt is enabled. If not, the event is disabled'''
  [[register.field]]
    name = "OTGADEVSRPDETEVNT"
    bits = "17"
    type = "wtc"
    shortdesc = '''SRP Detect Event Set in A-device Mode Only.'''
    longdesc = '''This event is asserted when a session request from the B-device is detected via SRP. Note: This bit is applicable for OTG 2.0 and OTG 3.0 modes of operation. A-Dev HNP Change EventEn (OTGADevHNPChngEvntEn) When this bit is set, OEVT.OTGADevHNPChngEvnt is enabled. If not, the event is disabled.'''
  [[register.field]]
    name = "OTGADEVSESSENDDETEVNT"
    bits = "16"
    type = "wtc"
    shortdesc = '''Session End Detected Event Set in A-device Mode Only.'''
    longdesc = '''This event is asserted when the utmiotg_vbusvalid signal goes low indicating the end of a session. Note: This bit is applicable for OTG 2.0 and OTG 3.0 modes of operation. When this bit is set, OEVT.OTGADevSessEndEvnt is enabled. If not, the event is disabled.'''
  [[register.field]]
    name = "RESERVED"
    bits = "15:12"
    type = "ro"
  [[register.field]]
    name = "OTGBDEVBHOSTENDEVNT"
    bits = "11"
    type = "wtc"
    shortdesc = '''B-Device B-Host End Event Set in B-device Mode Only.'''
    longdesc = '''This event is generated when B-device has completed its host role. Note: This bit is applicable for OTG 2.0 and OTG 3.0 modes of operation. When this bit is set, OEVT.OTGBDevHostEndEvnt is enabled. If not, the event is disabled.'''
  [[register.field]]
    name = "OTGBDEVHNPCHNGEVNT"
    bits = "10"
    type = "wtc"
    shortdesc = '''B-Dev HNP Change Event: Set in B-Device Mode only.'''
    longdesc = '''This event is generated when there is a Success or Failure of an HNP attempt. Note: This bit is applicable for OTG 2.0 and OTG 3.0 modes of operation. When this bit is set, OEVT.OTGBDevHNPChngEvnt is enabled. If not, the event is disabled.'''
  [[register.field]]
    name = "OTGBDEVSESSVLDDETEVNT"
    bits = "9"
    type = "wtc"
    shortdesc = '''Session Valid Detected Event Set in B-device Mode Only.'''
    longdesc = '''This event is asserted when there is a valid Vbus from A-device and B-device succeeds in starting a session. Note: This bit is applicable for OTG 2.0 and OTG 3.0 modes of operation.'''
  [[register.field]]
    name = "OTGBDEVVBUSCHNGEVNT"
    bits = "8"
    type = "wtc"
    shortdesc = '''Vbus Change Event Set in B-device Mode Only.'''
    longdesc = '''This event is asserted when the utmisrp_bvalid signal goes low (indicating the end of a session), or goes high. Note: This bit is applicable for OTG 2.0 and OTG 3.0 modes of operation. When this bit is set, OEVT.OTGBDevVBUSChngEvnt is enabled. If not, the event is disabled.'''
  [[register.field]]
    name = "RESERVED"
    bits = "7:4"
    type = "ro"
  [[register.field]]
    name = "BSESVLD"
    bits = "3"
    type = "ro"
    shortdesc = '''Indicates the Device mode transceiver status.'''
    longdesc = '''Indicates the Device mode transceiver status. The core updates this bit when: OEVTEN.OTGBDevVBUSChngEvnt is set. - 1'b0: B-session is not valid - 1'b1: B-session is valid Note: This bit is applicable for OTG 2.0 and OTG 3.0 modes of operation.'''
  [[register.field]]
    name = "HSTNEGSTS"
    bits = "2"
    type = "ro"
    shortdesc = '''Host Negotiation Status The core updates this bit when any of the following bits is set: - OEVTEN.'''
    longdesc = '''OTGADevHNPChngEvnt - OEVTEN.OTGBDevHNPChngEvnt This bit indicates Host Negotiation Success or Failure. 1'b0: Host negotiation failure. - In A-device, for HS/FS, this indicates an imminent end of session indication from the core. - In B-device, for HS/LS, it indicates that the timer used to wait for an A-device to signal a connection (b_ase0_brst_tmout in OTG 2.0) timed out resulting in B-device staying as B-peripheral. 1'b1: Host negotiation success. - This indicates that the host negotiation was successful. Note: This bit is applicable only for OTG 2.0 mode of operation.'''
  [[register.field]]
    name = "SESREQSTS"
    bits = "1"
    type = "ro"
    shortdesc = '''Session Request Status Ignore this field.'''
    longdesc = '''It is used only for internal testing.'''
  [[register.field]]
    name = "OEVTERROR"
    bits = "0"
    type = "wtc"
[[register]]
  name = "OEVTEN"
  type = "mixed"
  width = 32
  description = "OTG Events Enable Register Setting a bit in this register enables the generation of corresponding events in OEVT and assertion of otg_interrupt due to this event. When the enable bit is 1'b0, the event is not be set in OEVT and otg_interrupt is not asserted due to this event."
  default = "0x00000000"
  offset = "0x0000CC0C"
  [[register.field]]
    name = "RESERVED"
    bits = "31:28"
    type = "ro"
  [[register.field]]
    name = "OTGXHCIRUNSTPSETEVNTEN"
    bits = "27"
    type = "rw"
    shortdesc = '''OTG Host Run Stop Set Event Enable (OTGXhciRunStpSetEvntEn) When this bit is set, OEVT.'''
    longdesc = '''OTGXhciRunStpSetEvnt is enabled. If not, the event is disabled.'''
  [[register.field]]
    name = "OTGDEVRUNSTPSETEVNTEN"
    bits = "26"
    type = "rw"
    shortdesc = '''OTG Device Run Stop Set Event Enable (OTGDevRunStpSetEvntEn) When this bit is set, OEVT.'''
    longdesc = '''DevRunStpSet event is enabled. If not, that event is disabled.'''
  [[register.field]]
    name = "OTGHIBENTRYEVNTEN"
    bits = "25"
    type = "rw"
    shortdesc = '''OTG Hibernation Entry Event Enable (OTGHibEntryEn) When this bit is set, OEVT.'''
    longdesc = '''HibEntryEvnt is enabled. If not, the event is disabled.'''
  [[register.field]]
    name = "OTGCONIDSTSCHNGEVNTEN"
    bits = "24"
    type = "rw"
  [[register.field]]
    name = "HRRCONFNOTIFEVNTEN"
    bits = "23"
    type = "rw"
    shortdesc = '''OTGCommonEvtInfoEn[2] HRRConfNotif Event Enable (HRRConfNotifEvntEn) When this bit is set, OEVT.'''
    longdesc = '''HRRConfNotifEvnt is enabled. If not, the event is disabled.'''
  [[register.field]]
    name = "HRRINITNOTIFEVNTEN"
    bits = "22"
    type = "rw"
    shortdesc = '''OTGCommonEvtInfoEn[1] HRRInitNotif Event Enable (HRRInitNotifEvntEn) When this bit is set, OEVT.'''
    longdesc = '''HRRInitNotifEvnt is enabled. If not, the event is disabled.'''
  [[register.field]]
    name = "OTGADEVIDLEEVNTEN"
    bits = "21"
    type = "rw"
    shortdesc = '''OTGADevEvtInfoEn[5] A-device A-IDLE Event (OTGADevIdleEvntEn) When this bit is set, OEVT.'''
    longdesc = '''OTGADevIdleEvnt is enabled. If not, the event is disabled.'''
  [[register.field]]
    name = "OTGADEVBHOSTENDEVNTEN"
    bits = "20"
    type = "rw"
    shortdesc = '''OTGADevEvtInfoEn[4] A-device B-Host End Event Enable (OTGADevBHostEndEvntEn) When this bit is set, OEVT.'''
    longdesc = '''OTGADevBHostEndEvnt is enabled. If not, the event is disabled.'''
  [[register.field]]
    name = "OTGADEVHOSTEVNTEN"
    bits = "19"
    type = "rw"
    shortdesc = '''OTGADevEvtInfoEn[3] A-device host event (OTGADevHostEvntEn) When this bit is set, OEVT.'''
    longdesc = '''OTGADevHostEvnt is enabled. If not, the event is disabled.'''
  [[register.field]]
    name = "OTGADEVHNPCHNGEVNTEN"
    bits = "18"
    type = "rw"
    shortdesc = '''OTGADevEvtInfoEn[2] A-Dev HNP Change EventEn (OTGADevHNPChngEvntEn) When this bit is set, OEVT.'''
    longdesc = '''OTGADevHNPChngEvnt is enabled. If not, the event is disabled.'''
  [[register.field]]
    name = "OTGADEVSRPDETEVNTEN"
    bits = "17"
    type = "rw"
    shortdesc = '''OTGADevEvtInfoEn[1] SRP Detect Event Enable (OTGADevSRPDetEvntEn) When this bit is set, OEVT.'''
    longdesc = '''OTGADevSRPDetEvnt is enabled. If not, the event is disabled.'''
  [[register.field]]
    name = "OTGADEVSESSENDDETEVNTEN"
    bits = "16"
    type = "rw"
    shortdesc = '''OTGADevEvtInfoEn[0] Session End Detected Event Enable (OTGADevSessEndDetEvntEn) When this bit is set, OEVT.'''
    longdesc = '''OTGADevSessEndEvnt is enabled. Otherwise, the event is disabled.'''
  [[register.field]]
    name = "RESERVED"
    bits = "15:12"
    type = "ro"
  [[register.field]]
    name = "OTGBDEVBHOSTENDEVNTEN"
    bits = "11"
    type = "rw"
    shortdesc = '''OTGBDevEvtInfoEn[3] B-device B-Host End Event Enable (OTGBDevBHostEndEvntEn) When this bit is set, OEVT.'''
    longdesc = '''OTGBDevHostEndEvnt is enabled. If not, the event is disabled'''
  [[register.field]]
    name = "OTGBDEVHNPCHNGEVNTEN"
    bits = "10"
    type = "rw"
    shortdesc = '''OTGBDevEvtInfoEn[2] B-Dev HNP Change Event Enable (OTGBDevHNPChngEvntEn) When this bit is set, OEVT.'''
    longdesc = '''OTGBDevHNPChngEvnt is enabled. If not, the event is disabled'''
  [[register.field]]
    name = "OTGBDEVSESSVLDDETEVNTEN"
    bits = "9"
    type = "rw"
    shortdesc = '''OTGBDevEvtInfoEn[1] Session Valid Detected Event Enable (OTGBDevSessVldDetEvntEn) Set in B-device mode only.'''
    longdesc = '''This event is asserted when there is a valid VBUS from A-device and B-device succeeds in starting a session.'''
  [[register.field]]
    name = "OTGBDEVVBUSCHNGEVNTEN"
    bits = "8"
    type = "rw"
    shortdesc = '''OTGBDevEvtInfoEn[0] VBUS Change Event Enable (OTGBDevVBUSChngEvntEn) When this bit is set, OEVT.'''
    longdesc = '''OTGBDevVBUSChngEvnt is enabled. If not, the event is disabled.'''
  [[register.field]]
    name = "RESERVED"
    bits = "7:0"
    type = "ro"
[[register]]
  name = "OSTS"
  type = "ro"
  width = 32
  description = "OTG Status Register The OTG Status Register reflects the status of the OTG function of the core."
  default = "0x00000000"
  offset = "0x0000CC10"
  [[register.field]]
    name = "RESERVED"
    bits = "31:14"
    type = "ro"
  [[register.field]]
    name = "DEVRUNSTP"
    bits = "13"
    type = "ro"
    shortdesc = '''This bit reflects the status of the Run/Stop bit in the DCTL Device register.'''
    longdesc = '''- 0 DCTL.Run/Stop is set to 0. - 1 DCTL.Run/Stop is set to 1.'''
  [[register.field]]
    name = "XHCIRUNSTP"
    bits = "12"
    type = "ro"
    shortdesc = '''OTG Host Run Stop Set Event This event is set when the Host Driver programs the USBCMD.'''
    longdesc = '''Run/Stop to 1'b1. Note: - During Hibernation Exit, upon receiving this event, the OTG Driver can start register accesses to the core. - This bit is applicable for OTG 2.0 and OTG 3.0 modes of operation.'''
  [[register.field]]
    name = "OTGSTATE"
    bits = "11:8"
    type = "ro"
    shortdesc = '''This is a debug field indicating the current state of the OTG state machine.'''
    longdesc = '''The encoding is as follows: - 4'b0000: A_IDLE - 4'b0010: A_WAIT_BCON - 4'b0011: A_WAIT_VFALL - 4'b0100: A_VBUS_ERR - 4'b0101: A_HOST - 4'b0110: A_SUSPEND - 4'b1111: A_PERIPHERAL - 4'b0111: A_WAIT_PPWR - 4'b1000: B_IDLE - 4'b1001: B_SRP_INIT - 4'b1010: B_PERIPHERAL - 4'b1011: B_WAIT_ACON - 4'b1100: B_HOST - 4'b1101: A_WAIT_SWITCH - 4'b1110: B_WAIT_SWITCH'''
  [[register.field]]
    name = "RESERVED"
    bits = "7:5"
    type = "ro"
  [[register.field]]
    name = "PERIPHERALSTATE"
    bits = "4"
    type = "ro"
    shortdesc = '''OTG state Indicates whether the core is acting as a peripheral or host.'''
    longdesc = '''- 1'b0: Host - 1'b1: Peripheral'''
  [[register.field]]
    name = "XHCIPRTPOWER"
    bits = "3"
    type = "ro"
    shortdesc = '''This bit reflects the PORTSC.'''
    longdesc = '''PP bit in the xHCI register.'''
  [[register.field]]
    name = "BSESVLD"
    bits = "2"
    type = "ro"
    shortdesc = '''B-Session Valid Indicates the Device mode transceiver status.'''
    longdesc = '''In OTG mode, applications use this bit to determine if the device is connected. - 1'b0: B-session is not valid. - 1'b1: B-session is valid.'''
  [[register.field]]
    name = "ASESVLD"
    bits = "1"
    type = "ro"
    shortdesc = '''Indicates the Host mode transceiver status.'''
    longdesc = '''- 1'b0: A-session is not valid - 1'b1: A-session is valid'''
  [[register.field]]
    name = "CONIDSTS"
    bits = "0"
    type = "ro"
[[register]]
  name = "ADPEVT"
  type = "mixed"
  width = 32
  description = "ADP Event Register"
  default = "0x00000000"
  offset = "0x0000CC28"
  [[register.field]]
    name = "RESERVED"
    bits = "31:29"
    type = "ro"
  [[register.field]]
    name = "ADPPRBEVNT"
    bits = "28"
    type = "wtc"
  [[register.field]]
    name = "ADPSNSEVNT"
    bits = "27"
    type = "wtc"
  [[register.field]]
    name = "ADPTMOUTEVNT"
    bits = "26"
    type = "wtc"
    shortdesc = '''ADP Timeout Event This event is relevant when ADP probe command is executed.'''
    longdesc = '''When this event is set, it means that the ramp time is completed (GADPCTL.RTIM has reached its terminal value of 0x7FF). This is a debug feature that allows software to read the ramp time after each cycle.'''
  [[register.field]]
    name = "ADPRSTCMPLTEVNT"
    bits = "25"
    type = "wtc"
  [[register.field]]
    name = "RESERVED"
    bits = "24:16"
    type = "ro"
  [[register.field]]
    name = "RTIM"
    bits = "15:0"
    type = "ro"
    shortdesc = '''RAMP TIME: These bits capture the latest time it took for Vbus to ramp from VADP_SINK to VADP_PRB.'''
    longdesc = '''The bits are defined in units of 32 kHz clock cycles as follows: - 0x000: 1 cycles - 0x001: 2 cycles - 0x002: 3 cycles and so on till, - 0xFFFF: 65536 cycles The maximum time of 65536 cycles corresponds to a time of 2.04 seconds. Note: For scaledown ramp_timeout: - PrbDelta = 2'b11 => 781.25 us - PrbDelta = 2'b10 => 1562.5 us - PrbDelta = 2'b01 => 3125 us - PrbDelta = 2'b00 => 6250 us'''
