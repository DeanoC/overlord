package Overlord

import scala.collection.mutable

object ZigSoftware:

  def addLibrary(exe: String, name: String): String =
    s"    if(!hasPackageBeenAdded(\"${name}\")) ${exe}.addPackage(${name}Pkg);\n"

  private def makeLinkerFunction(
      libsById: Map[Identifier, SoftwareDef],
      name: String,
      libraries: List[String],
      link: String,
      pkg: String
  ): String =
    val sb = mutable.StringBuilder()
    val dictionary = Map("${lib_name}" -> name)
    val bTxt = if link.contains("builder") || libraries.nonEmpty then "builder" else "_"
    sb ++= s"pub fn ${name}Link(${bTxt}: *std.build.Builder, executable: *std.build.LibExeObjStep) void {\n"
    sb ++= link.replace("\\n", "\n").overlordStringInterpolate(dictionary)

    if libraries.nonEmpty then
      libraries.foreach(l =>
        libsById(Software.makeLibraryIdentifier(l)) match
          case LibSoftwareDef(name, _, _, _, _, _, _, _) => sb ++= addLibrary("executable", name)
          case _                                         => ""
      )

    sb ++= pkg

    sb ++= "}\n\n"
    sb.result()

  def programsTop(paths: Paths, zigLocalPrograms: Seq[SoftwareDef], libsById: Map[Identifier, SoftwareDef]): String =
    val sb = mutable.StringBuilder()

    // header
    sb ++= """// DO NOT EDIT - Autogenerated by Overlord
const std = @import("std");

// comptime makes path absolute from this build file
pub fn sdkPath(comptime suffix: []const u8) []const u8 {
    return comptime blk: {
        const root_dir = std.fs.path.dirname(@src().file) orelse ".";
        break :blk root_dir ++ "/" ++ suffix;
    };
}

fn hasPackageBeenAdded(name: []const u8) bool {
    for (packageAdded) |*package| {
        if (std.mem.eql(u8, name, package.name)) {
            if (package.added == false) {
                package.added = true;
                return false;
            } else return true;
        }
    }

    std.log.warn("Trying to add unknown package {s}", .{name});
    return true;
}

// package double adding protector
var packageAdded = [_]struct { name: []const u8, added: bool = false } {
"""

    libsById.foreach((id, sw) =>
      sw match
        case LibSoftwareDef(name, _, _, _, _, _, _, _) => sb ++= s"    .{ .name = \"$name\" },\n";
        case _                                         => {}
    )

    sb ++= "};\n// Package definitions\n"
    libsById.foreach((id, sw) =>
      sw match
        case LibSoftwareDef(lib_name, _, _, _, _, _, _, zig) =>
          val imp =
            if zig.nonEmpty && zig.get.library_import.nonEmpty then
              zig.get.library_import.overlordStringInterpolate(Map("${lib_name}" -> lib_name))
            else s"libs/$lib_name/package.zig"
          sb ++= s"""const ${lib_name}Pkg = std.build.Pkg{ .name = "$lib_name", .source = .{ .path = sdkPath("$imp") } };"""
          sb ++= "\n"
        case _ => {}
    )

    sb ++= "\n// Local program definitions\n"
    zigLocalPrograms.foreach(sw =>
      sw match
        case ProgramSoftwareDef(name, boards, cpus, builder, libraries, dependencies, actions) =>
          sb ++= s"""const $name = @import("$name/ikuy_build.zig");"""
          sb ++= "\n"
        case _ => {}
    )

    sb ++= "\n// link functions\n"
    libsById.foreach((id, sw) =>
      sw match
        case LibSoftwareDef(lib_name, _, _, _, libraries, _, _, zig) =>
          if zig.nonEmpty && zig.get.library_link.nonEmpty then
            val pkg =
              if zig.nonEmpty && zig.get.library_package.nonEmpty then "    " ++ zig.get.library_package ++ "\n"
              else addLibrary("executable", lib_name);
            sb ++= makeLinkerFunction(libsById, lib_name, libraries, zig.get.library_link, pkg)
              .overlordStringInterpolate(Map("${lib_name}" -> lib_name))
        case _ => {}
    )

    sb ++= """// The actual build function
  pub fn build(builder: *std.build.Builder) !void {
"""
    // insert local programs build call
    zigLocalPrograms.foreach(sw =>
      sw match
        case ProgramSoftwareDef(exe_name, _, _, _, _, _, _) =>
          sb ++= s"    const ${exe_name}_exe = try $exe_name.build(builder);\n"
          // add libraries for each one
          libsById.foreach((id, sw) =>
            sw match
              case LibSoftwareDef(lib_name, _, _, _, _, _, _, zig) =>
                val str =
                  if zig.nonEmpty && zig.get.library_link.nonEmpty then
                    s"    ${lib_name}Link(builder, ${exe_name}_exe);\n"
                  else addLibrary(s"${exe_name}_exe", lib_name)

                sb ++= str.overlordStringInterpolate(Map("${lib_name}" -> lib_name))
              case _ => {}
          )
          sb ++= s"    ${exe_name}_exe.install();\n"
        case _ => {}
    )

    // close the build functions
    sb ++= "}\n"

    sb.result
