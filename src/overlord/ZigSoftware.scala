package Overlord

import scala.collection.mutable

object ZigSoftware:

  def addLibrary(exe: String, name: String): String = s"    ${exe}.addPackage(${name}Pkg);\n"

  private def makeLinkerFunction(
      libsById: Map[Identifier, SoftwareDef],
      name: String,
      libraries: List[String],
      link: String,
      pkg: String
  ): String =
    val sb = mutable.StringBuilder()
    val dictionary = Map("${lib_name}" -> name)
    val bTxt = if link.contains("builder") || libraries.nonEmpty then "builder" else "_"
    sb ++= s"pub fn ${name}Link(${bTxt}: *std.build.Builder, executable: *std.build.LibExeObjStep) void {\n"
    sb ++= link.replace("\\n", "\n").overlordStringInterpolate(dictionary)

    if libraries.nonEmpty then
      libraries.foreach(l =>
        libsById(Software.makeLibraryIdentifier(l)) match
          case LibSoftwareDef(name, _, _, _, _, _, _, _) => sb ++= addLibrary("executable", name)
          case _                                         => ""
      )

    sb ++= pkg

    sb ++= "}\n\n"
    sb.result()

  def programsTop(paths: Paths, zigLocalPrograms: Seq[SoftwareDef], libsById: Map[Identifier, SoftwareDef]): String =
    val sb = mutable.StringBuilder()

    // header
    sb ++= """// DO NOT EDIT - Autogenerated by Overlord
const std = @import("std");

// comptime makes path absolute from this build file
pub fn sdkPath(comptime suffix: []const u8) []const u8 {
    return comptime blk: {
        const root_dir = std.fs.path.dirname(@src().file) orelse ".";
        break :blk root_dir ++ "/" ++ suffix;
    };
}

"""
    sb ++= "// Package definitions\n"
    libsById.foreach((id, sw) =>
      sw match
        case LibSoftwareDef(name, boards, cpus, builder, libraries, dependencies, actions, zig) =>
          val imp =
            if zig.nonEmpty && zig.get.library_import.nonEmpty then zig.get.library_import
            else s"libs/$name/package.zig"
          sb ++= s"""const ${name}Pkg = std.build.Pkg{ .name = "$name", .source = .{ .path = sdkPath("$imp") } };"""
          sb ++= "\n"
        case _ => {}
    )

    sb ++= "\n// Local program definitions\n"
    zigLocalPrograms.foreach(sw =>
      sw match
        case ProgramSoftwareDef(name, boards, cpus, builder, libraries, dependencies, actions) =>
          sb ++= s"""const $name = @import("$name/ikuy_build.zig");"""
          sb ++= "\n"
        case _ => {}
    )

    sb ++= "\n// link functions\n"
    libsById.foreach((id, sw) =>
      sw match
        case LibSoftwareDef(name, boards, cpus, builder, libraries, dependencies, actions, zig) =>
          val link =
            if zig.nonEmpty && zig.get.library_link.nonEmpty then "    " ++ zig.get.library_link ++ "\n" else ""
          val pkg =
            if zig.nonEmpty && zig.get.library_package.nonEmpty then "    " ++ zig.get.library_package ++ "\n"
            else addLibrary("executable", name);
          sb ++= makeLinkerFunction(libsById, name, libraries, link, pkg)
        case _ => {}
    )

    sb ++= """// The actual build function
pub fn build(builder: *std.build.Builder) !void {
"""
    // insert local programs build call
    zigLocalPrograms.foreach(sw =>
      sw match
        case ProgramSoftwareDef(exe_name, _, _, _, _, _, _) =>
          sb ++= s"    const ${exe_name}_exe = try $exe_name.build(builder);\n"
          // add libraries for each one
          libsById.foreach((id, sw) =>
            sw match
              case LibSoftwareDef(lib_name, _, _, _, _, _, _, zig) =>
                val str =
                  if zig.nonEmpty then s"    ${lib_name}Link(builder, ${exe_name}_exe);\n"
                  else addLibrary(s"${exe_name}_exe", lib_name)

                val dictionary = Map("${lib_name}" -> lib_name)
                sb ++= str.overlordStringInterpolate(dictionary)
              case _ => {}
          )
        case _ => {}
    )

    // close the build functions
    sb ++= "}\n"

    sb.result
