package Overlord

import scala.collection.mutable

object ZigSoftware:

  private def makeLinkerFunction(
      libsById: Map[Identifier, SoftwareDef],
      name: String,
      libraries: List[String],
      link: String,
      pkg: String
  ): String =
    val sb = mutable.StringBuilder()
    val dictionary = Map("${lib_name}" -> name)
    val bTxt = if link.contains("builder") then "builder" else "_"
    sb ++= s"pub fn ${name}Link(${bTxt}: *std.build.Builder, executable: *std.build.LibExeObjStep) void {\n"
    sb ++= link.replace("\\n", "\n").overlordStringInterpolate(dictionary)

    if libraries.nonEmpty then
      libraries.foreach(l =>
        libsById(Software.makeLibraryIdentifier(l)) match
          case LibSoftwareDef(lib_name, _, _, _, _, _, _, _) =>
            sb ++= s"    if(!hasPackageBeenAdded(\"${lib_name}\")) executable.addPackage(${lib_name}Pkg);\n"
          case _ => ""
      )

    sb ++= pkg

    sb ++= "}\n\n"
    sb.result()

  def programsTop(paths: Paths, zigLocalPrograms: Seq[SoftwareDef], libsById: Map[Identifier, SoftwareDef]): String =
    val sb = mutable.StringBuilder()

    // header
    sb ++= """// DO NOT EDIT - Autogenerated by Overlord
const std = @import("std");

// comptime makes path absolute from this build file
pub fn sdkPath(comptime suffix: []const u8) []const u8 {
    return comptime blk: {
        const root_dir = std.fs.path.dirname(@src().file) orelse ".";
        break :blk root_dir ++ "/" ++ suffix;
    };
}

fn hasPackageBeenAdded(name: []const u8) bool {
    for (packageAdded) |*package| {
        if (std.mem.eql(u8, name, package.name)) {
            if (package.added == false) {
                package.added = true;
                return false;
            } else return true;
        }
    }

    std.log.warn("Trying to add unknown package {s}", .{name});
    return true;
}

// package double adding protector
var packageAdded = [_]struct { name: []const u8, added: bool = false } {
"""

    libsById.foreach((id, sw) =>
      sw match
        case LibSoftwareDef(name, _, _, _, _, _, _, _) => sb ++= s"    .{ .name = \"$name\" },\n";
        case _                                         => {}
    )

    sb ++= "};\n// Package definitions\n"
    libsById.foreach((id, sw) =>
      sw match
        case LibSoftwareDef(lib_name, _, _, _, libraries, _, _, zig) =>
          val imp =
            if zig.nonEmpty && zig.get.library_import.nonEmpty then
              zig.get.library_import.overlordStringInterpolate(Map("${lib_name}" -> lib_name))
            else s"libs/$lib_name/package.zig"
          sb ++= s"const ${lib_name}Pkg = std.build.Pkg{\n    .name = \"$lib_name\",\n    .source = .{ .path = sdkPath(\"$imp\") }"
          if libraries.nonEmpty then
            sb ++= ",\n    .dependencies = &.{"
            libraries.foreach(lib => sb ++= s"\n      ${lib}Pkg, ")
            sb ++= "\n    },"

          sb ++= "\n};\n"
        case _ => {}
    )

    sb ++= "\n// Local program definitions\n"
    zigLocalPrograms.foreach(sw =>
      sw match
        case ProgramSoftwareDef(name, boards, cpus, builder, libraries, dependencies, actions) =>
          sb ++= s"""const $name = @import("$name/ikuy_build.zig");"""
          sb ++= "\n"
        case _ => {}
    )

    sb ++= "\n// link functions\n"
    libsById.foreach((id, sw) =>
      sw match
        case LibSoftwareDef(lib_name, _, _, _, libraries, _, _, zig) =>
          val pkg =
            if zig.nonEmpty && zig.get.library_package.nonEmpty then zig.get.library_package ++ "\n"
            else s"    if(!hasPackageBeenAdded(\"${lib_name}\")) executable.addPackage(${lib_name}Pkg);\n"

          val link = if zig.nonEmpty && zig.get.library_link.nonEmpty then zig.get.library_link ++ "\n" else ""

          sb ++= makeLinkerFunction(libsById, lib_name, libraries, link, pkg).overlordStringInterpolate(
            Map("${lib_name}" -> lib_name)
          )
        case _ => {}
    )

    sb ++= """// The actual build function
  pub fn build(builder: *std.build.Builder) !void {
"""
    // insert local programs build call
    zigLocalPrograms.foreach(sw =>
      sw match
        case ProgramSoftwareDef(exe_name, _, _, _, _, _, _) =>
          sb ++= s"    const ${exe_name}_exe = try $exe_name.build(builder);\n"
          // add libraries for each one
          libsById.foreach((id, sw) =>
            sw match
              case LibSoftwareDef(lib_name, _, _, _, _, _, _, zig) =>
                val str = s"    ${lib_name}Link(builder, ${exe_name}_exe);\n"

                sb ++= str.overlordStringInterpolate(Map("${lib_name}" -> lib_name))
              case _ => {}
          )
          sb ++= s"    ${exe_name}_exe.install();\n"
        case _ => {}
    )

    // close the build functions
    sb ++= "}\n"

    sb.result
