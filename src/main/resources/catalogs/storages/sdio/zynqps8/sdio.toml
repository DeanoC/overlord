description = "SDIO 0 Controller"
[[register]]
  name = "REG_SDMASYSADDRLO"
  type = "rw"
  width = 16
  description = "Dual purpose: low SDMA address, Auto CMD23 arg."
  default = "0x00000000"
  offset = "0x00000000"
  [[register.field]]
    name = "SDMA_SYSADDRESS"
    bits = "15:0"
    type = "rw"
[[register]]
  name = "REG_SDMASYSADDRHI"
  type = "rw"
  width = 16
  description = "Dual purpose: high SDMA address, Auto CMD23 arg."
  default = "0x00000000"
  offset = "0x00000002"
  [[register.field]]
    name = "SDMA_SYSADDRESS"
    bits = "15:0"
    type = "rw"
[[register]]
  name = "REG_BLOCKSIZE"
  type = "rw"
  width = 16
  description = "Configure the Number of Bytes in a Data Block."
  default = "0x00000000"
  offset = "0x00000004"
  [[register.field]]
    name = "SDMA_BUFBOUNDARY"
    bits = "14:12"
    type = "rw"
    shortdesc = '''Write the size of the contiguous DMA buffer in the system memory.'''
    longdesc = '''The System Address register is updated at every system boundary during the DMA transfer The DMA transfer waits at the every boundary specified by these fields and the SDIO controller generates the DMA interrupt to request the controller to update the System Address register. This function is active when the [DMA Enable] bit in the Transfer Mode register is set = 1. 000b: 4KB 001b: 8KB 010b: 16KB 011b: 32KB 100b: 64KB 101b: 128KB 110b: 256KB 111b: 512KB'''
  [[register.field]]
    name = "XFER_BLOCKSIZE"
    bits = "11:0"
    type = "rw"
    shortdesc = '''Block size for data transfers for CMD17, CMD18, CMD24, CMD25 and CMD53.'''
    longdesc = '''Read-only. Valid if no transaction is executing (i.e after a transaction has stopped). 0000h: No data transfer. 0001h: 1 byte 0002h: 2 bytes 0003h: 3 bytes .. 0200h: 512 bytes .. 0800h: 2048 bytes (maximum block size)'''
[[register]]
  name = "REG_BLOCKCOUNT"
  type = "rw"
  width = 16
  description = "Configure the number of data blocks"
  default = "0x00000000"
  offset = "0x00000006"
  [[register.field]]
    name = "XFER_BLOCKCOUNT"
    bits = "15:0"
    type = "rw"
    shortdesc = '''Remaining Block Count.'''
    longdesc = '''The controller decrements the block count after each block transfer and stops transfers when the count reaches zero. 0000h: 0 blocks, transfers stop. 0001h: 1 block. 0002h: 2 blocks. .. FFFFh: 65535 blocks. This register is enabled when Block Count Enable in the Transfer Mode register is set to 1 and is valid only for multi-block transfers. Accessed the register when no transactions are executing (i.e., after a transaction has stopped). During a transfer, reads return an invalid value and writes are ignored. When saving transfer context as a result of Suspend command, the number of blocks yet to be transferred can be determined by reading this register. When restoring transfer context prior to issuing a Resume command, the Host Driver shall restore the previously save block count.'''
[[register]]
  name = "REG_ARGUMENT1LO"
  type = "rw"
  width = 16
  description = "Lower bits of SD Command Argument"
  default = "0x00000000"
  offset = "0x00000008"
  [[register.field]]
    name = "COMMAND_ARGUMENT1"
    bits = "15:0"
    type = "rw"
[[register]]
  name = "REG_ARGUMENT1HI"
  type = "rw"
  width = 16
  description = "Upper bits of SD Command Argument"
  default = "0x00000000"
  offset = "0x0000000A"
  [[register.field]]
    name = "COMMAND_ARGUMENT1"
    bits = "15:0"
    type = "rw"
[[register]]
  name = "REG_TRANSFERMODE"
  type = "rw"
  width = 16
  description = "Control the Data Transfer Operations."
  default = "0x00000000"
  offset = "0x0000000C"
  [[register.field]]
    name = "XFERMODE_MULTIBLKSEL"
    bits = "5"
    type = "rw"
    shortdesc = '''This bit enables multiple block data transfers.'''
    longdesc = ''''0' Single Block.'1' Multiple Block.'''
  [[register.field]]
    name = "XFERMODE_DATAXFERDIR"
    bits = "4"
    type = "rw"
    shortdesc = '''This bit defines the direction of data transfers.'''
    longdesc = '''0: Write from Host to Card. 1: Read from Card to Host.'''
  [[register.field]]
    name = "XFERMODE_AUTOCMDENA"
    bits = "3:2"
    type = "rw"
    shortdesc = '''Auto command function enables.'''
    longdesc = '''00: Auto Command Disabled. 01: Auto CMD12 Enabled. 10: Auto CMD23 Enabled. 11: reserved. There are two methods to stop multiple-block read and write operation. (1) Auto CMD12 Enable: Multiple-block read and write commands for memory require CMD12 to stop the operation. The controller issues CMD12 automatically when the last block transfer is completed. Auto CMD12 error is indicated in the Auto CMD Error Status register. The driver shall not set this bit if the command does not require Auto CMD12. (2) Auto CMD23 Enable: The controller issues an Auto CMD23 before issuing a command specified in the Command Register. The following conditions are required to use the Auto CMD23. * Auto CMD23 Supported (Host Controller Version is 3.00 or later). * A memory card that supports CMD23 (SCR[33]=1). * If DMA is used, it shall be ADMA. * Only when CMD18 or CMD25 is issued. By writing the Command register, the controller issues a CMD23 first and then issues a command specified by the Command Index in Command register 32-bit block count value for CMD23 is set to SDMA System Address / Argument 2 register.'''
  [[register.field]]
    name = "XFERMODE_BLKCNTENA"
    bits = "1"
    type = "rw"
    shortdesc = '''Block Count Register Enable.'''
    longdesc = '''0: disable (setting is also useful for executing an infinite transfer). 1: enable. Applicable to multiple block transfers.'''
  [[register.field]]
    name = "XFERMODE_DMAENABLE"
    bits = "0"
    type = "rw"
    shortdesc = '''DMA can be enabled only if DMA Support bit in the Capabilities register is set.'''
    longdesc = '''If this bit is set to 1, a DMA operation shall begin when the Host Driver writes to the upper byte of Command register (00Fh). 0: disable DMA. 1: enable DMA.'''
[[register]]
  name = "REG_COMMAND"
  type = "rw"
  width = 16
  description = "Controller Commands."
  default = "0x00000000"
  offset = "0x0000000E"
  [[register.field]]
    name = "COMMAND_CMDINDEX"
    bits = "13:8"
    type = "rw"
    shortdesc = '''Write the command number used with: * CMD [0:63].'''
    longdesc = '''* ACMD [0:63].'''
  [[register.field]]
    name = "COMMAND_CMDTYPE"
    bits = "7:6"
    type = "rw"
    shortdesc = '''Assert a special command type; there are three types: suspend, resume, and abort.'''
    longdesc = '''Suspend Command: If the Suspend command succeeds, the controller assumes the SD I/O has been released and that it is possible to issue the next command using the SD_DAT signals. The controller de-asserts Read Wait for read transactions and stops checking busy for write transactions. The Interrupt cycle starts in 4-bit mode. If the Suspend command fails, the controller maintain its current state. and the controller shall restart the transfer by setting Continue Request in the Block Gap Control Register. Resume Command: The SDIO controller re-starts the data transfer by restoring the registers in the range of 000-00Dh. The controller checks for busy before starting write transfers. Abort Command: * If this command is set when executing a read transfer, the controller stops adding content to the receive buffer. * If this command is set when executing a write transfer, the controller stops driving the SD_DAT signals. After issuing the Abort command, the controller should issue a software reset. 00: Normal 01: Suspend 10: Resume 11: Abort'''
  [[register.field]]
    name = "COMMAND_DATAPRESENT"
    bits = "5"
    type = "rw"
    shortdesc = '''This bit is set to 1 to indicate that data is present and shall be transferred using the DAT line.'''
    longdesc = '''If is set to 0 for the following: 1. Commands using only CMD line (ex. CMD52). 2. Commands with no data transferbut using busy signal on DAT[0]line (R1b or R5b ex. CMD38). 3. Resume Command.'0' Data not Present'1' Data present'''
  [[register.field]]
    name = "COMMAND_INDEXCHKENA"
    bits = "4"
    type = "rw"
    shortdesc = '''If this bit is set to 1, the HC shall check the index field in the response to see if it has the same value as the command index.'''
    longdesc = '''If it is not, it is reported as a Command Index Error. If this bit is set to 0, the Index field is not checked.'0' Disable'1' Enable'''
  [[register.field]]
    name = "COMMAND_CRCCHKENA"
    bits = "3"
    type = "rw"
    shortdesc = '''If this bit is set to 1, the HC shall check the CRC field in the response.'''
    longdesc = '''If an error is detected, it is reported as a Command CRC Error. If this bit is set to 0, the CRC field is not checked.'0' Disable'1' Enable'''
  [[register.field]]
    name = "COMMAND_RESPONSETYPE"
    bits = "1:0"
    type = "rw"
    shortdesc = '''Response Type Select.'''
    longdesc = ''''00' No Response'01' Response Length 136'10' Response Length 48'11' Response Length 48 check busy after response'''
[[register]]
  name = "REG_RESPONSE0"
  type = "ro"
  width = 16
  description = "Response 0 from SD Card."
  default = "0x00000000"
  offset = "0x00000010"
  [[register.field]]
    name = "COMMAND_RESPONSE"
    bits = "15:0"
    type = "ro"
[[register]]
  name = "REG_RESPONSE1"
  type = "ro"
  width = 16
  description = "This register is used to store responses from SD Cards"
  default = "0x00000000"
  offset = "0x00000012"
  [[register.field]]
    name = "COMMAND_RESPONSE"
    bits = "15:0"
    type = "ro"
[[register]]
  name = "REG_RESPONSE2"
  type = "ro"
  width = 16
  description = "This register is used to store responses from SD Cards"
  default = "0x00000000"
  offset = "0x00000014"
  [[register.field]]
    name = "COMMAND_RESPONSE"
    bits = "15:0"
    type = "ro"
[[register]]
  name = "REG_RESPONSE3"
  type = "ro"
  width = 16
  description = "This register is used to store responses from SD Cards"
  default = "0x00000000"
  offset = "0x00000016"
  [[register.field]]
    name = "COMMAND_RESPONSE"
    bits = "15:0"
    type = "ro"
[[register]]
  name = "REG_RESPONSE4"
  type = "ro"
  width = 16
  description = "This register is used to store responses from SD Cards"
  default = "0x00000000"
  offset = "0x00000018"
  [[register.field]]
    name = "COMMAND_RESPONSE"
    bits = "15:0"
    type = "ro"
[[register]]
  name = "REG_RESPONSE5"
  type = "ro"
  width = 16
  description = "This register is used to store responses from SD Cards"
  default = "0x00000000"
  offset = "0x0000001A"
  [[register.field]]
    name = "COMMAND_RESPONSE"
    bits = "15:0"
    type = "ro"
[[register]]
  name = "REG_RESPONSE6"
  type = "ro"
  width = 16
  description = "This register is used to store responses from SD Cards"
  default = "0x00000000"
  offset = "0x0000001C"
  [[register.field]]
    name = "COMMAND_RESPONSE"
    bits = "15:0"
    type = "ro"
[[register]]
  name = "REG_RESPONSE7"
  type = "ro"
  width = 16
  description = "This register is used to store responses from SD Cards"
  default = "0x00000000"
  offset = "0x0000001E"
  [[register.field]]
    name = "COMMAND_RESPONSE"
    bits = "15:0"
    type = "ro"
[[register]]
  name = "REG_DATAPORT"
  type = "rw"
  width = 32
  description = "Read/write internal buffer."
  default = "0x00000000"
  offset = "0x00000020"
  [[register.field]]
    name = "SDHCDMACTRL_PIOBUFRDDATA"
    bits = "31:0"
    type = "rw"
[[register]]
  name = "REG_PRESENTSTATE"
  type = "ro"
  width = 32
  description = "SDIO Controller Status, read-only."
  default = "0x00080000"
  offset = "0x00000024"
  [[register.field]]
    name = "SDIF_DAT7IN_DSYNC"
    bits = "28"
    type = "ro"
  [[register.field]]
    name = "SDIF_DAT6IN_DSYNC"
    bits = "27"
    type = "ro"
  [[register.field]]
    name = "SDIF_DAT5IN_DSYNC"
    bits = "26"
    type = "ro"
  [[register.field]]
    name = "SDIF_DAT4IN_DSYNC"
    bits = "25"
    type = "ro"
  [[register.field]]
    name = "SDIF_CMDIN_DSYNC"
    bits = "24"
    type = "ro"
  [[register.field]]
    name = "SDIF_DAT3IN_DSYNC"
    bits = "23"
    type = "ro"
    shortdesc = '''This status is used to check DAT line level to recover from errors, and for debugging.'''
    longdesc = '''This is especially useful in detecting the busy signal level from DAT[0].'''
  [[register.field]]
    name = "SDIF_DAT2IN_DSYNC"
    bits = "22"
    type = "ro"
    shortdesc = '''This status is used to check DAT line level to recover from errors, and for debugging.'''
    longdesc = '''This is especially useful in detecting the busy signal level from DAT[0].'''
  [[register.field]]
    name = "SDIF_DAT1IN_DSYNC"
    bits = "21"
    type = "ro"
    shortdesc = '''This status is used to check DAT line level to recover from errors, and for debugging.'''
    longdesc = '''This is especially useful in detecting the busy signal level from DAT[0].'''
  [[register.field]]
    name = "SDIF_DAT0IN_DSYNC"
    bits = "20"
    type = "ro"
    shortdesc = '''This status is used to check DAT line level to recover from errors, and for debugging.'''
    longdesc = '''This is especially useful in detecting the busy signal level from DAT[0].'''
  [[register.field]]
    name = "SDIF_WP_DSYNC"
    bits = "19"
    type = "ro"
    shortdesc = '''The Write Protect Switch is supported for memory and combo cards.'''
    longdesc = '''This bit reflects the inversion of the SDx_WP pin. 0: Write protected, SDx_WP pin = High. 1: Write enabled, SDx_WP pin = Low.'''
  [[register.field]]
    name = "SDIF_CD_N_DSYNC"
    bits = "18"
    type = "ro"
    shortdesc = '''This bit reflects the inverse value of the SDCD# pin.'''
    longdesc = '''0: No Card present, SDx_CDn pin = High. 1: Card present, SDx_CDn pin = Low.'''
  [[register.field]]
    name = "SDHCCARDDET_STATESTABLE_DSYNC"
    bits = "17"
    type = "ro"
    shortdesc = '''This bit is used for testing.'''
    longdesc = '''If it is 0, the Card Detect Pin Level is not stable. If this bit is set to 1,it means the Card Detect Pin Level is stable. The Software Reset For All in the Software Reset Register shall not affect this bit.'0' Reset of Debouncing'1' No Card or Inserted'''
  [[register.field]]
    name = "SDHCCARDDET_INSERTED_DSYNC"
    bits = "16"
    type = "ro"
    shortdesc = '''Card insertion status flag.'''
    longdesc = '''Read-only. Changing from 0 to 1 generates a Card Insertion interrupt in the Normal Interrupt Status register. Changing from 1 to 0 generates a Card Removal interrupt in the Normal Interrupt Status register. The Software Reset For All in the Software Reset register does not affect this bit. If a Card is removed while its power is on and its clock is oscillating, the controller clears SD Bus Power in the Power Control register and SD Clock Enable in the Clock control register. In addition the Host Driver should clear the controller using the Software Reset For All in Software register. The card detect is active regardless of the SD Bus Power. 0: Reset or Debouncing or No Card. 1: Card Inserted.'''
  [[register.field]]
    name = "SDHCDMACTRL_PIOBUFRDENA"
    bits = "11"
    type = "ro"
    shortdesc = '''This status is used for non-DMA read transfers.'''
    longdesc = '''This read only flag indicates that valid data exists in the host side buffer status. If this bit is 1, readable data exists in the buffer. A change of this bit from 1 to 0 occurs when all the block data is read from the buffer. A change of this bit from 0 to 1 occurs when all the block data is ready in the buffer and generates the Buffer Read Ready Interrupt.'0' Read Disable'1' Read Enable'''
  [[register.field]]
    name = "SDHCDMACTRL_PIOBUFWRENA"
    bits = "10"
    type = "ro"
    shortdesc = '''This status flag is used with write transfers via register writes (not DMA).'''
    longdesc = '''Read-only. This flag indicates if space is available for writing data. 0: do not write to the register port. 1: data can be written to the buffer via the register port. A change from 1 to 0 indicates the buffer is full. A change from 0 to 1 occurs when top of block data can be written to the buffer and generates the Buffer Write Ready Interrupt.'''
  [[register.field]]
    name = "SDHCDMACTRL_RDXFERACTIVE"
    bits = "9"
    type = "ro"
    shortdesc = '''Completion of a read transfer flag.'''
    longdesc = '''Read-only. This bit is set to 1 for either of the following conditions: * After the end bit of the read command, or * When writing a 1 to continue Request in the Block Gap Control register to restart a read transfer. This bit is cleared to 0 for either of the following conditions: * When the last data block as specified by block length is transferred to the system, or * When all valid data blocks have been transferred to the system and no current block transfers are being sent as a result of the Stop At Block Gap Request set to 1. A transfer complete interrupt is generated when this bit changes to 0. 0: No valid data 1: Transferring data'''
  [[register.field]]
    name = "SDHCDMACTRL_WRXFERACTIVE"
    bits = "8"
    type = "ro"
    shortdesc = '''This status indicates a write transfer is active.'''
    longdesc = '''If this bit is 0, it means no valid write data exists in the HC. This bit is set in either of the following cases: * After the end bit of the write command. * When writing a 1 to Continue Request in the Block Gap Control register to restart a write transfer. This bit is cleared in either of the following cases: * After getting the CRC status of the last data block as specified by the transfer count (Single or Multiple) * After getting a CRC status of any block where data transmission is about to be stopped by a Stop At Block Gap Request. During a write transaction, a Block Gap Event interrupt is generated when this bit is changed to 0, as a result of the Stop At Block Gap Request being set. This status is useful for the HD in determining when to issue commands during write busy.'0' No valid data'1' Transferring data'''
  [[register.field]]
    name = "SDHCSDCTRL_RETUNINGREQ_DSYNC"
    bits = "3"
    type = "ro"
    shortdesc = '''Controller may request that the Host Driver executes the re-tuning sequence using this bit.'''
    longdesc = '''Re-tune the I/O timing when the data window is shifted by temperature changes or to improve timing margins to receive correct data. 0: Sampling clock is okay (it's fixed timing or well tuned). 1: Re-tune the sampling clock. This bit is set = 0 when a command is issued by setting the Execute Tuning bit in the Host Control 2 register. When software writes this bit from a 0 to 1 and [Sampling Clock Select] = 1 (not fixed sampling), the controller triggers the re-tune event. Refer to Normal Interrupt registers for more detail.'''
  [[register.field]]
    name = "SDHCDMACTRL_DATALINEACTIVE"
    bits = "2"
    type = "ro"
    shortdesc = '''SD_DAT signal I/O activity: 0: inactive.'''
    longdesc = '''1: active.'''
  [[register.field]]
    name = "PRESENTSTATE_INHIBITDAT"
    bits = "1"
    type = "ro"
    shortdesc = '''Dual purpose status indicator: * SD_DAT I/O is active, or * Read transfer Active is set to 1.'''
    longdesc = '''[ ] 0: controller can issue the next SD command. Commands with busy signal belong to Command Inhibit (DAT) (ex. R1b, R5b type). When the status indicator changes from a 0 to 1, the Transfer Complete interrupt asserts. Note: The SD Host Driver can save registers in the range of 000-00Dh; for a suspend transaction this bit changes from 1 to 0.'0' Can issue command which uses the DAT line'1' Cannot issue command which uses the DATline'''
  [[register.field]]
    name = "PRESENTSTATE_INHIBITCMD"
    bits = "0"
    type = "ro"
    shortdesc = '''Controller State.'''
    longdesc = '''0: The CMD line is not in use and the controller can issue a SD command using the CMD line. This bit is set immediately after the Command register (00Fh) is written. This bit is cleared when the command response is received. Even if the Command Inhibit (DAT) is set to 1, Commands using only the CMD line can be issued if this bit is 0. Changing from 1 to 0 generates a Command complete interrupt in the Normal Interrupt Status register. If the controller cannot issue the command because of a command conflict error or because of Command Not Issued By Auto CMD12 Error, this bit remains a 1 and the Command Complete interrupt is not set. Status issuing Auto CMD12 is not read from this bit. Auto CMD12 and Auto CMD23 consist of two responses. In this case, this bit is not cleared by the response of CMD12 or CMD23 but cleared by the response of a read/write command. Status issuing Auto CMD12 is not read from this bit. So if a command is issued during Auto CMD12 operation, controller issues two commands: CMD12 and a command set by Command register.'''
[[register]]
  name = "REG_HOSTCONTROL1"
  type = "rw"
  width = 8
  description = "Controller Configuration."
  default = "0x00000000"
  offset = "0x00000028"
  [[register.field]]
    name = "HOSTCTRL1_CDSIGSELECT"
    bits = "7"
    type = "rw"
    shortdesc = '''This bit selects source for card detection.'''
    longdesc = '''0: SD_CDn is selected (for normal use) 1: The card detect test level is selected'''
  [[register.field]]
    name = "HOSTCTRL1_CDTESTLEVEL"
    bits = "6"
    type = "rw"
    shortdesc = '''This bit is enabled while the Card Detect Signal Selection is set to 1 and it indicates card inserted or not.'''
    longdesc = '''Generates (card ins or card removal) interrupt when the normal int sts enable bit is set.'0' No Card'1' Card Inserted'''
  [[register.field]]
    name = "HOSTCTRL1_EXTDATAWIDTH"
    bits = "5"
    type = "rw"
    shortdesc = '''This bit controls 8-bit bus width mode for embedded device.'''
    longdesc = '''Support of this function is indicated in 8-bit Support for Embedded Device in the Capabilities register. If a device supports 8-bit bus mode, this bit may be set to 1. If this bit is 0, bus width is controlled by Data Transfer Width in the Host Control 1 register.This bit is not effective when multiple devices are installed on a bus slot (Slot Type is set to 10b in the Capabilities register). In this case, each device bus width is controlled by Bus Width Preset field in the Shared Bus register.'0' Bus width is selected by data transfer width'1' 8-bit bus width'''
  [[register.field]]
    name = "HOSTCTRL1_DMASELECT"
    bits = "4:3"
    type = "rw"
    shortdesc = '''One of supported DMA modes can be selected.'''
    longdesc = '''The host driver shall check support of DMA modes by referring the Capabilities register.'00' SDMA'01' 32 bit ADMA1 address'10' 32 bit ADMA2 address'11' 64 bit ADMA2 Address Note: Switching between 32-bit and 64-bit operation will require a reset. Write the [swreset_for_cmd] bit of SDHC register reg_software to reset.'''
  [[register.field]]
    name = "HOSTCTRL1_HIGHSPEEDENA"
    bits = "2"
    type = "rw"
    shortdesc = '''This bit is optional.'''
    longdesc = '''Before setting this bit, the driver shall check the High Speed Support in the capabilities register. If this bit is set to 0 (default), the HC outputs CMD line and DAT lines at the falling edge of the SD clock (up to 25 MHz/20MHz for MMC). If this bit is set to 1,the HC outputs CMD line and DAT lines at the rising edge of the SD clock (up to 50 MHz for SD/52MHz for MMC)/208Mhz (for SD3.0). If Preset Value Enable in the Host Control 2 register is set to 1, Host Driver needs to reset SD Clock Enable before changing this field to avoid generating clock glitches. After setting this field, the Host Driver sets SD Clock Enable again. 0: Normal Speed Mode. 1: High Speed Mode.'''
  [[register.field]]
    name = "HOSTCTRL1_DATAWIDTH"
    bits = "1"
    type = "rw"
    shortdesc = '''Select the data width of the controller.'''
    longdesc = '''The driver shall select it to match the data width of the SD card. 0: 1-bit mode 1: 4-bit mode'''
  [[register.field]]
    name = "HOSTCTRL1_LEDCONTROL"
    bits = "0"
    type = "rw"
    shortdesc = '''This bit is used to caution the user not to remove the card while the SD card is being accessed.'''
    longdesc = '''If the software is going to issue multiple SD commands, this bit can be set during all transactions. It is not necessary to change for each transaction.'0' LED Off'1' LED On'''
[[register]]
  name = "REG_POWERCONTROL"
  type = "rw"
  width = 8
  description = "SD Bus Power and Voltage Level."
  default = "0x00000000"
  offset = "0x00000029"
  [[register.field]]
    name = "EMMC_HWRESET"
    bits = "4"
    type = "rw"
  [[register.field]]
    name = "PWRCTRL_SDBUSVOLTAGE"
    bits = "3:1"
    type = "rw"
    shortdesc = '''By setting these bits, the HD selects the voltage level for the SD card.'''
    longdesc = '''Before setting this register, the HD shall check the voltage support bits in the capabilities register. If an unsupported voltage is selected, the Host System shall not supply SD bus voltage.'000'- '100' Reserved'101' 1.8V(Typ.)'110' 3.0V(Typ.)'111' 3.3V(Flattop.)'''
  [[register.field]]
    name = "PWRCTRL_SDBUSPOWER"
    bits = "0"
    type = "rw"
    shortdesc = '''Before setting this bit, the SD host driver shall set SD Bus Voltage Select.'''
    longdesc = '''If the HC detects the No Card State, this bit shall be cleared.'0' Power Off'1' Power On'''
[[register]]
  name = "REG_BLOCKGAPCONTROL"
  type = "mixed"
  width = 8
  description = "This register is used to program the block gap request, read wait control and interrupt at block gap"
  default = "0x00000080"
  offset = "0x0000002A"
  [[register.field]]
    name = "BLKGAPCTRL_BOOTACKENA"
    bits = "7"
    type = "rw"
    shortdesc = '''To check for the boot acknowledge in boot operation.'''
    longdesc = ''''0' Will not wait for boot ack from eMMC card,'1' Wait for boot ack from eMMC card'''
  [[register.field]]
    name = "BLKGAPCTRL_ALTBOOTMODE"
    bits = "6"
    type = "rw"
    shortdesc = '''To start boot code access in alternative mode.'''
    longdesc = ''''0' To stop alternative boot mode access,'1' To start alternative boot mode access'''
  [[register.field]]
    name = "BLKGAPCTRL_BOOTENABLE"
    bits = "5"
    type = "rw"
    shortdesc = '''To start boot code access.'''
    longdesc = ''''0' To stop boot code access,'1' To start boot code access'''
  [[register.field]]
    name = "BLKGAPCTRL_SPIMODE"
    bits = "4"
    type = "rw"
    shortdesc = '''SPI mode enable bit.'''
    longdesc = ''''0' SD Mode, '1' SPI Mode'''
  [[register.field]]
    name = "BLKGAPCTRL_INTERRUPT"
    bits = "3"
    type = "rw"
    shortdesc = '''This bit is valid only in 4-bit mode of the SDIO card and selects a sample point in the interrupt cycle.'''
    longdesc = '''Setting to 1 enables interrupt detection at the block gap for a multiple block transfer. If the SD card cannot signal an interrupt during a multiple block transfer, this bit should be set to 0. When the HD detects an SD card insertion, it shall set this bit according to the CCCR of the SDIO card.'''
  [[register.field]]
    name = "BLKGAPCTRL_RDWAITCTRL"
    bits = "2"
    type = "rw"
    shortdesc = '''The read wait function is optional for SDIO cards.'''
    longdesc = '''If the card supports read wait, set this bit to enable use of the read wait protocol to stop read data using DAT[2] line. Otherwise the HC has to stop the SD clock to hold read data, which restricts commands generation. When the HD detects an SD card insertion, it shall set this bit according to the CCCR of the SDIO card. If the card does not support read wait, this bit shall never be set to 1 otherwise DAT line conflict may occur. If this bit is set to 0, Suspend / Resume cannot be supported.'0' Disable Read-Wait Control'1' Enable Read-Wait Control'''
  [[register.field]]
    name = "BLKGAPCTRL_CONTINUE"
    bits = "1"
    type = "clronwr"
    shortdesc = '''This bit is used to restart a transaction which was stopped using the Stop At Block Gap Request.'''
    longdesc = '''To cancel stop at the block gap, set Stop At block Gap Request to 0 and set this bit to restart the transfer. The HC automatically clears this bit in either of the following cases: 1) In the case of a read transaction, the DAT Line Active changes from 0 to 1 as a read transaction restarts. 2) In the case of a write transaction, the Write transfer active changes from 0 to 1 as the write transaction restarts. Therefore it is not necessary for Host driver to set this bit to 0. If Stop At Block Gap Request is set to 1, any write to this bit is ignored.'0' Ignore'1' Restart'''
  [[register.field]]
    name = "BLKGAPCTRL_STOPATBLKGAP"
    bits = "0"
    type = "rw"
    shortdesc = '''Stop executing a transaction at the next block gap.'''
    longdesc = '''Applicable for non-DMA, SDMA, and ADMA transfers. Until the transfer complete is set to 1, indicating a transfer completion the Host Driver shall leave this bit set to 1. Clearing both the Stop At Block Gap Request and Continue Request shall not cause the transaction to restart. Read Wait is used to stop the read transaction at the block gap. The controller shall honour Stop At Block Gap Request for write transfers, but for read transfers it requires that the SD card support Read Wait. Therefore the Host Driver shall not set this bit during read transfers unless the SD card supports Read Wait and has set Read Wait Control to 1. In case of write transfers in which the HD writes data to the Buffer Data Port register, the HD shall set this bit after all block data is written. If this bit is set to 1, the HD shall not write data to Buffer data port register. This bit affects Read Transfer Active, Write Transfer Active, DAT line active and Command Inhibit (DAT) in the Present State register.'0' Transfer'1' Stop'''
[[register]]
  name = "REG_WAKEUPCONTROL"
  type = "rw"
  width = 8
  description = "Wakeup Functionality Control."
  default = "0x00000000"
  offset = "0x0000002B"
  [[register.field]]
    name = "WKUPCTRL_CARDREMOVAL"
    bits = "2"
    type = "rw"
    shortdesc = '''This bit enables wakeup event via Card Insertion assertion in the Normal Interrupt Status register.'''
    longdesc = '''FN_WUS (Wake up Support) in CIS does not affect this bit.'0' Disable'1' Enable'''
  [[register.field]]
    name = "WKUPCTRL_CARDINSERTION"
    bits = "1"
    type = "rw"
    shortdesc = '''This bit enables wakeup event via Card Insertion assertion in the Normal Interrupt Status register.'''
    longdesc = '''FN_WUS (Wake up Support) in CIS does not affect this bit.'0' Disable'1' Enable'''
  [[register.field]]
    name = "WKUPCTRL_CARDINTERRUPT"
    bits = "0"
    type = "rw"
    shortdesc = '''This bit enables wakeup event via Card Interrupt assertion in the Normal Interrupt Status register.'''
    longdesc = '''This bit can be set to 1 if FN_WUS (Wake Up Support) in CIS is set to 1.'0' Disable'1' Enable'''
[[register]]
  name = "REG_CLOCKCONTROL"
  type = "mixed"
  width = 16
  description = "Clock Frequency Control and State."
  default = "0x00000000"
  offset = "0x0000002C"
  [[register.field]]
    name = "CLKCTRL_SDCLKFREQSEL"
    bits = "15:8"
    type = "rw"
    shortdesc = '''This register is used to select the frequency of the SDCLK pin.'''
    longdesc = '''The frequency is not programmed directly; rather this register holds the divisor of the Base Clock Frequency For SD clock in the capabilities register. Only the following settings are allowed. (1) 8-bit Divided Clock Mode 80h - base clock divided by 256 40h - base clock divided by 128 20h - base clock divided by 64 10h - base clock divided by 32 08h - base clock divided by 16 04h - base clock divided by 8 02h - base clock divided by 4 01h - base clock divided by 2 00h - base clock(10MHz-63MHz) Setting 00h specifies the highest frequency of the SD Clock. When setting multiple bits, the most significant bit is used as the divisor. But multiple bits should not be set. The two default divider values can be calculated by the frequency that is defined by the Base Clock Frequency For SD Clock in the Capabilities register. 1) 25 MHz divider value. 2) 400 KHz divider value. The frequency of the SDCLK is set by the following formula: Clock Frequency = (Baseclock) / divisor. Thus choose the smallest possible divisor which results in a clock frequency that is less than or equal to the target frequency. Maximum Frequency for SD = 50Mhz (base clock) Maximum Frequency for MMC = 52Mhz (base clock) Minimum Frequency = 195.3125Khz (50Mhz / 256), same calculation for MMC also. (2) 10-bit Divided Clock Mode Host Controller Version 3.00 supports this mandatory mode instead of the 8-bit Divided Clock Mode. The length of divider is extended to10 bits and all divider values shall be supported. 3FFh --1/2046 Divided Clock N -------1/2N Divided Clock (Duty 50%) 002h -- 1/4 Divided Clock 001h ---1/2 Divided Clock 000h --- Base Clock (10MHz-254MHz)'''
  [[register.field]]
    name = "CLKCTRL_SDCLKFREQSEL_UPPERBITS"
    bits = "7:6"
    type = "rw"
  [[register.field]]
    name = "CLKCTRL_CLKGENSEL"
    bits = "5"
    type = "rw"
    shortdesc = '''This bit is used to select the clock generator mode in SDCLK Frequency Select.'''
    longdesc = '''If the Programmable Clock Mode is supported (non-zero value is set to Clock Multiplier in the Capabilities register), this bit attribute is RW, and if not supported, this bit attribute is RO and zero is read. This bit depends on the setting of Preset Value Enable in the Host Control 2 register. If the Preset Value Enable = 0, this bit is set by Host Driver. If the Preset Value Enable = 1, this bit is automatically set to a value specified in one of Preset Value registers.'0' Divided Clock Mode'1' Programmable Clock Mode'''
  [[register.field]]
    name = "CLKCTRL_SDCLKENA"
    bits = "2"
    type = "rw"
    shortdesc = '''The HC shall stop SDCLK when writing this bit to 0.'''
    longdesc = '''SDCLK frequency Select can be changed when this bit is 0. Then, the HC shall maintain the same clock frequency until SDCLK is stopped (Stop at SDCLK = 0). If the HC detects the No Card state, this bit shall be cleared.'0' Disable,'1' Enable'''
  [[register.field]]
    name = "SDHCCLKGEN_INTCLKSTABLE_DSYNC"
    bits = "1"
    type = "ro"
    shortdesc = '''This bit is set to 1 when SD clock is stable after writing to Internal Clock Enable in this register to 1.'''
    longdesc = '''The SD Host Driver shall wait to set SD Clock Enable until this bit is set to 1. Note: This is useful when using PLL for a clock oscillator that requires setup time.'0' Not Ready,'1' Ready'''
  [[register.field]]
    name = "CLKCTRL_INTCLKENA"
    bits = "0"
    type = "rw"
    shortdesc = '''This bit is set to 0 when the HD is not using the HC or the HC awaits a wakeup event.'''
    longdesc = '''The HC should stop its internal clock to go very low power state. Still, registers shall be able to be read and written. Clock starts to oscillate when this bit is set to 1. When clock oscillation is stable, the HC shall set Internal Clock Stable in this register to 1. This bit shall not affect card detection.'0' Stop,'1' Oscillate'''
[[register]]
  name = "REG_TIMEOUTCONTROL"
  type = "rw"
  width = 8
  description = "Set the Data Timeout Counter Value."
  default = "0x00000000"
  offset = "0x0000002E"
  [[register.field]]
    name = "TIMEOUT_CTRVALUE"
    bits = "3:0"
    type = "rw"
    shortdesc = '''This value determines the interval by which DAT line time-outs are detected.'''
    longdesc = '''Refer to the Data Time-out Error in the Error Interrupt Status register for information on factors that dictate time-out generation. Time-out clock frequency will be generated by dividing the sdclockTMCLK by this value. When setting this register, prevent inadvertent time-out events by clearing the Data Time-out Error Status Enable (in the Error Interrupt Status Enable register). 1111 - Reserved 1110 - TMCLK * 2^27 -------------------- -------------------- 0001 - TMCLK * 2^14 0000 - TMCLK * 2^13'''
[[register]]
  name = "REG_SOFTWARERESET"
  type = "clronwr"
  width = 8
  description = "Software reset for data, command and all."
  default = "0x00000000"
  offset = "0x0000002F"
  [[register.field]]
    name = "SWRESET_FOR_DAT"
    bits = "2"
    type = "clronwr"
    shortdesc = '''Only part of data circuit is reset.'''
    longdesc = '''The following registers and bits are cleared by this bit: Buffer Data Port Register: Buffer is cleared and Initialized. Present State register: Buffer read Enable, Buffer write Enable, Read Transfer Active, Write Transfer Active, DAT Line Active, Command Inhibit (DAT). Block Gap Control register: Continue Request, Stop At Block Gap Request. Normal Interrupt Status register: Buffer Read Ready, Buffer Write Ready, Block Gap Event, Transfer Complete. 0: Operational. 1: Held in reset.'''
  [[register.field]]
    name = "SWRESET_FOR_CMD"
    bits = "1"
    type = "clronwr"
    shortdesc = '''Only part of command circuit is reset.'''
    longdesc = '''The following registers and bits are cleared by this bit: Present State register- Command Inhibit (CMD). Normal Interrupt Status register- Command Complete. 0: Operational. 1: Held in reset.'''
  [[register.field]]
    name = "SWRESET_FOR_ALL"
    bits = "0"
    type = "clronwr"
    shortdesc = '''This reset affects the entire HC except for the card detection circuit.'''
    longdesc = '''Register bits of type ROC, RW, RW1C, RWAC are cleared to 0. During its initialization, the HD shall set this bit to 1 to reset the HC. The HC shall reset this bit to 0 when capabilities registers are valid and the HD can read them. Additional use of Software Reset For All may not affect the value of the Capabilities registers. If this bit is set to 1, the SD card shall reset itself and must be re initialized by the HD. 0: Operational. 1: Held in reset.'''
[[register]]
  name = "REG_NORMALINTRSTS"
  type = "mixed"
  width = 16
  description = "Status of all Interrupts"
  default = "0x00000000"
  offset = "0x00000030"
  [[register.field]]
    name = "REG_ERRORINTRSTS"
    bits = "15"
    type = "ro"
    shortdesc = '''Or of all bits in the Error Interrupt Status Register.'''
    longdesc = ''''0' No error'1' Error'''
  [[register.field]]
    name = "NORMALINTRSTS_BOOTCOMPLETE"
    bits = "14"
    type = "wtc"
    shortdesc = '''This status is set if the boot operation gets terminated.'''
    longdesc = ''''0' Boot operation is not terminated'1' Boot operation is terminated'''
  [[register.field]]
    name = "NORMALINTRSTS_RCVBOOTACK"
    bits = "13"
    type = "wtc"
    shortdesc = '''This status is set if the boot acknowledge is received from device.'''
    longdesc = ''''0' Boot ack not recieved'1' Boot ack is recieved'''
  [[register.field]]
    name = "NORMALINTRSTS_RETUNINGEVENT"
    bits = "12"
    type = "ro"
    shortdesc = '''This status is set if Re-Tuning Request in the Present State register changes from 0 to 1.'''
    longdesc = '''Host Controller requests Host Driver to perform re-tuning for next data transfer. Current data transfer (not large block count) can be completed without re-tuning.'0' Re-tuning not required'1' Re-tuning should be performed'''
  [[register.field]]
    name = "NORMALINTRSTS_INTC"
    bits = "11"
    type = "ro"
    shortdesc = '''This status is set if INT_C is enabled and INT_C# pin is in low level.'''
    longdesc = '''Writing this bit to 1 does not clear this bit. It is cleared by resetting the INT_C interrupt factor.'''
  [[register.field]]
    name = "NORMALINTRSTS_INTB"
    bits = "10"
    type = "ro"
    shortdesc = '''This status is set if INT_B is enabled and INT_B# pin is in low level.'''
    longdesc = '''Writing this bit to 1 does not clear this bit. It is cleared by resetting the INT_B interrupt factor.'''
  [[register.field]]
    name = "NORMALINTRSTS_INTA"
    bits = "9"
    type = "ro"
    shortdesc = '''This status is set if INT_A is enabled and INT_A# pin is in low level.'''
    longdesc = '''Writing this bit to 1 does not clear this bit. It is cleared by resetting the INT_A interrupt factor. NOTE: INT_A, INT_B, and INT_C are to be implemented based on the Application Requirements. By default these are not implemented as there is no specific requirement from Customers.'''
  [[register.field]]
    name = "NORMALINTRSTS_CARDINTSTS"
    bits = "8"
    type = "ro"
    shortdesc = '''Writing this bit to 1 does not clear this bit.'''
    longdesc = '''It is cleared by resetting the SD card interrupt factor. In 1-bit mode, the HC shall detect the Card Interrupt without SD Clock to support wakeup. In 4-bit mode, the card interrupt signal is sampled during the interrupt cycle, so there are some sample delays between the interrupt signal from the card and the interrupt to theHost system. when this status has been set and the HD needs to start this interrupt service, Card Interrupt Status Enable in the Normal Interrupt Status register shall be set to 0 in order to clear the card interrupt statuses latched in the HC and stop driving the Host System. After completion of the card interrupt service (the reset factor in the SD card and the interrupt signal may not be asserted), set Card Interrupt Status Enable to 1 and start sampling the interrupt signal again. Interrupt detected by DAT[1] is supported when there is a card per slot. In case of shared bus, interrupt pins are used to detect interrupts. If 000b is set to Interrupt Pin Select in the Shared Bus Control register, this status is effective. Non-zero value is set to Interrupt Pin Select, INT_A, INT_B or INT_C is then used to device interrupts. Card Interrupt: 0: inactive. 1: active.'''
  [[register.field]]
    name = "NORMALINTRSTS_CARDREMSTS"
    bits = "7"
    type = "wtc"
    shortdesc = '''This status is set if the Card Inserted in the Present State register changes from 1 to 0.'''
    longdesc = '''When the HD writes this bit to 1 to clear this status the status of the Card Inserted in the Present State register should be confirmed. Because the card detect may possibly be changed when the HD clear this bit an Interrupt event may not be generated.'0' Card State Stable or Debouncing'1' Card Removed'''
  [[register.field]]
    name = "NORMALINTRSTS_CARDINSSTS"
    bits = "6"
    type = "wtc"
    shortdesc = '''This status is set if the Card Inserted in the Present State register changes from 0 to 1.'''
    longdesc = '''When the HD writes this bit to 1 to clear this status the status of the Card Inserted in the Present State register should be confirmed. Because the card detect may possibly be changed when the HD clear this bit an Interrupt event may not be generated.'0' Card State Stable or Debouncing'1' Card Inserted'''
  [[register.field]]
    name = "NORMALINTRSTS_BUFRDREADY"
    bits = "5"
    type = "wtc"
    shortdesc = '''This status is set if the Buffer Read Enable changes from 0 to 1.'''
    longdesc = ''''0' Not ready to read buffer,'1' Ready to read buffer'''
  [[register.field]]
    name = "NORMALINTRSTS_BUFWRREADY"
    bits = "4"
    type = "wtc"
    shortdesc = '''This status is set if the Buffer Write Enable changes from 0 to 1.'''
    longdesc = ''''0' Not ready to write to buffer, '1' Ready to write to buffer'''
  [[register.field]]
    name = "NORMALINTRSTS_DMAINTERRUPT"
    bits = "3"
    type = "wtc"
    shortdesc = '''This status is set if the HC detects the Host DMA Buffer Boundary in the Block Size regiser.'''
    longdesc = ''''0' No DMA Interrupt'1' DMA Interrupt is generated'''
  [[register.field]]
    name = "NORMALINTRSTS_BLKGAPEVENT"
    bits = "2"
    type = "wtc"
    shortdesc = '''If the Stop At Block Gap Request in the BlockGap Control Register is set, this bit is set.'''
    longdesc = '''Read Transaction: This bit is set at the falling edge of the DAT Line Active Status (When the transaction is stopped at SD Bus timing. The Read Wait must be supported inorder to use this function). Write Transaction: This bit is set at the falling edge of Write Transfer Active Status (After getting CRC status at SD Bus timing).'0' No Block Gap Event'1' Transaction stopped at Block Gap'''
  [[register.field]]
    name = "NORMALINTRSTS_XFERCOMPLETE"
    bits = "1"
    type = "wtc"
    shortdesc = '''This bit is set when a read / write transaction is completed.'''
    longdesc = '''Read Transaction: This bit is set at the falling edge of Read Transfer Active Status. There are two cases in which the Interrupt is generated. The first is when a data transfer is completed as specified by data length (After the last data has been read to the Host Sys- tem). The second is when data has stopped at the block gap and completed the data transfer by setting the Stop At Block Gap Request in the Block Gap Control Register (After valid data has been read to the Host System). Write Transaction: This bit is set at the falling edge of the DAT Line Active Status. There are two cases in which the Interrupt is generated. The first is when the last data is written to the card as specified by data length and Busy signal is released. The second is when data transfers are stopped at the block gap by setting Stop At Block Gap Request in the Block Gap Control Register and data transfers completed. (After valid data is written to the SD card and the busy signal is released). Note: Transfer Complete has higher priority than Data Time-out Error. If both bits are set to 1, the data transfer can be considered complete. Note: While performing tuning procedure (Execute Tuning is set to 1), Transfer Complete is not set to 1'0' No Data Transfer Complete,'1' Data Transfer Complete'''
  [[register.field]]
    name = "NORMALINTRSTS_CMDCOMPLETE"
    bits = "0"
    type = "wtc"
    shortdesc = '''This bit is set when we get the end bit of the command response (Except Auto CMD12 and Auto CMD23) Note: Command Time-out Error has higher priority than Command Complete.'''
    longdesc = '''If both are set to 1, it can be considered that the response was not received correctly.'0' No Command Complete,'1' Command Complete'''
[[register]]
  name = "REG_ERRORINTRSTS"
  type = "wtc"
  width = 16
  description = "Error Interrupts Status"
  default = "0x00000000"
  offset = "0x00000032"
  [[register.field]]
    name = "ERRORINTRSTS_HOSTERROR"
    bits = "12"
    type = "wtc"
  [[register.field]]
    name = "ERRORINTRSTS_ADMAERROR"
    bits = "9"
    type = "wtc"
    shortdesc = '''This bit is set when the Host Controller detects errors during ADMA based data transfer.'''
    longdesc = '''The state of the ADMA at an error occurrence is saved in the ADMA Error Status Register.'0' No error'1' Error'''
  [[register.field]]
    name = "ERRORINTRSTS_AUTOCMDERROR"
    bits = "8"
    type = "wtc"
    shortdesc = '''Auto CMD12 and Auto CMD23 use this error status.'''
    longdesc = '''This bit is set when detecting that one of the bits D00-D04 in Auto CMD Error Status register has changed from 0 to 1. In case of Auto CMD12, this bit is set to 1, not only when the errors in Auto CMD12 occur but also when Auto CMD12 is not executed due to the previous command error.'0' No error'1' Error'''
  [[register.field]]
    name = "ERRORINTRSTS_CURRLIMITERROR"
    bits = "7"
    type = "wtc"
    shortdesc = '''By setting the SD Bus Power bit in the Power Control Register, the HC is requested to supply power for the SD Bus.'''
    longdesc = '''If the HC supports the Current Limit Function, it can be protected from an Illegal card by stopping power supply to the card in which case this bit indicates a failure status. Reading 1 means the HC is not supplying power to SD card due to some failure. Reading 0 means that the HC is supplying power and no error has occurred. This bit shall always set to be 0, if the HC does not support this function.'0' No error'1' Power Fail Note: The current_Limit_Error is to be implemented if customer application requires it. By default it is not implemented as there is no specific requirement from Customers.'''
  [[register.field]]
    name = "ERRORINTRSTS_DATAENDBITERROR"
    bits = "6"
    type = "wtc"
  [[register.field]]
    name = "ERRORINTRSTS_DATACRCERROR"
    bits = "5"
    type = "wtc"
    shortdesc = '''Occurs when detecting CRC error when transferring read data which uses the DAT line or when detecting the Write CRC Status having a value of other than '010'.'''
    longdesc = ''''0' No error'1' Error'''
  [[register.field]]
    name = "ERRORINTRSTS_DATATIMEOUTERROR"
    bits = "4"
    type = "wtc"
    shortdesc = '''Occurs when detecting one of following timeout conditions: 1.'''
    longdesc = '''Busy Timeout for R1b, R5b type. 2. Busy Timeout after Write CRC status 3. Write CRC status Timeout 4. Read Data Timeout.'0' No Error'1' Timeout'''
  [[register.field]]
    name = "ERRORINTRSTS_CMDINDEXERROR"
    bits = "3"
    type = "wtc"
    shortdesc = '''Occurs if a Command Index error occurs in the Command Response.'''
    longdesc = ''''0' No Error'1' Error'''
  [[register.field]]
    name = "ERRORINTRSTS_CMDENDBITERROR"
    bits = "2"
    type = "wtc"
    shortdesc = '''Occurs when detecting that the end bit of a command response is 0.'''
    longdesc = ''''0' No Error, '1' End bit error generated'''
  [[register.field]]
    name = "ERRORINTRSTS_CMDCRCERROR"
    bits = "1"
    type = "wtc"
    shortdesc = '''Command CRC Error is generated in two cases.'''
    longdesc = '''1. If a response is returned and the Command Time-out Error is set to 0, this bit is set to 1 when detecting a CRT error in the command response 2. The HC detects a CMD line conflict by monitoring the CMD line when a command is issued. If the HC drives the CMD line to 1 level, but detects 0 level on the CMD line at the next SDCLK edge, then the HC shall abort the command (Stop driving CMD line) and set this bit to 1. The Command Timeout Error shall also be set to 1 to distinguish CMD line conflict.'0' No Error,'1' CRC Error'''
  [[register.field]]
    name = "ERRORINTRSTS_CMDTIMEOUTERROR"
    bits = "0"
    type = "wtc"
    shortdesc = '''Occurs only if the no response is returned within 64 SDCLK cycles from the end bit of the command.'''
    longdesc = '''If the HC detects a CMD line conflict, in which case Command CRC Error shall also be set. This bit shall be set without waiting for 64 SDCLK cycles because the command will be aborted by the HC.'0' Error'1' Timeout'''
[[register]]
  name = "REG_NORMALINTRSTSENA"
  type = "mixed"
  width = 16
  description = "Normal-type Interrupts Status Enables."
  default = "0x00000000"
  offset = "0x00000034"
  [[register.field]]
    name = "NORMALINTRSTS_ENABLEREGBIT15"
    bits = "15"
    type = "ro"
  [[register.field]]
    name = "NORMALINTRSTS_ENABLEREGBIT14"
    bits = "14"
    type = "rw"
  [[register.field]]
    name = "NORMALINTRSTS_ENABLEREGBIT13"
    bits = "13"
    type = "rw"
  [[register.field]]
    name = "NORMALINTRSTS_ENABLEREGBIT12"
    bits = "12"
    type = "rw"
  [[register.field]]
    name = "NORMALINTRSTS_ENABLEREGBIT11"
    bits = "11"
    type = "rw"
    shortdesc = '''If this bit is set to 0, the Host Controller shall clear the interrupt request to the System.'''
    longdesc = '''The Host Driver may clear this bit before servicing the INT_C and may set this bit again after all interrupt requests to INT_C pin are cleared to prevent inadvertent interrupts.'''
  [[register.field]]
    name = "NORMALINTRSTS_ENABLEREGBIT10"
    bits = "10"
    type = "rw"
    shortdesc = '''If this bit is set to 0, the Host Controller shall clear the interrupt request to the System.'''
    longdesc = '''The Host Driver may clear this bit before servicing the INT_B and may set this bit again after all interrupt requests to INT_B pin are cleared to prevent inadvertent interrupts.'''
  [[register.field]]
    name = "NORMALINTRSTS_ENABLEREGBIT9"
    bits = "9"
    type = "rw"
    shortdesc = '''If this bit is set to 0, the Host Controller shall clear the interrupt request to the System.'''
    longdesc = '''The Host Driver may clear this bit before servicing the INT_A and may set this bit again after all interrupt requests to INT_A pin are cleared to prevent inadvertent interrupts.'''
  [[register.field]]
    name = "SDHCREGSET_CARDINTSTSENA"
    bits = "8"
    type = "rw"
    shortdesc = '''If this bit is set to 0, the HC shall clear Interrupt request to the System.'''
    longdesc = '''The Card Interruptdetection is stopped when this bit is cleared and restarted when this bit is set to 1. The HD may clear the Card Interrupt Status Enable before servicing the Card Interrupt and may set this bit again after all Interrupt requests from the card are cleared to prevent inadvertent Interrupts.'''
  [[register.field]]
    name = "SDHCREGSET_CARDREMSTSENA"
    bits = "7"
    type = "rw"
  [[register.field]]
    name = "SDHCREGSET_CARDINSSTSENA"
    bits = "6"
    type = "rw"
  [[register.field]]
    name = "NORMALINTRSTS_ENABLEREGBIT5"
    bits = "5"
    type = "rw"
  [[register.field]]
    name = "NORMALINTRSTS_ENABLEREGBIT4"
    bits = "4"
    type = "rw"
  [[register.field]]
    name = "NORMALINTRSTS_ENABLEREGBIT3"
    bits = "3"
    type = "rw"
  [[register.field]]
    name = "NORMALINTRSTS_ENABLEREGBIT2"
    bits = "2"
    type = "rw"
  [[register.field]]
    name = "NORMALINTRSTS_ENABLEREGBIT1"
    bits = "1"
    type = "rw"
  [[register.field]]
    name = "NORMALINTRSTS_ENABLEREGBIT0"
    bits = "0"
    type = "rw"
[[register]]
  name = "REG_ERRORINTRSTSENA"
  type = "rw"
  width = 16
  description = "Error-type Interrupts Status Enables."
  default = "0x00000000"
  offset = "0x00000036"
  [[register.field]]
    name = "ERRORINTRSTS_ENABLEREGBIT12"
    bits = "12"
    type = "rw"
  [[register.field]]
    name = "ERRORINTRSTS_ENABLEREGBIT10"
    bits = "10"
    type = "rw"
  [[register.field]]
    name = "ERRORINTRSTS_ENABLEREGBIT9"
    bits = "9"
    type = "rw"
  [[register.field]]
    name = "ERRORINTRSTS_ENABLEREGBIT8"
    bits = "8"
    type = "rw"
  [[register.field]]
    name = "ERRORINTRSTS_ENABLEREGBIT7"
    bits = "7"
    type = "rw"
  [[register.field]]
    name = "ERRORINTRSTS_ENABLEREGBIT6"
    bits = "6"
    type = "rw"
  [[register.field]]
    name = "ERRORINTRSTS_ENABLEREGBIT5"
    bits = "5"
    type = "rw"
  [[register.field]]
    name = "ERRORINTRSTS_ENABLEREGBIT4"
    bits = "4"
    type = "rw"
  [[register.field]]
    name = "ERRORINTRSTS_ENABLEREGBIT3"
    bits = "3"
    type = "rw"
  [[register.field]]
    name = "ERRORINTRSTS_ENABLEREGBIT2"
    bits = "2"
    type = "rw"
  [[register.field]]
    name = "ERRORINTRSTS_ENABLEREGBIT1"
    bits = "1"
    type = "rw"
  [[register.field]]
    name = "ERRORINTRSTS_ENABLEREGBIT0"
    bits = "0"
    type = "rw"
[[register]]
  name = "REG_NORMALINTRSIGENA"
  type = "mixed"
  width = 16
  description = "Normal-type Interrupts Signal Enables."
  default = "0x00000000"
  offset = "0x00000038"
  [[register.field]]
    name = "NORMALINTRSIG_ENABLEREGBIT15"
    bits = "15"
    type = "ro"
  [[register.field]]
    name = "NORMALINTRSIG_ENABLEREGBIT14"
    bits = "14"
    type = "rw"
  [[register.field]]
    name = "NORMALINTRSIG_ENABLEREGBIT13"
    bits = "13"
    type = "rw"
  [[register.field]]
    name = "NORMALINTRSIG_ENABLEREGBIT12"
    bits = "12"
    type = "rw"
  [[register.field]]
    name = "NORMALINTRSIG_ENABLEREGBIT11"
    bits = "11"
    type = "rw"
  [[register.field]]
    name = "NORMALINTRSIG_ENABLEREGBIT10"
    bits = "10"
    type = "rw"
  [[register.field]]
    name = "NORMALINTRSIG_ENABLEREGBIT9"
    bits = "9"
    type = "rw"
  [[register.field]]
    name = "NORMALINTRSIG_ENABLEREGBIT8"
    bits = "8"
    type = "rw"
  [[register.field]]
    name = "NORMALINTRSIG_ENABLEREGBIT7"
    bits = "7"
    type = "rw"
  [[register.field]]
    name = "NORMALINTRSIG_ENABLEREGBIT6"
    bits = "6"
    type = "rw"
  [[register.field]]
    name = "NORMALINTRSIG_ENABLEREGBIT5"
    bits = "5"
    type = "rw"
  [[register.field]]
    name = "NORMALINTRSIG_ENABLEREGBIT4"
    bits = "4"
    type = "rw"
  [[register.field]]
    name = "NORMALINTRSIG_ENABLEREGBIT3"
    bits = "3"
    type = "rw"
  [[register.field]]
    name = "NORMALINTRSIG_ENABLEREGBIT2"
    bits = "2"
    type = "rw"
  [[register.field]]
    name = "NORMALINTRSIG_ENABLEREGBIT1"
    bits = "1"
    type = "rw"
  [[register.field]]
    name = "NORMALINTRSIG_ENABLEREGBIT0"
    bits = "0"
    type = "rw"
[[register]]
  name = "REG_ERRORINTRSIGENA"
  type = "mixed"
  width = 16
  description = "Error-type Interrupts Signal Enables."
  default = "0x00000000"
  offset = "0x0000003A"
  [[register.field]]
    name = "ERRORINTRSIG_ENABLEREGBIT12"
    bits = "12"
    type = "ro"
  [[register.field]]
    name = "ERRORINTRSIG_ENABLEREGBIT10"
    bits = "10"
    type = "rw"
  [[register.field]]
    name = "ERRORINTRSIG_ENABLEREGBIT9"
    bits = "9"
    type = "rw"
  [[register.field]]
    name = "ERRORINTRSIG_ENABLEREGBIT8"
    bits = "8"
    type = "rw"
  [[register.field]]
    name = "ERRORINTRSIG_ENABLEREGBIT7"
    bits = "7"
    type = "rw"
  [[register.field]]
    name = "ERRORINTRSIG_ENABLEREGBIT6"
    bits = "6"
    type = "rw"
  [[register.field]]
    name = "ERRORINTRSIG_ENABLEREGBIT5"
    bits = "5"
    type = "rw"
  [[register.field]]
    name = "ERRORINTRSIG_ENABLEREGBIT4"
    bits = "4"
    type = "rw"
  [[register.field]]
    name = "ERRORINTRSIG_ENABLEREGBIT3"
    bits = "3"
    type = "rw"
  [[register.field]]
    name = "ERRORINTRSIG_ENABLEREGBIT2"
    bits = "2"
    type = "rw"
  [[register.field]]
    name = "ERRORINTRSIG_ENABLEREGBIT1"
    bits = "1"
    type = "rw"
  [[register.field]]
    name = "ERRORINTRSIG_ENABLEREGBIT0"
    bits = "0"
    type = "rw"
[[register]]
  name = "REG_AUTOCMDERRSTS"
  type = "ro"
  width = 16
  description = "CMD12 response error of Auto CMD12 and CMD23."
  default = "0x00000000"
  offset = "0x0000003C"
  [[register.field]]
    name = "AUTOCMDERRSTS_NEXTERROR"
    bits = "7"
    type = "ro"
    shortdesc = '''Setting this bit to 1 means CMD_wo_DAT is not executed due to an Auto CMD12 error (D04- D01) in this register.'''
    longdesc = '''This bit is set to 0 when Auto CMD Error is generated by Auto CMD23.'0' No Error'1' Not Issued'''
  [[register.field]]
    name = "AUTOCMDERRSTS_INDEXERROR"
    bits = "4"
    type = "ro"
    shortdesc = '''Occurs if the Command Index error occurs in response to a command.'''
    longdesc = ''''0' No Error,'1' Error.'''
  [[register.field]]
    name = "AUTOCMDERRSTS_ENDBITERROR"
    bits = "3"
    type = "ro"
    shortdesc = '''Occurs when detecting that the end bit of command response is 0.'''
    longdesc = ''''0' No Error,'1' End Bit Error Generated'''
  [[register.field]]
    name = "AUTOCMDERRSTS_CRCERROR"
    bits = "2"
    type = "ro"
    shortdesc = '''Occurs when detecting a CRC error in the command response.'''
    longdesc = ''''0' No error'1' CRC Error Generated'''
  [[register.field]]
    name = "AUTOCMDERRSTS_TIMEOUTERROR"
    bits = "1"
    type = "ro"
    shortdesc = '''Occurs if the no response is returned within 64 SDCLK cycles from the end bit of the command.'''
    longdesc = '''If this bit is set to 1, the other error status bits (D04 - D02) are meaningless.'0' No error'1' Timeout'''
  [[register.field]]
    name = "AUTOCMDERRSTS_NOTEXECERROR"
    bits = "0"
    type = "ro"
    shortdesc = '''If memory multiple block data transfer is not started due to command error, this bit is not set because it is not necessary to issue Auto CMD12.'''
    longdesc = '''Setting this bit to 1 means the HC cannot issue Auto CMD12 to stop memory multiple block transfer due to some error. If this bit is set to 1, other error status bits (D04 - D01) are meaningless. This bit is set to 0 when Auto CMD Error is generated by Auto CMD23'0' Executed, '1' Not Executed'''
[[register]]
  name = "REG_HOSTCONTROL2"
  type = "mixed"
  width = 16
  description = "UHS Mode, I/O Drive, Tuning, Clocking, Intr, and Presets."
  default = "0x00000000"
  offset = "0x0000003E"
  [[register.field]]
    name = "HOSTCTRL2_PRESETVALUEENABLE"
    bits = "15"
    type = "rw"
    shortdesc = '''Host Controller Version 3.'''
    longdesc = '''00 supports this bit. As the operating SDCLK frequency and I/O driver strength depend on the Host System implementation, it is difficult to determine these parameters in the Standard Host Driver. When Preset Value Enable is set to automatic. This bit enables the functions defined in the Preset Value registers.'0' SDCLK and Driver Strength are controlled by Host Driver.'1' Automatic Selection by Preset Value are Enabled. If this bit is set to 0, SDCLK Frequency Select, Clock Generator Select in the Clock Control register and Driver Strength Select in Host Control 2 register are set by Host Driver. If this bit is set to 1, SDCLK Frequency Select, Clock Generator Select in the Clock Control register and Driver Strength Select in Host Control 2 register are set by Host Controller as specified in the Preset Value registers.'''
  [[register.field]]
    name = "HOSTCTRL2_ASYNCHINTRENABLE"
    bits = "14"
    type = "rw"
    shortdesc = '''This bit can be set to 1 if a card support asynchronous interrupt and Asynchronous Interrupt Support is set to 1 in the Capabilities register.'''
    longdesc = '''Asynchronous interrupt is effective when DAT[1] interrupt is used in 4-bit SD mode (and zero is set to Interrupt Pin Select in the Shared Bus Control register). If this bit is set to 1, the Host Driver can stop the SDCLK during asynchronous interrupt period to save power. During this period, the Host Controller continues to deliver Card Interrupt to the host when it is asserted by the Card.'0' Disabled'1' Enabled'''
  [[register.field]]
    name = "HOSTCTRL2_SAMPLINGCLKSELECT"
    bits = "7"
    type = "rw"
    shortdesc = '''This bit is set by tuning procedure when Execute Tuning is cleared.'''
    longdesc = '''Writing 1 to this bit is meaningless and ignored. Setting 1 means that tuning is completed successfully and setting 0 means that tuning is failed. Host Controller uses this bit to select sampling clock to receive CMD and DAT. This bit is cleared by writing 0. Change of this bit is not allowed while the Host Controller is receiving response or a read data block.'0' Fixed clock is used to sample data'1' Tuned clock is used to sample data'''
  [[register.field]]
    name = "HOSTCTRL2_EXECUTETUNING"
    bits = "6"
    type = "clronwr"
    shortdesc = '''This bit is set to 1 to start tuning procedure and automatically cleared when tuning procedure is completed.'''
    longdesc = '''The result of tuning is indicated to Sampling Clock Select. Tuning procedure is aborted by writing 0 for more detail about tuning procedure.'0' Not Tuned or Tuning Completed'1' Execute Tuning'''
  [[register.field]]
    name = "HOSTCTRL2_DRIVERSTRENGTH"
    bits = "5:4"
    type = "rw"
    shortdesc = '''Output driver for 1.'''
    longdesc = '''8V signaling. In 3.3V signaling, this field is not effective. This field can be set to driver type A, B, C, or D. This bit depends on setting of Preset Value Enable: If Preset Value Enable = 0, this field is set by Host Driver. If Preset Value Enable = 1, this field is automatically set by the hardware to a value specified in the selected Preset Value register. 00: Driver Type B (default) 01: Driver Type A 10: Driver Type C 11: Driver Type D'''
  [[register.field]]
    name = "HOSTCTRL2_1P8VSIGNALLINGENA"
    bits = "3"
    type = "rw"
    shortdesc = '''This bit controls voltage regulator for I/O cell.'''
    longdesc = '''3.3V is supplied to the card regardless of signaling voltage. Setting this bit from 0 to 1 starts changing signal voltage from 3.3V to 1.8V. 1.8V regulator output shall be stable within 5ms. Host Controller clears this bit if switching to 1.8V signaling fails. Clearing this bit from 1 to 0 starts changing signal voltage from 1.8V to 3.3V. 3.3V regulator output shall be stable within 5ms. Host Driver can set this bit to 1 when Host Controller supports 1.8V signaling (One of support bits is set to 1: SDR50, SDR104 or DDR50 in the Capabilities register) and the card or device supports UHS-I.'0' 3.3V Signalling, '1' 1.8V Signalling'''
  [[register.field]]
    name = "HOSTCTRL2_UHSMODESELECT"
    bits = "2:0"
    type = "rw"
    shortdesc = '''This field is used to select one of UHS-I modes and effective when 1.'''
    longdesc = '''8V Signaling Enable is set to 1.If Preset Value Enable in the Host Control 2 register is set to 1, Host Controller sets SDCLK Frequency Select, Clock Generator Select in the Clock Control register and Driver Strength Select according to Preset Value registers. In this case, one of preset value registers is selected by this field. Host Driver needs to reset SD Clock Enable before changing this field to avoid generating clock glitch. After setting this field, Host Driver sets SD Clock Enable again. 000: SDR12 001: SDR25 010: SDR50 011: SDR104 100: DDR50 101 - 111: Reserved. When SDR50, SDR104 or DDR50 is selected for SDIO card, interrupt detection at the block gap shall not be used. Read Wait timing is changed for these modes. Refer to the SDIO Specification Version 3.00 for more detail.'''
[[register]]
  name = "REG_CAPABILITIES"
  type = "ro"
  width = 64
  description = "Host controller implementation."
  default = "0x280737EC6481"
  offset = "0x00000040"
  [[register.field]]
    name = "CORECFG_SPIBLKMODE"
    bits = "57"
    type = "ro"
  [[register.field]]
    name = "CORECFG_SPISUPPORT"
    bits = "56"
    type = "ro"
  [[register.field]]
    name = "CORECFG_CLOCKMULTIPLIER"
    bits = "55:48"
    type = "ro"
  [[register.field]]
    name = "CORECFG_RETUNINGMODES"
    bits = "47:46"
    type = "ro"
    shortdesc = '''This field defines the re-tuning capability of a Host Controller and how to manage the data transfer length and a Re-Tuning Timer by the Host Driver.'''
    longdesc = '''00: Mode 1 01: Mode 2 10: Mode 3 11: reserved. There are two re-tuning timings:Re-Tuning Request and expiration of a Re-Tuning Timer. By receiving either timing, the Host Driver executes the re-tuning procedure just before a next command issue.'''
  [[register.field]]
    name = "CORECFG_TUNINGFORSDR50"
    bits = "45"
    type = "ro"
  [[register.field]]
    name = "CORECFG_RETUNINGTIMERCNT"
    bits = "43:40"
    type = "ro"
    shortdesc = '''This field indicates an initial value of the Re-Tuning Timer for Re-Tuning Mode 1 to 3.'''
    longdesc = '''0h: Get information via other source 1h: 1 seconds 2h: 2 seconds 3h: 4 seconds 4h: 8 seconds ------ nh: 2 (n-1) seconds ------ Bh: 1024 seconds Others: reserved'''
  [[register.field]]
    name = "CORECFG_DDRIVERSUPPORT"
    bits = "38"
    type = "ro"
    shortdesc = '''Driver Type D (1.'''
    longdesc = '''8 Signaling) is not supported.'''
  [[register.field]]
    name = "CORECFG_CDRIVERSUPPORT"
    bits = "37"
    type = "ro"
    shortdesc = '''Driver Type C (1.'''
    longdesc = '''8 Signaling) is not supported.'''
  [[register.field]]
    name = "CORECFG_ADRIVERSUPPORT"
    bits = "36"
    type = "ro"
    shortdesc = '''Driver Type A (for 1.'''
    longdesc = '''8 Signaling) is not supported.'''
  [[register.field]]
    name = "CORECFG_DDR50SUPPORT"
    bits = "34"
    type = "ro"
  [[register.field]]
    name = "CORECFG_SDR104SUPPORT"
    bits = "33"
    type = "ro"
  [[register.field]]
    name = "CORECFG_SDR50SUPPORT"
    bits = "32"
    type = "ro"
  [[register.field]]
    name = "CORECFG_SLOTTYPE"
    bits = "31:30"
    type = "ro"
    shortdesc = '''This field indicates usage of a slot by a specific Host System.'''
    longdesc = '''(A host controller register set is defined perslot.) Embedded slot for one device (01b) means that only one non-removable device is connected to a SD bus slot. Shared Bus Slot (10b) can be set if Host Controller supports Shared Bus Control register. The Standard Host Driver controls only a removable card or one embedded device is connected to a SD bus slot. If a slot is configured for shared bus (10b), the Standard Host Driver does not control embedded devices connected to a shared bus. Shared bus slot is controlled by a specific host driver developed by a Host System.'00' Removable Card Slot'01' Embedded Slot for One Device'10' Shared Bus Slot'11' Reserved'''
  [[register.field]]
    name = "CORECFG_ASYNCHINTRSUPPORT"
    bits = "29"
    type = "ro"
    shortdesc = '''Asynchronous Interrupt is supported; refer to SDIO Specification Version 3.'''
    longdesc = '''00.'''
  [[register.field]]
    name = "CORECFG_64BITSUPPORT"
    bits = "28"
    type = "ro"
  [[register.field]]
    name = "CORECFG_1P8VOLTSUPPORT"
    bits = "26"
    type = "ro"
    shortdesc = '''Host controller supports 1.'''
    longdesc = '''8V I/O.'''
  [[register.field]]
    name = "CORECFG_3P0VOLTSUPPORT"
    bits = "25"
    type = "ro"
    shortdesc = '''Host controller supports 3.'''
    longdesc = '''0V I/O.'''
  [[register.field]]
    name = "CORECFG_3P3VOLTSUPPORT"
    bits = "24"
    type = "ro"
    shortdesc = '''Host controller supports 3.'''
    longdesc = '''3V I/O.'''
  [[register.field]]
    name = "CORECFG_SUSPRESSUPPORT"
    bits = "23"
    type = "ro"
  [[register.field]]
    name = "CORECFG_SDMASUPPORT"
    bits = "22"
    type = "ro"
  [[register.field]]
    name = "CORECFG_HIGHSPEEDSUPPORT"
    bits = "21"
    type = "ro"
    shortdesc = '''This bit indicates whether the HC and the Host System support High Speed mode and they can supply SD Clock frequency from 25Mhz to 50 Mhz (for SD)/ 20MHz to 52MHz (for MMC).'''
    longdesc = ''''0' High Speed Not Supported'1' High Speed Supported'''
  [[register.field]]
    name = "CORECFG_ADMA2SUPPORT"
    bits = "19"
    type = "ro"
  [[register.field]]
    name = "CORECFG_8BITSUPPORT"
    bits = "18"
    type = "ro"
    shortdesc = '''This bit indicates whether the Host Controller is capable of using 8-bit bus width mode.'''
    longdesc = '''This bit is not effective when Slot Type is set to 10b. In this case, refer to Bus Width Preset in the Shared Bus resister.'0' Extended Media Bus Not Supported'1' Extended Media Bus Supported'''
  [[register.field]]
    name = "CORECFG_MAXBLKLENGTH"
    bits = "17:16"
    type = "ro"
    shortdesc = '''This value indicates the maximum block size that the HD can read and write to the buffer in the HC.'''
    longdesc = '''The buffer shall transfer this block size without wait cycles. Three sizes can be defined as indicated below.'00' 512byte'01' 1024byte'10' 2048byte'11' 4096byte'''
  [[register.field]]
    name = "CORECFG_BASECLKFREQ"
    bits = "15:8"
    type = "ro"
    shortdesc = '''(1)6-bit Base Clock Frequency: This mode is supported by the Host Controller Version 1.'''
    longdesc = '''00 and 2.00. Upper 2-bit is not effective and always 0. Unit values are 1MHz. The supported clock range is 10MHz to 63MHz. 11xx xxxxb' Not Supported'0011 1111b' 63MHz'0000 0010b' 2MHz'0000 0001b' 1MHz'0000 0000b'Get Information via another method (2)8-bit Base Clock Frequency: This mode is supported by the Host Controller Version 3.00.Unit values are 1MHz. The supported clock range is 10MHz to 255MHz.'FFh' 255MHz'02h' 2MHz'01h' 1MHz'00h' Get Information via another method. If the real frequency is 16.5MHz, the lager value shall be set 0001 0001b (17MHz) because the Host Driver use this value to calculate the clock divider value (Refer to the SDCLK Frequency Select in the Clock Control register.) and it shall not exceed upper limit of the SD Clock frequency. If these bits are all 0, the Host System has to get information via another method.'''
  [[register.field]]
    name = "CORECFG_TIMEOUTCLKUNIT"
    bits = "7"
    type = "ro"
  [[register.field]]
    name = "CORECFG_TIMEOUTCLKFREQ"
    bits = "5:0"
    type = "ro"
[[register]]
  name = "REG_MAXCURRENTCAP"
  type = "ro"
  width = 64
  description = "Maximum current capability for each voltage."
  default = "0x00000000"
  offset = "0x00000048"
  [[register.field]]
    name = "CORECFG_MAXCURRENT1P8V"
    bits = "23:16"
    type = "ro"
    shortdesc = '''Refer to the iou_slcr.'''
    longdesc = '''SD_MAXCUR1P8 register.'''
  [[register.field]]
    name = "CORECFG_MAXCURRENT3P0V"
    bits = "15:8"
    type = "ro"
    shortdesc = '''Refer to the iou_slcr.'''
    longdesc = '''SD_MAXCUR3P0 register.'''
  [[register.field]]
    name = "CORECFG_MAXCURRENT3P3V"
    bits = "7:0"
    type = "ro"
    shortdesc = '''Refer to the iou_slcr.'''
    longdesc = '''SD_MAXCUR3P3 register.'''
[[register]]
  name = "REG_FORCEEVENTFORAUTOCMDERRORSTATUS"
  type = "wo"
  width = 16
  description = "Generate Auto CMD Error Status Interrupts, write-only."
  default = "0x00000000"
  offset = "0x00000050"
  [[register.field]]
    name = "FORCECMDNOTISSUEDBYAUTOCMD12ERR"
    bits = "7"
    type = "wo"
  [[register.field]]
    name = "FORCEAUTOCMDINDEXERR"
    bits = "4"
    type = "wo"
  [[register.field]]
    name = "FORCEAUTOCMDENDBITERR"
    bits = "3"
    type = "wo"
  [[register.field]]
    name = "FORCEAUTOCMDCRCERR"
    bits = "2"
    type = "wo"
  [[register.field]]
    name = "FORCEAUTOCMDTIMEOUTERR"
    bits = "1"
    type = "wo"
  [[register.field]]
    name = "FORCEAUTOCMDNOTEXEC"
    bits = "0"
    type = "wo"
[[register]]
  name = "REG_FORCEEVENTFORERRINTSTS"
  type = "mixed"
  width = 16
  description = "Generate Error Interrupt Status Interrupts."
  default = "0x00000000"
  offset = "0x00000052"
  [[register.field]]
    name = "FORCETUNINGERR"
    bits = "10"
    type = "ro"
  [[register.field]]
    name = "FORCEADMAERR"
    bits = "9"
    type = "wo"
  [[register.field]]
    name = "FORCEAUTOCMDERR"
    bits = "8"
    type = "wo"
  [[register.field]]
    name = "FORCECURRLIMERR"
    bits = "7"
    type = "wo"
  [[register.field]]
    name = "FORCEDATENDBITERR"
    bits = "6"
    type = "wo"
  [[register.field]]
    name = "FORCEDATCRCERR"
    bits = "5"
    type = "wo"
  [[register.field]]
    name = "FORCEDATTIMEOUTERR"
    bits = "4"
    type = "wo"
  [[register.field]]
    name = "FORCECMDINDEXERR"
    bits = "3"
    type = "wo"
  [[register.field]]
    name = "FORCECMDENDBITERR"
    bits = "2"
    type = "wo"
  [[register.field]]
    name = "FORCECMDCRCERR"
    bits = "1"
    type = "wo"
  [[register.field]]
    name = "FORCECMDTIMEOUTERR"
    bits = "0"
    type = "wo"
[[register]]
  name = "REG_ADMAERRSTS"
  type = "ro"
  width = 8
  description = "SDIO ADMA Error State and Address."
  default = "0x00000000"
  offset = "0x00000054"
  [[register.field]]
    name = "ADMAERRSTS_ADMALENMISMATCHERR"
    bits = "2"
    type = "ro"
    shortdesc = '''ADMA errors detected; occurs in the following 2 cases.'''
    longdesc = '''1) While the Block Count Enable being set, the total data length specified by the Descriptor table is different from that specified by the Block Count and Block Length. 2) Total data length can not be divided evenly by the block length. 1: Error 0: No Error'''
  [[register.field]]
    name = "ADMAERRSTS_ADMAERRORSTATE"
    bits = "1:0"
    type = "ro"
    shortdesc = '''State of ADMA when an error occurred during an ADMA data transfer.'''
    longdesc = '''D01 - D00: ADMA Error State when error occurred Contents of SYS_SDR register. 00: ST_STOP (Stop DMA) Points to next of the error descriptor. 01: ST_FDS (Fetch Descriptor)Points to the error descriptor. 10: reserved (ADMA never stops in this state). 11: ST_TFR (Transfer Data) Points to the next error descriptor.'''
[[register]]
  name = "REG_ADMASYSADDR0"
  type = "rw"
  width = 16
  description = "Lower physical address for ADMA data transfer."
  default = "0x00000000"
  offset = "0x00000058"
  [[register.field]]
    name = "ADMA_SYSADDRESS0"
    bits = "15:0"
    type = "rw"
[[register]]
  name = "REG_ADMASYSADDR1"
  type = "rw"
  width = 16
  description = "ADMA Physical Address, 16 LSBs."
  default = "0x00000000"
  offset = "0x0000005A"
  [[register.field]]
    name = "ADMA_SYSADDRESS1"
    bits = "15:0"
    type = "rw"
[[register]]
  name = "REG_ADMASYSADDR2"
  type = "rw"
  width = 16
  description = "ADMA Physical Address, 16 bits."
  default = "0x00000000"
  offset = "0x0000005C"
  [[register.field]]
    name = "ADMA_SYSADDRESS2"
    bits = "15:0"
    type = "rw"
[[register]]
  name = "REG_ADMASYSADDR3"
  type = "rw"
  width = 16
  description = "ADMA Physical Address, 16 MSBs."
  default = "0x00000000"
  offset = "0x0000005E"
  [[register.field]]
    name = "ADMA_SYSADDRESS3"
    bits = "15:0"
    type = "rw"
[[register]]
  name = "REG_PRESETVALUE0"
  type = "ro"
  width = 16
  description = "This register is used to read the SDCLK Frequency Select Value,Clock Generator Select Value,Driver Strength Select Value"
  default = "0x00000100"
  offset = "0x00000060"
  [[register.field]]
    name = "DRIVERSTRENGTHSELECTVALUE"
    bits = "15:14"
    type = "ro"
    shortdesc = '''Driver Strength is supported by 1.'''
    longdesc = '''8V signaling bus speed modes. This field is meaningless for 3.3V signaling.'00' Driver Type B is Selected'01' Driver Type A is Selected'10' Driver Type C is Selected'11' Driver Type D is Selected'''
  [[register.field]]
    name = "CLOCKGENERATORSELECTVALUE"
    bits = "10"
    type = "ro"
    shortdesc = '''This bit is effective when Host Controller supports programmable clock'0' Host Controller Ver2.'''
    longdesc = '''00 Compatible Clock Generator'1' Programmable Clock Generator'''
  [[register.field]]
    name = "SDCLKFREQUENCYSELECTVALUE"
    bits = "9:0"
    type = "ro"
[[register]]
  name = "REG_PRESETVALUE1"
  type = "ro"
  width = 16
  description = "Default Clock and I/O Drive Preset Values. Read clock select values and I/O drive."
  default = "0x00000004"
  offset = "0x00000062"
  [[register.field]]
    name = "DRIVERSTRENGTHSELECTVALUE"
    bits = "15:14"
    type = "ro"
    shortdesc = '''Driver Strength is supported by 1.'''
    longdesc = '''8V signaling bus speed modes. 00: Driver Type B is selected. (default) 01: Driver Type A is selected. 10: Driver Type C is selected. 11: Driver Type D is selected. This field is meaningless for 3.3V signaling.'''
  [[register.field]]
    name = "CLOCKGENERATORSELECTVALUE"
    bits = "10"
    type = "ro"
    shortdesc = '''Select clock generator mode.'''
    longdesc = '''0: Host Controller Ver2.00 Clock Model. 1: Programmable Clock Generator.'''
  [[register.field]]
    name = "SDCLKFREQUENCYSELECTVALUE"
    bits = "9:0"
    type = "ro"
[[register]]
  name = "REG_PRESETVALUE2"
  type = "ro"
  width = 16
  description = "High-Speed Clock and I/O Drive Preset Values. Read clock select values and I/O drive."
  default = "0x00000002"
  offset = "0x00000064"
  [[register.field]]
    name = "DRIVERSTRENGTHSELECTVALUE"
    bits = "15:14"
    type = "ro"
    shortdesc = '''Driver Strength is supported by 1.'''
    longdesc = '''8V signaling bus speed modes. This field is meaningless for 3.3V signaling.'00' Driver Type B is Selected'01' Driver Type A is Selected'10' Driver Type C is Selected'11' Driver Type D is Selected'''
  [[register.field]]
    name = "CLOCKGENERATORSELECTVALUE"
    bits = "10"
    type = "ro"
    shortdesc = '''This bit is effective when Host Controller supports programmable clock'0' Host Controller Ver2.'''
    longdesc = '''00 Compatible Clock Generator'1' Programmable Clock Generator'''
  [[register.field]]
    name = "SDCLKFREQUENCYSELECTVALUE"
    bits = "9:0"
    type = "ro"
[[register]]
  name = "REG_PRESETVALUE3"
  type = "ro"
  width = 16
  description = "SDR12 Clock and I/O Drive Preset Values."
  default = "0x00000004"
  offset = "0x00000066"
  [[register.field]]
    name = "DRIVERSTRENGTHSELECTVALUE"
    bits = "15:14"
    type = "ro"
    shortdesc = '''Driver Strength is supported by 1.'''
    longdesc = '''8V signaling bus speed modes. This field is meaningless for 3.3V signaling.'00' Driver Type B is Selected'01' Driver Type A is Selected'10' Driver Type C is Selected'11' Driver Type D is Selected'''
  [[register.field]]
    name = "CLOCKGENERATORSELECTVALUE"
    bits = "10"
    type = "ro"
    shortdesc = '''This bit is effective when Host Controller supports programmable clock'0' Host Controller Ver2.'''
    longdesc = '''00 Compatible Clock Generator'1' Programmable Clock Generator'''
  [[register.field]]
    name = "SDCLKFREQUENCYSELECTVALUE"
    bits = "9:0"
    type = "ro"
[[register]]
  name = "REG_PRESETVALUE4"
  type = "ro"
  width = 16
  description = "SDR25 Clock and I/O Drive Preset Values."
  default = "0x00000002"
  offset = "0x00000068"
  [[register.field]]
    name = "DRIVERSTRENGTHSELECTVALUE"
    bits = "15:14"
    type = "ro"
    shortdesc = '''Driver Strength is supported by 1.'''
    longdesc = '''8V signaling bus speed modes. This field is meaningless for 3.3V signaling.'00' Driver Type B is Selected'01' Driver Type A is Selected'10' Driver Type C is Selected'11' Driver Type D is Selected'''
  [[register.field]]
    name = "CLOCKGENERATORSELECTVALUE"
    bits = "10"
    type = "ro"
    shortdesc = '''This bit is effective when Host Controller supports programmable clock'0' Host Controller Ver2.'''
    longdesc = '''00 Compatible Clock Generator'1' Programmable Clock Generator'''
  [[register.field]]
    name = "SDCLKFREQUENCYSELECTVALUE"
    bits = "9:0"
    type = "ro"
[[register]]
  name = "REG_PRESETVALUE5"
  type = "ro"
  width = 16
  description = "SDR50 Clock and I/O Drive Preset Values."
  default = "0x00000001"
  offset = "0x0000006A"
  [[register.field]]
    name = "DRIVERSTRENGTHSELECTVALUE"
    bits = "15:14"
    type = "ro"
    shortdesc = '''Driver Strength is supported by 1.'''
    longdesc = '''8V signaling bus speed modes. This field is meaningless for 3.3V signaling.'00' Driver Type B is Selected'01' Driver Type A is Selected'10' Driver Type C is Selected'11' Driver Type D is Selected'''
  [[register.field]]
    name = "CLOCKGENERATORSELECTVALUE"
    bits = "10"
    type = "ro"
    shortdesc = '''This bit is effective when Host Controller supports programmable clock'0' Host Controller Ver2.'''
    longdesc = '''00 Compatible Clock Generator'1' Programmable Clock Generator'''
  [[register.field]]
    name = "SDCLKFREQUENCYSELECTVALUE"
    bits = "9:0"
    type = "ro"
[[register]]
  name = "REG_PRESETVALUE6"
  type = "ro"
  width = 16
  description = "SDR 104 Mode Clock and I/O Drive Preset Values."
  default = "0x00000000"
  offset = "0x0000006C"
  [[register.field]]
    name = "DRIVERSTRENGTHSELECTVALUE"
    bits = "15:14"
    type = "ro"
    shortdesc = '''Driver Strength is supported by 1.'''
    longdesc = '''8V signaling bus speed modes. This field is meaningless for 3.3V signaling.'00' Driver Type B is Selected'01' Driver Type A is Selected'10' Driver Type C is Selected'11' Driver Type D is Selected'''
  [[register.field]]
    name = "CLOCKGENERATORSELECTVALUE"
    bits = "10"
    type = "ro"
    shortdesc = '''This bit is effective when Host Controller supports programmable clock'0' Host Controller Ver2.'''
    longdesc = '''00 Compatible Clock Generator'1' Programmable Clock Generator'''
  [[register.field]]
    name = "SDCLKFREQUENCYSELECTVALUE"
    bits = "9:0"
    type = "ro"
[[register]]
  name = "REG_PRESETVALUE7"
  type = "ro"
  width = 16
  description = "DDR50 Clock and I/O Drive Preset Values."
  default = "0x00000002"
  offset = "0x0000006E"
  [[register.field]]
    name = "DRIVERSTRENGTHSELECTVALUE"
    bits = "15:14"
    type = "ro"
    shortdesc = '''Driver Strength is supported by 1.'''
    longdesc = '''8V signaling bus speed modes. This field is meaningless for 3.3V signaling.'00' Driver Type B is Selected'01' Driver Type A is Selected'10' Driver Type C is Selected'11' Driver Type D is Selected'''
  [[register.field]]
    name = "CLOCKGENERATORSELECTVALUE"
    bits = "10"
    type = "ro"
    shortdesc = '''This bit is effective when Host Controller supports programmable clock'0' Host Controller Ver2.'''
    longdesc = '''00 Compatible Clock Generator'1' Programmable Clock Generator'''
  [[register.field]]
    name = "SDCLKFREQUENCYSELECTVALUE"
    bits = "9:0"
    type = "ro"
[[register]]
  name = "REG_BOOTTIMEOUTCNT"
  type = "rw"
  width = 32
  description = "Program the boot timeout value counter."
  default = "0x00000000"
  offset = "0x00000070"
  [[register.field]]
    name = "BOOT_TIMEOUTCNT"
    bits = "31:0"
    type = "rw"
    shortdesc = '''Timeout interval for DAT lines during eMMC boot.'''
    longdesc = '''The value is in number of SD_CLK clocks.'''
[[register]]
  name = "REG_SLOTINTRSTS"
  type = "ro"
  width = 16
  description = "Read the interrupt signal for each slot."
  default = "0x00000000"
  offset = "0x000000FC"
  [[register.field]]
    name = "SDHCHOSTIF_SLOTINTRSTS"
    bits = "7:0"
    type = "ro"
    shortdesc = '''These status bits indicate the logical OR of Interrupt signal and Wakeup signal for each slot.'''
    longdesc = '''A maximum of 8 slots can be defined.'''
[[register]]
  name = "REG_HOSTCONTROLLERVER"
  type = "ro"
  width = 16
  description = "Controller version and specification numbers."
  default = "0x00001002"
  offset = "0x000000FE"
  [[register.field]]
    name = "SDHC_VENVERNUM"
    bits = "15:8"
    type = "ro"
    shortdesc = '''The Vendor Version Number is set to 0x10 (1.'''
    longdesc = '''0).'''
  [[register.field]]
    name = "SPECIFICATIONVERSIONNUMBER"
    bits = "7:0"
    type = "ro"
    shortdesc = '''The SDIO controller supports SD Host Specification Version 3.'''
    longdesc = '''00.'''
