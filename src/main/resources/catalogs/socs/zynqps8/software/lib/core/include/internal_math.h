#pragma once
// MIT Licensed (for full license see LICENSE file)

// Math has no designs on being the fastest, most comprehensive or even most
// correct maths library.
// Its one purpose is to be portable, tested and available everywhere.
// Its for the 'normal' everyday math usage that probably won't need
// perfect alignment, SIMD or exact precision ulp guarentees. There are plenty
// of tasks that don't need that. So this is small, portable
// and perfect for API interfaces and little bits of portable maths.
//

// Functions supported for unsigned scalar types (float used as exampler)
// ---------
// Math_MinF(float const v, float const a) = v < a ? v : a
// Math_MaxF(float const v, float const a) = v > a ? v : a
// Math_ClampF(float const v, float const a, float const b) = min(max(v, a), b)
// Math_EqualF(float const a, float const b) = a == b
// Math_RoundUpToF(float const a, float const multiple) = a rounded up to a multiple
//
// Functions supported for signed scale types (float used as exampler), all unsigned plus
// ---------
// Math_AbsF(float const a) = a < 0 ? -a : a
//
// Functions supported for real scalar types (float used as exampler), as signed plus
// ---------
// Math_LerpF(float const a, float const b, float t) = a + (b - a) * t
// Math_ApproxEqualF(float const a, float const b, float epsilon) = abs(b - a) < epsilon
// Math_IsNanF(float const in) = isnan(in)
// Math_SaturateF(float const in) = min(max(v, 0), 1)
// Math_PiF() = pi
// Math_PiOver2F() = pi / 2
// Math_TwoPiF() = pi * 2
// Math_DegreesToRadiansF(float const input) = radian version of input angle in degrees
// Math_RadiansToDegreesF(type const input) = degree version of input angle in radians
// Math_ReciprocalF(float const a) = 1 / a
// Math_SignF(float const a) = -1 if a < 0 or 1 if a > 0 or 0 if a == 0
// Math_SqrtF(float const a) sqrt(a)
// Math_ReciprocalSqrtF(float const a) 1 / sqrt(a)

// Functions supported for unsigned integer types (uint32_t used as exampler)
// Math_IsPowerOf2U32(uint32_t const x) = true if x is power of 2, x == 0 return true
// Math_NextPowerOfTwoU32(uint32_t const x) = next power of 2 greater than x, x == 0 returns 1
// Math_ClosestPowerOfTwoU32(uint32_t const x) = closest power of 2 greater or less than x, x == 0, returns 0
// Math_Log2U32(uint32_t const x) = highest bit set in x

/// Additional some functions are not supported across the entire range of types
/// these are for specific (or a few types) so are not autogenerated by the macro
/// system used to build the generic CMath types
// TODO Math_Float2Half(float f) = float in, uint16_t encoded half out
// TODO Math_Half2Float(uint16_t h) = uint16_t encoded half in, float out
/// TODO sqrt functions use system double sqrt for all types needs replacing
/// Some functions can be defined for integer only types, at the moment real
/// use same base functions as integer meaning those can't be easily shared


#define MATH_FM_CREATE_UNSIGNED(postfix, type) 																				\
INLINE type Math_Min##postfix(type const v, type const a) { return (v < a) ? v : a; } \
INLINE type Math_Max##postfix(type const v, type const a) { return (v > a) ? v : a; } \
INLINE type Math_Clamp##postfix(type const v, type const a, type const b) { return Math_Min##postfix(Math_Max##postfix(v, a), b); } \
INLINE bool Math_Equal##postfix(type const a, type const b) { return a == b; } 				\
INLINE type Math_RoundUpTo##postfix(type const v, type const m) { return ((v + m - 1) / m) * m; }

#define MATH_FM_CREATE_SIGNED(postfix, type) \
MATH_FM_CREATE_UNSIGNED(postfix, type) \
INLINE type Math_Abs##postfix(type const a) { return (a < 0) ? -a : a; }

#define MATH_FM_CREATE_REAL(postfix, type) 																						\
MATH_FM_CREATE_SIGNED(postfix, type) 																									\
INLINE bool Math_ApproxEqual##postfix(type const a, type const b, type const epsilon) { return (Math_Abs##postfix(b - a) <= epsilon); } \
INLINE bool Math_IsNan##postfix(type const a) { return a != a; } 											\
INLINE type Math_Saturate##postfix(type const x) { return Math_Clamp##postfix(x, (type)0, (type)1); } \
INLINE type Math_Pi##postfix() { return (type) (3.14159265358979323846264338327950L); } \
INLINE type Math_PiOver2##postfix() { return Math_Pi##postfix() / 2; } 								\
INLINE type Math_TwoPi##postfix() { return 2 * Math_Pi##postfix(); } 									\
INLINE type Math_DegreesToRadians##postfix(type const val) { return val * (Math_Pi##postfix() / 180); } \
INLINE type Math_RadiansToDegrees##postfix(type const val) { return (180 * val) / Math_Pi##postfix(); } \
INLINE type Math_Reciprocal##postfix(type const a) { return 1 / a; } 									\
INLINE int Math_Sign##postfix(type val) { return (0 < val) - (val < 0); } 						\
INLINE type Math_Sqrt##postfix(type const a) { return (type)sqrt((double)a); } 				\
INLINE type Math_ReciprocalSqrt##postfix(type const a) { return 1 / (type)sqrt((double)a); }

#if MATH_FM_USE_BUILTIN == 1

// use gcc builtin

#define MATH_FM_CREATE_UNSIGNED_INTEGER_MAYBE_BUILTIN(postfix, type) 	\
ALWAYS_INLINE type Math_NextPowerOfTwo##postfix(type x) {     	\
	if(sizeof(type) >= 8)                                  						 	\
		return x == 1 ? 1 : 1<<((sizeof(type)*8) - __builtin_clzl(x-1));  \
	else                																								\
		return x == 1 ? 1 : 1<<((sizeof(type)*8) - __builtin_clz(x-1));   \
} 																																		\
ALWAYS_INLINE uint8_t Math_Log2##postfix(type const v) { 			\
	if(sizeof(type) >= 8)                                  						 	\
		return (sizeof(type)*8) - __builtin_clzl(x);     									\
	else                																								\
		return (sizeof(type)*8) - __builtin_clz(x);      									\
} 																																		\

#else

// Use generic not builtin functions

#define MATH_FM_CREATE_UNSIGNED_INTEGER_MAYBE_BUILTIN(postfix, type) 	\
INLINE type Math_NextPowerOfTwo##postfix(type x) { 										\
	if(x == 0) return 1; 																								\
	x = x - 1; 																													\
	if(sizeof(type) >= 8) { x |= ((uint64_t)x) >> 32; } 								\
	if(sizeof(type) >= 4) { x |= ((uint32_t)x) >> 16; } 								\
	if(sizeof(type) >= 2) { x |= ((uint16_t)x) >> 8; } 									\
	x |= x >> 4; 																												\
	x |= x >> 2; 																												\
	x |= x >> 1; 																												\
	return x + 1; 																											\
} 																																		\
INLINE uint8_t Math_Log2##postfix(type const v) { 										\
	uint8_t r = 0; 																											\
	type t = v; 																												\
	if(sizeof(type) >= 8) { 																						\
		uint32_t tt = ((uint64_t)t) >> 32; 																\
		r = r + (tt ? 32 : 0); 																						\
		t = tt ? tt : (t & 0xFFFFFFFF); 																	\
	} 																																	\
	if(sizeof(type) >= 4) { 																						\
		uint16_t tt = ((uint32_t)t) >> 16; 																\
		r = r + (tt ? 16 : 0); 																						\
		t = tt ? tt : (t & 0xFFFF); 																			\
	} 																																	\
	if(sizeof(type) >= 2) { 																						\
		uint8_t tt = ((uint16_t)t) >> 8; 																	\
		r = r + (tt ? 8 : 0); 																						\
		t = tt ? tt : (t & 0xFF); 																				\
	} 																																	\
	uint8_t tt = ((uint8_t)t) >> 4; 																		\
	r = r + (tt ? 4 : 0); 																							\
	t = tt ? tt : (t & 0xF); 																						\
	static uint8_t const logTable[16] = {0, 0, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3}; \
	return r + logTable[(uint8_t)t]; 																		\
}

#endif

#define MATH_FM_CREATE_UNSIGNED_INTEGER(postfix, type)							 	\
MATH_FM_CREATE_UNSIGNED(postfix, type)                 								\
MATH_FM_CREATE_UNSIGNED_INTEGER_MAYBE_BUILTIN(postfix, type) 					\
INLINE bool Math_IsPowerOf2##postfix(type const x) { return (x & (x - 1)) == 0; } \
INLINE type Math_ClosestPowerOfTwo##postfix(type const x) { 					\
	type upow2 = Math_NextPowerOfTwo##postfix(x); 											\
	if (4 * x < 3 * upow2) return upow2 >> 1; 													\
	else return upow2; 																									\
} 																																		\

#define MATH_FM_CREATE_SIGNED_INTEGER(postfix, type) \
MATH_FM_CREATE_SIGNED(postfix, type)


