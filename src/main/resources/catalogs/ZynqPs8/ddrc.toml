description = "DDR Memory Controller"
[[bank]]
  name = "DDRC"
  address = "0xfd070000"
[[register]]
  name = "MSTR"
  type = "rw"
  width = 32
  description = "Master Register"
  default = "0x03040001"
  offset = "0x00000000"
  [[register.field]]
    name = "DEVICE_CONFIG"
    bits = "31:30"
    type = "rw"
    shortdesc = '''Indicates the configuration of the device used in the system.'''
    longdesc = '''- 00 - Reserved - 01 - x8 device - 10 - x16 device - 11 - x32 device'''
  [[register.field]]
    name = "FREQUENCY_MODE"
    bits = "29"
    type = "rw"
    shortdesc = '''Choose which registers are used.'''
    longdesc = '''- 0 - Original registers - 1 - Shadow registers'''
  [[register.field]]
    name = "ACTIVE_RANKS"
    bits = "25:24"
    type = "rw"
    shortdesc = '''Each bit represents one rank.'''
    longdesc = '''- 1 - populated - 0 - unpopulated LSB is the lowest rank number. For 2 ranks following combinations are legal: - 01 - One rank - 11 - Two ranks - Others - Reserved.'''
  [[register.field]]
    name = "BURST_RDWR"
    bits = "19:16"
    type = "rw"
    shortdesc = '''SDRAM burst length used: - 0001 - Reserved - 0010 - Burst length of 4 - 0100 - Burst length of 8 - 1000 - Burst length of 16 (only supported for LPDDR4) All other values are reserved.'''
    longdesc = '''This controls the burst size used to access the SDRAM. This must match the burst length mode register setting in the SDRAM. (For BC4/8 on-the-fly mode of DDR3 and DDR4, set this field to 0x0100).'''
  [[register.field]]
    name = "DLL_OFF_MODE"
    bits = "15"
    type = "rw"
    shortdesc = '''Set to 1 when the DDRC and DRAM has to be put in DLL-off mode for low frequency operation.'''
    longdesc = '''Set to 0 to put DDRC and DRAM in DLL-on mode for normal frequency operation. If DDR4 CRC/parity retry is enabled (CRCPARCTL1.crc_parity_retry_enable = 1), dll_off_mode is not supported, and this bit must be set to '0'. Programming Mode: Quasi-dynamic Group 2'''
  [[register.field]]
    name = "DATA_BUS_WIDTH"
    bits = "13:12"
    type = "rw"
    shortdesc = '''Selects proportion of DQ bus width that is used by the SDRAM - 00 - Full DQ bus width to SDRAM - 01 - Half DQ bus width to SDRAM - 10 - Reserved - 11 - Reserved.'''
    longdesc = '''Note that half bus width mode is only supported when the SDRAM bus width is a multiple of 16. Bus width refers to DQ bus width (excluding any ECC width).'''
  [[register.field]]
    name = "EN_2T_TIMING_MODE"
    bits = "10"
    type = "rw"
    shortdesc = '''If 1, then DDRC uses 2T timing.'''
    longdesc = '''Otherwise, uses 1T timing. In 2T timing, all command signals (except chip select) are held for 2 clocks on the SDRAM bus. Chip select is asserted on the second cycle of the command Note: 2T timing is not supported in LPDDR3/LPDDR4 mode.'''
  [[register.field]]
    name = "LPDDR4"
    bits = "5"
    type = "rw"
    shortdesc = '''Select LPDDR4 SDRAM - 1 - LPDDR4 SDRAM device in use.'''
    longdesc = '''- 0 - non-LPDDR4 device in use'''
  [[register.field]]
    name = "DDR4"
    bits = "4"
    type = "rw"
    shortdesc = '''Select DDR4 SDRAM - 1 - DDR4 SDRAM device in use.'''
    longdesc = '''- 0 - non-DDR4 device in use'''
  [[register.field]]
    name = "LPDDR3"
    bits = "3"
    type = "rw"
    shortdesc = '''Select LPDDR3 SDRAM - 1 - LPDDR3 SDRAM device in use.'''
    longdesc = '''- 0 - non-LPDDR3 device in use'''
  [[register.field]]
    name = "DDR3"
    bits = "0"
    type = "rw"
[[register]]
  name = "STAT"
  type = "ro"
  width = 32
  description = "Operating Mode Status Register"
  default = "0x00000000"
  offset = "0x00000004"
  [[register.field]]
    name = "SELFREF_STATE"
    bits = "9:8"
    type = "ro"
    shortdesc = '''Self refresh state.'''
    longdesc = '''This indicates self refresh or self refresh power down state for LPDDR4. This register is used for frequency change and MRR/MRW access during self refresh. - 00 - SDRAM is not in Self Refresh. - 01 - Self refresh 1 - 10 - Self refresh power down - 11 - Self refresh 2'''
  [[register.field]]
    name = "SELFREF_TYPE"
    bits = "5:4"
    type = "ro"
    shortdesc = '''Flags if Self Refresh is entered and if it was under Automatic Self Refresh control only or not.'''
    longdesc = '''- 00 - SDRAM is not in Self Refresh. If retry is enabled by CRCPARCTRL1.crc_parity_retry_enable, this also indicates SRE command is still in parity error window or retry is in-progress. - 11 - SDRAM is in Self Refresh and Self Refresh was caused by Automatic Self Refresh only. If retry is enabled, this guarantees SRE command is executed correctly without parity error. - 10 - SDRAM is in Self Refresh and Self Refresh was not caused solely under Automatic Self Refresh control. It could have been caused by Hardware Low Power Interface and/or Software (reg_ddrc_selfref_sw). If retry is enabled, this guarantees SRE command is executed correctly without parity error.'''
  [[register.field]]
    name = "OPERATING_MODE"
    bits = "2:0"
    type = "ro"
    shortdesc = '''Operating mode.'''
    longdesc = '''DDR3 designs: - 000 - Init - 001 - Normal - 010 - Power-down - 011 - Self refresh LPDDR3 or DDR4 designs: - 000 - Init - 001 - Normal - 010 - Power-down - 011 - Self refresh - 1XX - Deep power-down / Maximum Power Saving Mode LPDDR4 designs: - 000 - Init - 001 - Normal - 010 - Power-down - 011 - Self refresh / Self refresh power-down'''
[[register]]
  name = "MRCTRL0"
  type = "rw"
  width = 32
  description = "Mode Register Read/Write Control Register 0. Note: Do not enable more than one of the following fields simultaneously: - sw_init_int - pda_en - mpr_en"
  default = "0x00000030"
  offset = "0x00000010"
  [[register.field]]
    name = "MR_WR"
    bits = "31"
    type = "rw"
    shortdesc = '''Setting this register bit to 1 triggers a mode register read or write operation.'''
    longdesc = '''When the MR operation is complete, the DDRC automatically clears this bit. The other register fields of this register must be written in a separate APB transaction, before setting this mr_wr bit. It is recommended NOT to set this signal if in Init, Deep power-down or MPSM operating modes.'''
  [[register.field]]
    name = "MR_ADDR"
    bits = "15:12"
    type = "rw"
    shortdesc = '''Address of the mode register that is to be written to.'''
    longdesc = '''- 0000 - MR0 - 0001 - MR1 - 0010 - MR2 - 0011 - MR3 - 0100 - MR4 - 0101 - MR5 - 0110 - MR6 - 0111 - MR7 Don't Care for LPDDR3/LPDDR4 (see MRCTRL1.mr_data for mode register addressing in LPDDR3/LPDDR4) This signal is also used for writing to control words of RDIMMs. In that case, it corresponds to the bank address bits sent to the RDIMM In case of DDR4, the bit[3:2] corresponds to the bank group bits. Therefore, the bit[3] as well as the bit[2:0] must be set to an appropriate value which is considered both the Address Mirroring of UDIMMs/RDIMMs and the Output Inversion of RDIMMs.'''
  [[register.field]]
    name = "MR_RANK"
    bits = "5:4"
    type = "rw"
    shortdesc = '''Controls which rank is accessed by MRCTRL0.'''
    longdesc = '''mr_wr. Normally, it is desired to access all ranks, so all bits should be set to 1. However, for multi-rank UDIMMs/RDIMMs which implement address mirroring, it may be necessary to access ranks individually. Examples (assume DDRC is configured for 4 ranks): - 0x1 - select rank 0 only - 0x2 - select rank 1 only - 0x5 - select ranks 0 and 2 - 0xA - select ranks 1 and 3 - 0xF - select ranks 0, 1, 2 and 3'''
  [[register.field]]
    name = "SW_INIT_INT"
    bits = "3"
    type = "rw"
    shortdesc = '''Indicates whether Software intervention is allowed via MRCTRL0/MRCTRL1 before automatic SDRAM initialization routine or not.'''
    longdesc = '''For DDR4, this bit can be used to initialize the DDR4 RCD (MR7) before automatic SDRAM initialization. For LPDDR4, this bit can be used to program additional mode registers before automatic SDRAM initialization if necessary. Note: This must be cleared to 0 after completing Software operation. Otherwise, SDRAM initialization routine will not re-start. - 0 - Software intervention is not allowed - 1 - Software intervention is allowed'''
  [[register.field]]
    name = "PDA_EN"
    bits = "2"
    type = "rw"
  [[register.field]]
    name = "MPR_EN"
    bits = "1"
    type = "rw"
  [[register.field]]
    name = "MR_TYPE"
    bits = "0"
    type = "rw"
    shortdesc = '''Indicates whether the mode register operation is read or write.'''
    longdesc = '''Only used for LPDDR3/LPDDR4/DDR4. - 0 - Write - 1 - Read'''
[[register]]
  name = "MRCTRL1"
  type = "rw"
  width = 32
  description = "Mode Register Read/Write Control Register 1"
  default = "0x00000000"
  offset = "0x00000014"
  [[register.field]]
    name = "MR_DATA"
    bits = "17:0"
    type = "rw"
    shortdesc = '''Mode register write data for all non-LPDDR3/non-LPDDR4 modes.'''
    longdesc = '''For LPDDR3/LPDDR4, MRCTRL1[15:0] are interpreted as [15:8] MR Address [7:0] MR data for writes, don't care for reads.'''
[[register]]
  name = "MRSTAT"
  type = "ro"
  width = 32
  description = "Mode Register Read/Write Status Register"
  default = "0x00000000"
  offset = "0x00000018"
  [[register.field]]
    name = "PDA_DONE"
    bits = "8"
    type = "ro"
    shortdesc = '''The SoC core may initiate an MR write operation in PDA mode only if this signal is low.'''
    longdesc = '''This signal goes high when three consecutive MRS commands related to the PDA mode are issued to the SDRAM. This signal goes low when MRCTRL0.pda_en becomes 0. Therefore, it is recommended to write MRCTRL0.pda_en to 0 after this signal goes high in order to prepare to perform PDA operation next time. - 0 - Indicates that mode register write operation related to PDA is in progress or has not started yet. - 1 - Indicates that mode register write operation related to PDA has competed.'''
  [[register.field]]
    name = "MR_WR_BUSY"
    bits = "0"
    type = "ro"
    shortdesc = '''The SoC core may initiate an MR write operation only if this signal is low.'''
    longdesc = '''This signal goes high in the clock after the DDRC accepts the MRW/MRR request. It goes low when the MRW/MRR command is issued to the SDRAM. It is recommended not to perform MRW/MRR commands when 'MRSTAT.mr_wr_busy' is high. - 0 - Indicates that the SoC core can initiate a mode register write operation - 1 - Indicates that mode register write operation is in progress'''
[[register]]
  name = "MRCTRL2"
  type = "rw"
  width = 32
  description = "Mode Register Read/Write Control Register 2"
  default = "0x00000000"
  offset = "0x0000001C"
  [[register.field]]
    name = "MR_DEVICE_SEL"
    bits = "31:0"
    type = "rw"
    shortdesc = '''Indicates the device(s) to be selected during the MRS that happens in PDA mode.'''
    longdesc = '''Each bit is associated with one device. For example, bit[0] corresponds to Device 0, bit[1] to Device 1 etc. A '1' should be programmed to indicate that the MRS command should be applied to that device. A '0' indicates that the MRS commands should be skipped for that device.'''
[[register]]
  name = "DERATEEN"
  type = "rw"
  width = 32
  description = "Temperature Derate Enable Register"
  default = "0x00000000"
  offset = "0x00000020"
  [[register.field]]
    name = "RC_DERATE_VALUE"
    bits = "9:8"
    type = "rw"
    shortdesc = '''Derate value of tRC for LPDDR4 - 0 - Derating uses +1.'''
    longdesc = '''- 1 - Derating uses +2. - 2 - Derating uses +3. - 3 - Derating uses +4. The required number of cycles for derating can be determined by dividing 3.75ns by the core_ddrc_core_clk period, and rounding up the next integer.'''
  [[register.field]]
    name = "DERATE_BYTE"
    bits = "7:4"
    type = "rw"
    shortdesc = '''Derate byte Indicates which byte of the MRR data is used for derating.'''
    longdesc = '''The maximum valid value depends on MEMC_DRAM_TOTAL_DATA_WIDTH.'''
  [[register.field]]
    name = "DERATE_VALUE"
    bits = "1"
    type = "rw"
    shortdesc = '''Derate value - 0 - Derating uses +1.'''
    longdesc = '''- 1 - Derating uses +2. Can be 0 or 1 for LPDDR3/LPDDR4, depending if +1.875 ns is less than a core_ddrc_core_clk period or not.'''
  [[register.field]]
    name = "DERATE_ENABLE"
    bits = "0"
    type = "rw"
    shortdesc = '''Enables derating - 0 - Timing parameter derating is disabled - 1 - Timing parameter derating is enabled using MR4 read value.'''
    longdesc = '''This field must be set to '0' for non-LPDDR3/LPDDR4 mode. Programming Mode: Dynamic'''
[[register]]
  name = "DERATEINT"
  type = "rw"
  width = 32
  description = "Temperature Derate Interval Register"
  default = "0x00800000"
  offset = "0x00000024"
  [[register.field]]
    name = "MR4_READ_INTERVAL"
    bits = "31:0"
    type = "rw"
    shortdesc = '''LPDDR3/LPDDR4: Interval between two MR4 reads, used to derate the timing parameters.'''
    longdesc = '''This register must not be set to zero'''
[[register]]
  name = "PWRCTL"
  type = "rw"
  width = 32
  description = "Low Power Control Register"
  default = "0x00000000"
  offset = "0x00000030"
  [[register.field]]
    name = "STAY_IN_SELFREF"
    bits = "6"
    type = "rw"
    shortdesc = '''Self refresh state is an intermediate state to enter to Self refresh power down state or exit Self refresh power down state for LPDDR4.'''
    longdesc = '''This register controls transition from the Self refresh state. - 1 - Prohibit transition from Self refresh state - 0 - Allow transition from Self refresh state'''
  [[register.field]]
    name = "SELFREF_SW"
    bits = "5"
    type = "rw"
    shortdesc = '''A value of 1 to this register causes system to move to Self Refresh state immediately, as long as it is not in INIT or DPD/MPSM operating_mode.'''
    longdesc = '''This is referred to as Software Entry/Exit to Self Refresh. - 1 - Software Entry to Self Refresh - 0 - Software Exit from Self Refresh'''
  [[register.field]]
    name = "MPSM_EN"
    bits = "4"
    type = "rw"
    shortdesc = '''When this is 1, the DDRC puts the SDRAM into maximum power saving mode when the transaction store is empty.'''
    longdesc = '''This register must be reset to '0' to bring DDRC out of maximum power saving mode. For non-DDR4, this register should not be set to 1. FOR PERFORMANCE ONLY.'''
  [[register.field]]
    name = "EN_DFI_DRAM_CLK_DISABLE"
    bits = "3"
    type = "rw"
    shortdesc = '''Enable the assertion of dfi_dram_clk_disable whenever a clock is not required by the SDRAM.'''
    longdesc = '''If set to 0, dfi_dram_clk_disable is never asserted. Assertion of dfi_dram_clk_disable is as follows: In DDR3, can only be asserted in Self Refresh. In DDR4, can be asserted in following: - in Self Refresh. - in Maximum Power Saving Mode In LPDDR3, can be asserted in following: - in Self Refresh - in Power Down - in Deep Power Down - during Normal operation (Clock Stop) In LPDDR4, can be asserted in following: - in Self Refresh Power Down - in Power Down - during Normal operation (Clock Stop)'''
  [[register.field]]
    name = "DEEPPOWERDOWN_EN"
    bits = "2"
    type = "rw"
    shortdesc = '''When this is 1, DDRC puts the SDRAM into deep power-down mode when the transaction store is empty.'''
    longdesc = '''This register must be reset to '0' to bring DDRC out of deep power-down mode. Controller performs automatic SDRAM initialization on deep power-down exit. For non-LPDDR3, this register should not be set to 1. FOR PERFORMANCE ONLY.'''
  [[register.field]]
    name = "POWERDOWN_EN"
    bits = "1"
    type = "rw"
    shortdesc = '''If true then the DDRC goes into power-down after a programmable number of cycles 'maximum idle clocks before power down' (PWRTMG.'''
    longdesc = '''powerdown_to_x32). This register bit may be re-programmed during the course of normal operation.'''
  [[register.field]]
    name = "SELFREF_EN"
    bits = "0"
    type = "rw"
    shortdesc = '''If true then the DDRC puts the SDRAM into Self Refresh after a programmable number of cycles 'maximum idle clocks before Self Refresh (PWRTMG.'''
    longdesc = '''selfref_to_x32)'. This register bit may be re-programmed during the course of normal operation.'''
[[register]]
  name = "PWRTMG"
  type = "rw"
  width = 32
  description = "Low Power Timing Register"
  default = "0x00402010"
  offset = "0x00000034"
  [[register.field]]
    name = "SELFREF_TO_X32"
    bits = "23:16"
    type = "rw"
    shortdesc = '''After this many clocks of NOP or deselect the DDRC automatically puts the SDRAM into Self Refresh.'''
    longdesc = '''This must be enabled in the PWRCTL.selfref_en. Unit: Multiples of 32 clocks. FOR PERFORMANCE ONLY.'''
  [[register.field]]
    name = "T_DPD_X4096"
    bits = "15:8"
    type = "rw"
    shortdesc = '''Minimum deep power-down time.'''
    longdesc = '''For LPDDR3, value from the JEDEC specification is 500us. Unit: Multiples of 4096 clocks. FOR PERFORMANCE ONLY.'''
  [[register.field]]
    name = "POWERDOWN_TO_X32"
    bits = "4:0"
    type = "rw"
    shortdesc = '''After this many clocks of NOP or deselect the DDRC automatically puts the SDRAM into power-down.'''
    longdesc = '''This must be enabled in the PWRCTL.powerdown_en. Unit: Multiples of 32 clocks FOR PERFORMANCE ONLY.'''
[[register]]
  name = "HWLPCTL"
  type = "rw"
  width = 32
  description = "Hardware Low Power Control Register"
  default = "0x00000003"
  offset = "0x00000038"
  [[register.field]]
    name = "HW_LP_IDLE_X32"
    bits = "27:16"
    type = "rw"
    shortdesc = '''Hardware idle period.'''
    longdesc = '''The cactive_ddrc output is driven low if the system is idle for hw_lp_idle * 32 cycles if not in INIT or DPD/MPSM operating_mode. The hardware idle function is disabled when hw_lp_idle_x32=0. Unit: Multiples of 32 clocks. FOR PERFORMANCE ONLY.'''
  [[register.field]]
    name = "HW_LP_EXIT_IDLE_EN"
    bits = "1"
    type = "rw"
    shortdesc = '''When this bit is programmed to 1 the cactive_in_ddrc pin of the DDRC can be used to exit from the automatic clock stop, automatic power down or automatic self-refresh modes.'''
    longdesc = '''Note, it will not cause exit of Self-Refresh that was caused by Hardware Low Power Interface and/or Software (PWRCTL.selfref_sw).'''
  [[register.field]]
    name = "HW_LP_EN"
    bits = "0"
    type = "rw"
    shortdesc = '''Enable for Hardware Low Power Interface.'''
    longdesc = '''Programming Mode: Quasi-dynamic Group 3'''
[[register]]
  name = "RFSHCTL0"
  type = "rw"
  width = 32
  description = "Refresh Control Register 0"
  default = "0x00210000"
  offset = "0x00000050"
  [[register.field]]
    name = "REFRESH_MARGIN"
    bits = "23:20"
    type = "rw"
    shortdesc = '''Threshold value in number of clock cycles before the critical refresh or page timer expires.'''
    longdesc = '''A critical refresh is to be issued before this threshold is reached. It is recommended that this not be changed from the default value, currently shown as 0x2. It must always be less than internally used t_rfc_nom_x32. Note that, in LPDDR3/LPDDR4, internally used t_rfc_nom_x32 may be equal to RFSHTMG.t_rfc_nom_x32>>2 if derating is enabled (DERATEEN.derate_enable=1). Otherwise, internally used t_rfc_nom_x32 will be equal to RFSHTMG.t_rfc_nom_x32. Unit: Multiples of 32 clocks.'''
  [[register.field]]
    name = "REFRESH_TO_X32"
    bits = "16:12"
    type = "rw"
    shortdesc = '''If the refresh timer (tRFCnom, also known as tREFI) has expired at least once, but it has not expired (RFSHCTL0.'''
    longdesc = '''refresh_burst+1) times yet, then a speculative refresh may be performed. A speculative refresh is a refresh performed at a time when refresh would be useful, but before it is absolutely required. When the SDRAM bus is idle for a period of time determined by this RFSHCTL0.refresh_to_x32 and the refresh timer has expired at least once since the last refresh, then a speculative refresh is performed. Speculative refreshes continues successively until there are no refreshes pending or until new reads or writes are issued to the DDRC. FOR PERFORMANCE ONLY.'''
  [[register.field]]
    name = "REFRESH_BURST"
    bits = "8:4"
    type = "rw"
    shortdesc = '''The programmed value + 1 is the number of refresh timeouts that is allowed to accumulate before traffic is blocked and the refreshes are forced to execute.'''
    longdesc = '''Closing pages to perform a refresh is a one-time penalty that must be paid for each group of refreshes. Therefore, performing refreshes in a burst reduces the per-refresh penalty of these page closings. Higher numbers for RFSHCTL.refresh_burst slightly increases utilization; lower numbers decreases the worst-case latency associated with refreshes. - 0 - single refresh - 1 - burst-of-2 refresh - 7 - burst-of-8 refresh For DDR3, the refresh is always per-rank and not per-bank. The rank refresh can be accumulated over 8*tREFI cycles using the burst refresh feature. In DDR4 mode, according to Fine Granularity feature, 8 refreshes can be postponed in 1X mode, 16 refreshes in 2X mode and 32 refreshes in 4X mode. If using PHY-initiated updates, care must be taken in the setting of RFSHCTL0.refresh_burst, to ensure that tRFCmax is not violated due to a PHY-initiated update occurring shortly before a refresh burst was due. In this situation, the refresh burst will be delayed until the PHY-initiated update is complete.'''
  [[register.field]]
    name = "PER_BANK_REFRESH"
    bits = "2"
    type = "rw"
    shortdesc = '''- 1 - Per bank refresh; - 0 - All bank refresh.'''
    longdesc = '''Per bank refresh allows traffic to flow to other banks. Per bank refresh is supported by all LPDDR3/LPDDR4 devices. Programming Mode: Static'''
[[register]]
  name = "RFSHCTL1"
  type = "rw"
  width = 32
  description = "Refresh Control Register 1"
  default = "0x00000000"
  offset = "0x00000054"
  [[register.field]]
    name = "REFRESH_TIMER1_START_VALUE_X32"
    bits = "27:16"
    type = "rw"
    shortdesc = '''Refresh timer start for rank 1.'''
    longdesc = '''This is useful in staggering the refreshes to multiple ranks to help traffic to proceed. This is explained in Refresh Controls section of architecture chapter. Unit: Multiples of 32 clocks. FOR PERFORMANCE ONLY.'''
  [[register.field]]
    name = "REFRESH_TIMER0_START_VALUE_X32"
    bits = "11:0"
    type = "rw"
    shortdesc = '''Refresh timer start for rank 0.'''
    longdesc = '''This is useful in staggering the refreshes to multiple ranks to help traffic to proceed. This is explained in Refresh Controls section of architecture chapter. Unit: Multiples of 32 clocks. FOR PERFORMANCE ONLY.'''
[[register]]
  name = "RFSHCTL3"
  type = "rw"
  width = 32
  description = "Refresh Control Register 3"
  default = "0x00000000"
  offset = "0x00000060"
  [[register.field]]
    name = "REFRESH_MODE"
    bits = "6:4"
    type = "rw"
    shortdesc = '''Fine Granularity Refresh Mode - 000 - Fixed 1x (Normal mode) - 001 - Fixed 2x - 010 - Fixed 4x - 101 - Enable on the fly 2x (not supported) - 110 - Enable on the fly 4x (not supported) - Everything else - reserved Note: The on-the-fly modes is not supported in this version of the DDRC.'''
    longdesc = '''Note: This must be set up while the Controller is in reset or while the Controller is in self-refresh mode. Changing this during normal operation is not allowed. Programming Mode: Quasi-dynamic Group 2'''
  [[register.field]]
    name = "REFRESH_UPDATE_LEVEL"
    bits = "1"
    type = "rw"
    shortdesc = '''Toggle this signal (either from 0 to 1 or from 1 to 0) to indicate that the refresh register(s) have been updated.'''
    longdesc = '''The value is automatically updated when exiting reset, so it does not need to be toggled initially.'''
  [[register.field]]
    name = "DIS_AUTO_REFRESH"
    bits = "0"
    type = "rw"
    shortdesc = '''When '1', disable auto-refresh generated by the DDRC.'''
    longdesc = '''When auto-refresh is disabled, the SoC core must generate refreshes using the registers reg_ddrc_rank0_refresh, reg_ddrc_rank1_refresh, reg_ddrc_rank2_refresh and reg_ddrc_rank3_refresh. When dis_auto_refresh transitions from 0 to 1, any pending refreshes are immediately scheduled by the DDRC. If DDR4 CRC/parity retry is enabled (CRCPARCTL1.crc_parity_retry_enable = 1), disable auto-refresh is not supported, and this bit must be set to '0'. This register field is changeable on the fly.'''
[[register]]
  name = "RFSHTMG"
  type = "rw"
  width = 32
  description = "Refresh Timing Register"
  default = "0x0062008C"
  offset = "0x00000064"
  [[register.field]]
    name = "T_RFC_NOM_X32"
    bits = "27:16"
    type = "rw"
    shortdesc = '''tREFI: Average time interval between refreshes per rank (Specification: 7.'''
    longdesc = '''8us for DDR3 and DDR4. See JEDEC specification for LPDDR3 and LPDDR4). For LPDDR3/LPDDR4: - if using all-bank refreshes (RFSHCTL0.per_bank_refresh = 0), this register should be set to tREFIab - if using per-bank refreshes (RFSHCTL0.per_bank_refresh = 1), this register should be set to tREFIpb Program this to (tREFI/2), no rounding up. In DDR4 mode, tREFI value is different depending on the refresh mode. The user should program the appropriate value from the spec based on the value programmed in the refresh mode register. Note that RFSHTMG.t_rfc_nom_x32 * 32 must be greater than RFSHTMG.t_rfc_min, and RFSHTMG.t_rfc_nom_x32 must be greater than 0x1. Unit: Multiples of 32 clocks.'''
  [[register.field]]
    name = "LPDDR3_TREFBW_EN"
    bits = "15"
    type = "rw"
    shortdesc = '''Used only when LPDDR3 memory type is connected.'''
    longdesc = '''Should only be changed when DDRC is in reset. Specifies whether to use the tREFBW parameter (required by some LPDDR3 devices which comply with earlier versions of the LPDDR3 JEDEC specification) or not: - 0 - tREFBW parameter not used - 1 - tREFBW parameter used Programming Mode: Static'''
  [[register.field]]
    name = "T_RFC_MIN"
    bits = "9:0"
    type = "rw"
    shortdesc = '''tRFC (min): Minimum time from refresh to refresh or activate.'''
    longdesc = '''t_rfc_min should be set to RoundUp(RoundUp(tRFCmin/tCK)/2). In LPDDR3/LPDDR4 mode: - if using all-bank refreshes, the tRFCmin value in the above equations is equal to tRFCab - if using per-bank refreshes, the tRFCmin value in the above equations is equal to tRFCpb In DDR4 mode, the tRFCmin value in the above equations is different depending on the refresh mode (fixed 1X,2X,4X) and the device density. The user should program the appropriate value from the spec based on the 'refresh_mode' and the device density that is used. Unit: Clocks.'''
[[register]]
  name = "ECCCFG0"
  type = "rw"
  width = 32
  description = "ECC Configuration Register 0"
  default = "0x00000000"
  offset = "0x00000070"
  [[register.field]]
    name = "DIS_SCRUB"
    bits = "4"
    type = "rw"
    shortdesc = '''Disable ECC scrubs.'''
    longdesc = '''Valid only when ECCCFG0.ecc_mode = 3'b100'''
  [[register.field]]
    name = "ECC_MODE"
    bits = "2:0"
    type = "rw"
[[register]]
  name = "ECCCFG1"
  type = "rw"
  width = 32
  description = "ECC Configuration Register 1"
  default = "0x00000000"
  offset = "0x00000074"
  [[register.field]]
    name = "DATA_POISON_BIT"
    bits = "1"
    type = "rw"
    shortdesc = '''Selects whether to poison 1 or 2 bits - if 0 -> 2-bit (uncorrectable) data poisoning, if 1 -> 1-bit (correctable) data poisoning, if ECCCFG1.'''
    longdesc = '''data_poison_en=1'''
  [[register.field]]
    name = "DATA_POISON_EN"
    bits = "0"
    type = "rw"
[[register]]
  name = "ECCSTAT"
  type = "ro"
  width = 32
  description = "ECC Status Register"
  default = "0x00000000"
  offset = "0x00000078"
  [[register.field]]
    name = "ECC_UNCORRECTED_ERR"
    bits = "19:16"
    type = "ro"
  [[register.field]]
    name = "ECC_CORRECTED_ERR"
    bits = "11:8"
    type = "ro"
    shortdesc = '''Single-bit error indicators, 1 per data beat.'''
    longdesc = '''ECCCADDR1 [ecc_corr_col] = 0: 0001: beat 0 0010: beat 1 0100: beat 2 1000: beat 3 ECCCADDR1 [ecc_corr_col] = 4: 0001: beat 4 0010: beat 5 0100: beat 6 1000: beat 7'''
  [[register.field]]
    name = "ECC_CORRECTED_BIT_NUM"
    bits = "6:0"
    type = "ro"
    shortdesc = '''Bit number (within the data beat) corrected by single-bit ECC error.'''
    longdesc = '''If more than one data lane has an error, the lower data lane is selected. This register is 7 bits wide in order to handle 72 bits of the data present in a single lane.'''
[[register]]
  name = "ECCCLR"
  type = "wtc"
  width = 32
  description = "ECC Clear Register"
  default = "0x00000000"
  offset = "0x0000007C"
  [[register.field]]
    name = "ECC_CLR_UNCORR_ERR_CNT"
    bits = "3"
    type = "wtc"
    shortdesc = '''Setting this register bit to 1 clears the currently stored uncorrected ECC error count.'''
    longdesc = '''The ECCSTAT.ecc_uncorr_err_cnt register is cleared by this operation. When the clear operation is complete, the DDRC automatically clears this bit.'''
  [[register.field]]
    name = "ECC_CLR_CORR_ERR_CNT"
    bits = "2"
    type = "wtc"
    shortdesc = '''Setting this register bit to 1 clears the currently stored corrected ECC error count.'''
    longdesc = '''The ECCERRCNT.ecc_corr_err_cnt register is cleared by this operation. When the clear operation is complete, the DDRC automatically clears this bit.'''
  [[register.field]]
    name = "ECC_CLR_UNCORR_ERR"
    bits = "1"
    type = "wtc"
    shortdesc = '''Setting this register bit to 1 clears the currently stored uncorrected ECC error.'''
    longdesc = '''The ECCSTAT.ecc_uncorrected_err, ECCUADDR0, ECCUADDR1, ECCUSYN0, ECCUSYN1 and ECCUSYN2 registers are cleared by this operation. When the clear operation is complete, the DDRC automatically clears this bit.'''
  [[register.field]]
    name = "ECC_CLR_CORR_ERR"
    bits = "0"
    type = "wtc"
    shortdesc = '''Setting this register bit to 1 clears the currently stored corrected ECC error.'''
    longdesc = '''The ECCSTAT.ecc_corrected_err, ECCSTAT.ecc_corrected_bit_num, ECCCADDR0, ECCCADDR1, ECCCSYN0, ECCCSYN1, ECCCSYN2, ECCBITMASK0, ECCBITMASK1 and ECCBITMASK2 registers are cleared by this operation. When the clear operation is complete, the DDRC automatically clears this bit.'''
[[register]]
  name = "ECCERRCNT"
  type = "ro"
  width = 32
  description = "ECC Error Counter Register"
  default = "0x00000000"
  offset = "0x00000080"
  [[register.field]]
    name = "ECC_UNCORR_ERR_CNT"
    bits = "31:16"
    type = "ro"
  [[register.field]]
    name = "ECC_CORR_ERR_CNT"
    bits = "15:0"
    type = "ro"
[[register]]
  name = "ECCCADDR0"
  type = "ro"
  width = 32
  description = "ECC Corrected Error Address Register 0"
  default = "0x00000000"
  offset = "0x00000084"
  [[register.field]]
    name = "ECC_CORR_RANK"
    bits = "24"
    type = "ro"
  [[register.field]]
    name = "ECC_CORR_ROW"
    bits = "17:0"
    type = "ro"
[[register]]
  name = "ECCCADDR1"
  type = "ro"
  width = 32
  description = "ECC Corrected Error Address Register 1"
  default = "0x00000000"
  offset = "0x00000088"
  [[register.field]]
    name = "ECC_CORR_BG"
    bits = "25:24"
    type = "ro"
  [[register.field]]
    name = "ECC_CORR_BANK"
    bits = "18:16"
    type = "ro"
  [[register.field]]
    name = "ECC_CORR_COL"
    bits = "11:0"
    type = "ro"
    shortdesc = '''Block number of a read resulting in a corrected ECC error (lowest bit not assigned here) 0: data beats 0 to 3.'''
    longdesc = '''4: data beats 4 to 7.'''
[[register]]
  name = "ECCCSYN0"
  type = "ro"
  width = 32
  description = "ECC Corrected Syndrome Register 0"
  default = "0x00000000"
  offset = "0x0000008C"
  [[register.field]]
    name = "ECC_CORR_SYNDROMES_31_0"
    bits = "31:0"
    type = "ro"
    shortdesc = '''Data pattern that resulted in a corrected error.'''
    longdesc = '''For 16-bit ECC, only bits [15:0] are used'''
[[register]]
  name = "ECCCSYN1"
  type = "ro"
  width = 32
  description = "ECC Corrected Syndrome Register 1"
  default = "0x00000000"
  offset = "0x00000090"
  [[register.field]]
    name = "ECC_CORR_SYNDROMES_63_32"
    bits = "31:0"
    type = "ro"
    shortdesc = '''Data pattern that resulted in a corrected error.'''
    longdesc = '''For 32-bit ECC and 16-bit ECC, this register is not used'''
[[register]]
  name = "ECCCSYN2"
  type = "ro"
  width = 32
  description = "ECC Corrected Syndrome Register 2"
  default = "0x00000000"
  offset = "0x00000094"
  [[register.field]]
    name = "ECC_CORR_SYNDROMES_71_64"
    bits = "7:0"
    type = "ro"
[[register]]
  name = "ECCBITMASK0"
  type = "ro"
  width = 32
  description = "ECC Corrected Data Bit Mask Register 0"
  default = "0x00000000"
  offset = "0x00000098"
  [[register.field]]
    name = "ECC_CORR_BIT_MASK_31_0"
    bits = "31:0"
    type = "ro"
    shortdesc = '''Mask for the corrected data portion - 1 on any bit indicates that the bit has been corrected by the ECC logic - 0 on any bit indicates that the bit has not been corrected by the ECC logic This register accumulates data over multiple ECC errors, to give an overall indication of which bits are being fixed.'''
    longdesc = '''It is cleared by writing a 1 to ECCCLR.ecc_clr_corr_err. For 16-bit ECC, only bits [15:0] are used'''
[[register]]
  name = "ECCBITMASK1"
  type = "ro"
  width = 32
  description = "ECC Corrected Data Bit Mask Register 1"
  default = "0x00000000"
  offset = "0x0000009C"
  [[register.field]]
    name = "ECC_CORR_BIT_MASK_63_32"
    bits = "31:0"
    type = "ro"
    shortdesc = '''Mask for the corrected data portion - 1 on any bit indicates that the bit has been corrected by the ECC logic - 0 on any bit indicates that the bit has not been corrected by the ECC logic This register accumulates data over multiple ECC errors, to give an overall indication of which bits are being fixed.'''
    longdesc = '''It is cleared by writing a 1 to ECCCLR.ecc_clr_corr_err. For 32-bit ECC and 16-bit ECC, this register is not used'''
[[register]]
  name = "ECCBITMASK2"
  type = "ro"
  width = 32
  description = "ECC Corrected Data Bit Mask Register 2"
  default = "0x00000000"
  offset = "0x000000A0"
  [[register.field]]
    name = "ECC_CORR_BIT_MASK_71_64"
    bits = "7:0"
    type = "ro"
    shortdesc = '''Mask for the corrected data portion - 1 on any bit indicates that the bit has been corrected by the ECC logic - 0 on any bit indicates that the bit has not been corrected by the ECC logic This register accumulates data over multiple ECC errors, to give an overall indication of which bits are being fixed.'''
    longdesc = '''It is cleared by writing a 1 to ECCCLR.ecc_clr_corr_err. This register refers to the ECC byte, which is bits [71:64] for 64-bit ECC, [39:32] for 32-bit ECC, or [23:16] for 16-bit ECC'''
[[register]]
  name = "ECCUADDR0"
  type = "ro"
  width = 32
  description = "ECC Uncorrected Error Address Register 0"
  default = "0x00000000"
  offset = "0x000000A4"
  [[register.field]]
    name = "ECC_UNCORR_RANK"
    bits = "24"
    type = "ro"
  [[register.field]]
    name = "ECC_UNCORR_ROW"
    bits = "17:0"
    type = "ro"
[[register]]
  name = "ECCUADDR1"
  type = "ro"
  width = 32
  description = "ECC Uncorrected Error Address Register 1"
  default = "0x00000000"
  offset = "0x000000A8"
  [[register.field]]
    name = "ECC_UNCORR_BG"
    bits = "25:24"
    type = "ro"
  [[register.field]]
    name = "ECC_UNCORR_BANK"
    bits = "18:16"
    type = "ro"
  [[register.field]]
    name = "ECC_UNCORR_COL"
    bits = "11:0"
    type = "ro"
[[register]]
  name = "ECCUSYN0"
  type = "ro"
  width = 32
  description = "ECC Uncorrected Syndrome Register 0"
  default = "0x00000000"
  offset = "0x000000AC"
  [[register.field]]
    name = "ECC_UNCORR_SYNDROMES_31_0"
    bits = "31:0"
    type = "ro"
    shortdesc = '''Data pattern that resulted in an uncorrected error, one for each ECC lane, all concatenated together.'''
    longdesc = '''For 16-bit ECC, only bits [15:0] are used'''
[[register]]
  name = "ECCUSYN1"
  type = "ro"
  width = 32
  description = "ECC Uncorrected Syndrome Register 1"
  default = "0x00000000"
  offset = "0x000000B0"
  [[register.field]]
    name = "ECC_UNCORR_SYNDROMES_63_32"
    bits = "31:0"
    type = "ro"
    shortdesc = '''Data pattern that resulted in an uncorrected error, one for each ECC lane, all concatenated together.'''
    longdesc = '''For 32-bit ECC and 16-bit ECC, this register is not used'''
[[register]]
  name = "ECCUSYN2"
  type = "ro"
  width = 32
  description = "ECC Uncorrected Syndrome Register 2"
  default = "0x00000000"
  offset = "0x000000B4"
  [[register.field]]
    name = "ECC_UNCORR_SYNDROMES_71_64"
    bits = "7:0"
    type = "ro"
    shortdesc = '''Data pattern that resulted in an uncorrected error one for each ECC lane, all concatenated together.'''
    longdesc = '''This register refers to the ECC byte, which is bits [71:64] for 64-bit ECC, [39:32] for 32-bit ECC, or [23:16] for 16-bit ECC'''
[[register]]
  name = "ECCPOISONADDR0"
  type = "rw"
  width = 32
  description = "ECC Data Poisoning Address Register 0. If a write transaction matches the address specified in this register, an ECC error will be introduced on that transaction, if ECCCFG1.data_poison_en=1"
  default = "0x00000000"
  offset = "0x000000B8"
  [[register.field]]
    name = "ECC_POISON_RANK"
    bits = "24"
    type = "rw"
  [[register.field]]
    name = "ECC_POISON_COL"
    bits = "11:0"
    type = "rw"
    shortdesc = '''Column address for ECC poisoning.'''
    longdesc = '''Note that this column address must be burst aligned: - In full bus width mode, ecc_poison_col[2:0] must be set to 0 - In half bus width mode, ecc_poison_col[3:0] must be set to 0'''
[[register]]
  name = "ECCPOISONADDR1"
  type = "rw"
  width = 32
  description = "ECC Data Poisoning Address Register 1. If a write transaction matches the address specified in this register, an ECC error will be introduced on that transaction, if ECCCFG1.data_poison_en=1"
  default = "0x00000000"
  offset = "0x000000BC"
  [[register.field]]
    name = "ECC_POISON_BG"
    bits = "29:28"
    type = "rw"
  [[register.field]]
    name = "ECC_POISON_BANK"
    bits = "26:24"
    type = "rw"
  [[register.field]]
    name = "ECC_POISON_ROW"
    bits = "17:0"
    type = "rw"
[[register]]
  name = "CRCPARCTL0"
  type = "mixed"
  width = 32
  description = "CRC Parity Control Register0"
  default = "0x00008000"
  offset = "0x000000C0"
  [[register.field]]
    name = "RETRY_CTRLUPD_ENABLE"
    bits = "15"
    type = "rw"
    shortdesc = '''dfi_ctrlupd_req enable for retry.'''
    longdesc = '''- 1: Enable to issue dfi_ctrlupd_req before starting retry sequence - 0: Disable to issue dfi_ctrlupd_req before starting retry sequence The DFI controller update can be used to reset PHY FIFO pointers. If both CRCPARCTL0.retry_cfrlupd_enable and CRCPARCTL1.alert_wait_for_sw are enabled, dfi_ctrlupd_req is issued just before software intervention time. If CRCPARCTL0.retry_cfrlupd_enable is enabled, dfi_ctrlupd_req will be issued regardless of DFIUPD0.dis_auto_ctrlupd. Programming Mode: Static'''
  [[register.field]]
    name = "DFI_ALERT_ERR_MAX_REACHED_INT_CLR"
    bits = "8"
    type = "wtc"
    shortdesc = '''Interrupt clear bit for DFI alert counter saturation.'''
    longdesc = '''If this bit is set, the alert error interrupt on CRCPARSTAT.dfi_alert_err_max_reached_int is cleared. When the clear operation is complete, the DDRC automatically clears this bit.'''
  [[register.field]]
    name = "DFI_ALERT_ERR_FATL_INT_CLR"
    bits = "4"
    type = "wtc"
    shortdesc = '''Interrupt clear bit for dfi_alert_err_fatl_int.'''
    longdesc = '''If this bit is set, the alert error interrupt on CRCPARSTAT.dfi_alert_err_fatl_int is cleared. When the clear operation is complete, the DDRC automatically clears this bit.'''
  [[register.field]]
    name = "DFI_ALERT_ERR_CNT_CLR"
    bits = "2"
    type = "wtc"
    shortdesc = '''DFI alert error count clear.'''
    longdesc = '''Clear bit for DFI alert error counter. Asserting this bit will clear the DFI alert error counter, CRCPARSTAT.dfi_alert_err_cnt. When the clear operation is complete, the DDRC automatically clears this bit.'''
  [[register.field]]
    name = "DFI_ALERT_ERR_INT_CLR"
    bits = "1"
    type = "wtc"
    shortdesc = '''Interrupt clear bit for DFI alert error.'''
    longdesc = '''If this bit is set, the alert error interrupt on CRCPARSTAT.dfi_alert_err_int will be cleared. When the clear operation is complete, the DDRC automatically clears this bit.'''
  [[register.field]]
    name = "DFI_ALERT_ERR_INT_EN"
    bits = "0"
    type = "rw"
    shortdesc = '''Interrupt enable bit for DFI alert error.'''
    longdesc = '''If this bit is set, any parity/CRC error detected on the dfi_alert_n input will result in an interrupt being set on CRCPARSTAT.dfi_alert_err_int.'''
[[register]]
  name = "CRCPARCTL1"
  type = "rw"
  width = 32
  description = "CRC Parity Control Register1"
  default = "0x10000200"
  offset = "0x000000C4"
  [[register.field]]
    name = "DFI_T_PHY_RDLAT"
    bits = "29:24"
    type = "rw"
    shortdesc = '''The maximum number of DFI PHY clock cycles allowed from the assertion of the dfi_rddata_en signal to the assertion of each of the corresponding bits of the dfi_rddata_valid signal.'''
    longdesc = '''This corresponds to the DFI timing parameter tphy_rdlat. This value is only used for detecting read data timeout when DDR4 retry is enabled by CRCPARCTL1.crc_parity_retry_enable=1. Maximum supported value: - 1:2 Frequency mode && DFITMG0.dfi_rddata_use_sdr == 1 : CRCPARCTL1.dfi_t_phy_rdlat < 64 Unit: DFI Clocks'''
  [[register.field]]
    name = "ALERT_WAIT_FOR_SW"
    bits = "9"
    type = "rw"
    shortdesc = '''After a Parity or CRC error is flagged on dfi_alert_n signal, the software has an option to read the mode registers in the DRAM before the hardware begins the retry process - 1: Wait for software to read/write the mode registers before hardware begins the retry.'''
    longdesc = '''After software is done with its operations, it will clear the alert interrupt register bit - 0: Hardware can begin the retry right away after the dfi_alert_n pulse goes away. The value on this register is valid only when retry is enabled (PARCTRL.crc_parity_retry_enable = 1) If this register is set to 1 and if the software doesn't clear the interrupt register after handling the parity/CRC error, then the hardware will not begin the retry process and the system will hang. In the case of Parity/CRC error, there are two possibilities when the software doesn't reset MR5[4] to 0. - (i) If 'Persistent parity' mode register bit is NOT set: the commands sent during retry and normal operation are executed without parity checking. The value in the Parity error log register MPR Page 1 is valid. - (ii) If 'Persistent parity' mode register bit is SET: Parity checking is done for commands sent during retry and normal operation. If multiple errors occur before MR5[4] is cleared, the error log in MPR Page 1 should be treated as 'Don't care'.'''
  [[register.field]]
    name = "CRC_PARITY_RETRY_ENABLE"
    bits = "8"
    type = "rw"
    shortdesc = '''- 1: Enable command retry mechanism in case of C/A Parity or CRC error - 0: Disable command retry mechanism when C/A Parity or CRC features are enabled.'''
    longdesc = '''Note that retry functionality is not supported if burst chop is enabled (MSTR.burstchop = 1) and/or disable auto-refresh is enabled (RFSHCTL3.dis_auto_refresh = 1)'''
  [[register.field]]
    name = "CRC_INC_DM"
    bits = "7"
    type = "rw"
  [[register.field]]
    name = "CRC_ENABLE"
    bits = "4"
    type = "rw"
  [[register.field]]
    name = "PARITY_ENABLE"
    bits = "0"
    type = "rw"
[[register]]
  name = "CRCPARCTL2"
  type = "rw"
  width = 32
  description = "CRC Parity Control Register2"
  default = "0x0030050C"
  offset = "0x000000C8"
  [[register.field]]
    name = "T_PAR_ALERT_PW_MAX"
    bits = "24:16"
    type = "rw"
    shortdesc = '''Value from the DRAM spec indicating the maximum width of the dfi_alert_n pulse when a parity error occurs.'''
    longdesc = '''Recommended values: - tPAR_ALERT_PW.MAX Program this to tPAR_ALERT_PW.MAX/2 and round up to next integer value. Values of 0, 1, and 2 are illegal. This value must be greater than CRCPARCTL2.t_crc_alert_pw_max.'''
  [[register.field]]
    name = "T_CRC_ALERT_PW_MAX"
    bits = "12:8"
    type = "rw"
    shortdesc = '''Value from the DRAM spec indicating the maximum width of the dfi_alert_n pulse when a CRC error occurs.'''
    longdesc = '''Recommended values: - tCRC_ALERT_PW.MAX Program this to tCRC_ALERT_PW.MAX/2 and round up to next integer value. Values of 0, 1, and 2 are illegal. This value must be less than CRCPARCTL2.t_par_alert_pw_max.'''
  [[register.field]]
    name = "RETRY_FIFO_MAX_HOLD_TIMER_X4"
    bits = "5:0"
    type = "rw"
    shortdesc = '''Indicates the maximum duration in number of DRAM clock cycles for which a command should be held in the Command Retry FIFO before it is popped out.'''
    longdesc = '''Every location in the Command Retry FIFO has an associated down counting timer that will use this register as the start value. The down counting starts when a command is loaded into the FIFO. The timer counts down every 4 DRAM cycles. When the counter reaches zero, the entry is popped from the FIFO. All the counters are frozen, if a C/A Parity or CRC error occurs before the counter reaches zero. The counter is reset to 0, after all the commands in the FIFO are retried. Recommended(minimum) values: - Only C/A Parity is enabled. RoundUp((PHY Command Latency(DRAM CLK) + CAL + RDIMM delay + tPAR_ALERT_ON.max + tPAR_UNKNOWN + PHY Alert Latency(DRAM CLK) + board delay) / 4) + 2 - Both C/A Parity and CRC is enabled/ Only CRC is enabled. RoundUp((PHY Command Latency(DRAM CLK) + CAL + RDIMM delay + WL + 5(BL10)+ tCRC_ALERT.max + PHY Alert Latency(DRAM CLK) + board delay) / 4) + 2 Note 1: All value (e.g. tPAR_ALERT_ON) should be in terms of DRAM Clock and round up Note 2: Board delay(Command/Alert_n) should be considered. Note 3: Use the worst case(longer) value for PHY Latencies/Board delay Note 4: The Recommended values are minimum value to be set. For mode detail, See 'Calculation of FIFO Depth' section. Max value can be set to this register is defined below: Full bus Mode (CRC=OFF) Max value = 39 Full bus Mode (CRC=ON) Max value = 38 Half bus Mode (CRC=OFF) Max value = 38 Half bus Mode (CRC=ON) Max value = 37 Values of 0, 1 and 2 are illegal.'''
[[register]]
  name = "CRCPARSTAT"
  type = "ro"
  width = 32
  description = "CRC Parity Status Register"
  default = "0x00000000"
  offset = "0x000000CC"
  [[register.field]]
    name = "CMD_IN_ERR_WINDOW"
    bits = "29"
    type = "ro"
    shortdesc = '''Indicate if commands are in the parity/crc error window.'''
    longdesc = '''- 0 - No command is in the parity/crc error window. - 1 - One or more commands are in the parity/crc error window or retry is in progress. This register is valid when CRCPARCTRL1.crc_parity_retry_enable=1.'''
  [[register.field]]
    name = "RETRY_OPERATING_MODE"
    bits = "28"
    type = "ro"
  [[register.field]]
    name = "RETRY_CURRENT_STATE"
    bits = "27:24"
    type = "ro"
  [[register.field]]
    name = "DFI_ALERT_ERR_FATL_CODE"
    bits = "22:20"
    type = "ro"
    shortdesc = '''Indicate reason of dfi_alert_err_fatl_int assertion - [22] MPSMX caused parity error.'''
    longdesc = '''(RCD's parity error detection only) - [21] Parity error happens again during software intervention time - [20] MRS was in retry_fifo_max_hold_timer_x4 window from alert_n=0 or STAT.operating_mode is Init. Two or more reason can be available at the same time It remains set until cleared by CRCPARCTL0.dfi_alert_err_fatl_clr.'''
  [[register.field]]
    name = "DFI_ALERT_ERR_NO_SW"
    bits = "19"
    type = "ro"
    shortdesc = '''Indicate whether software can perform MRS/MPR/PDA during software intervention time.'''
    longdesc = '''- 0 - MRS/MPR/PDA can be performed during software intervention time - 1 - MRS/MPR/PDA can NOT be performed during software intervention time If CRCPARCTL1.alert_wait_for_sw=1 and dfi_alert_err_no_sw=1, software can not perform MRS/MPR/PDA until dfi_alert_err_int is cleared by dfi_alert_err_int_clr. It remains set until cleared by CRCPARCTL0.dfi_alert_err_int_clr.'''
  [[register.field]]
    name = "DFI_ALERT_ERR_MAX_REACHED_INT"
    bits = "18"
    type = "ro"
    shortdesc = '''DFI alert error counter max reached interrupt.'''
    longdesc = '''If the CRCPARSTAT.dfi_alert_err_cnt reaches it maximum value, this interrupt bit is set. It remains set until cleared by CRCPARCTL0.dfi_alert_err_int_clr'''
  [[register.field]]
    name = "DFI_ALERT_ERR_FATL_INT"
    bits = "17"
    type = "ro"
    shortdesc = '''Fatal parity error interrupt.'''
    longdesc = '''One or more these situation below happens, this interrupt bit is set. - PDA operation is in progress/started during retry is in control - Parity error happens again during dfi_alert_err_inrt=1 - MRS was in retry_fifo_max_hold_timer_x4 window from alert_n=0. It remains set until cleared by CRCPARCTL0.dfi_alert_err_fatl_clr. If this interrupt is asserted, system reset is strongly recommended.'''
  [[register.field]]
    name = "DFI_ALERT_ERR_INT"
    bits = "16"
    type = "ro"
    shortdesc = '''DFI alert error interrupt.'''
    longdesc = '''If a parity/CRC error is detected on dfi_alert_n, and the interrupt is enabled by CRCPARCTL0.dfi_alert_err_int_en, this interrupt bit will be set. It will remain set until cleared by CRCPARCTL0.dfi_alert_err_int_clr'''
  [[register.field]]
    name = "DFI_ALERT_ERR_CNT"
    bits = "15:0"
    type = "ro"
    shortdesc = '''DFI alert error count.'''
    longdesc = '''If a parity/CRC error is detected on dfi_alert_n, this counter be incremented. This is independent of the setting of CRCPARCTL0.dfi_alert_err_int_en. It will saturate at 0xFFFF, and can be cleared by asserting CRCPARCTL0.dfi_alert_err_cnt_clr.'''
[[register]]
  name = "INIT0"
  type = "rw"
  width = 32
  description = "SDRAM Initialization Register 0"
  default = "0x0002004E"
  offset = "0x000000D0"
  [[register.field]]
    name = "SKIP_DRAM_INIT"
    bits = "31:30"
    type = "rw"
    shortdesc = '''If lower bit is enabled the SDRAM initialization routine is skipped.'''
    longdesc = '''The upper bit decides what state the controller starts up in when reset is removed - 00 - SDRAM Initialization routine is run after power-up - 01 - SDRAM Initialization routine is skipped after power-up. Controller starts up in Normal Mode - 11 - SDRAM Initialization routine is skipped after power-up. Controller starts up in Self-refresh Mode - 10 - SDRAM Initialization routine is run after power-up. Note: The only 2'b00 is supported for LPDDR4 in this version of the DDRC. Programming Mode: Quasi-dynamic Group 2'''
  [[register.field]]
    name = "POST_CKE_X1024"
    bits = "25:16"
    type = "rw"
    shortdesc = '''Cycles to wait after driving CKE high to start the SDRAM initialization sequence.'''
    longdesc = '''Unit: 1024 clocks. LPDDR3 typically requires this to be programmed for a delay of 200us. LPDDR4 typically requires this to be programmed for a delay of 2us. Program this to JEDEC spec value divided by 2, and round it up to next integer value.'''
  [[register.field]]
    name = "PRE_CKE_X1024"
    bits = "11:0"
    type = "rw"
    shortdesc = '''Cycles to wait after reset before driving CKE high to start the SDRAM initialization sequence.'''
    longdesc = '''Unit: 1024 clock cycles. LPDDR3: tINIT1 of 100 ns (min) LPDDR4: tINIT3 of 2 ms (min) Program this to JEDEC spec value divided by 2, and round it up to next integer value.'''
[[register]]
  name = "INIT1"
  type = "rw"
  width = 32
  description = "SDRAM Initialization Register 1"
  default = "0x00000000"
  offset = "0x000000D4"
  [[register.field]]
    name = "DRAM_RSTN_X1024"
    bits = "24:16"
    type = "rw"
    shortdesc = '''DDR3/DDR4/LPDDR4: Number of cycles to assert SDRAM reset signal during init sequence.'''
    longdesc = '''This should be set to a minimum of 1'''
  [[register.field]]
    name = "FINAL_WAIT_X32"
    bits = "14:8"
    type = "rw"
    shortdesc = '''Cycles to wait after completing the SDRAM initialization sequence before starting the dynamic scheduler.'''
    longdesc = '''Unit: Counts of a global timer that pulses every 32 clock cycles. There is no known specific requirement for this; it may be set to zero.'''
  [[register.field]]
    name = "PRE_OCD_X32"
    bits = "3:0"
    type = "rw"
    shortdesc = '''Wait period before driving the OCD complete command to SDRAM.'''
    longdesc = '''Unit: Counts of a global timer that pulses every 32 clock cycles. There is no known specific requirement for this; it may be set to zero.'''
[[register]]
  name = "INIT2"
  type = "rw"
  width = 32
  description = "SDRAM Initialization Register 2"
  default = "0x00000D05"
  offset = "0x000000D8"
  [[register.field]]
    name = "MIN_STABLE_CLOCK_X1"
    bits = "3:0"
    type = "rw"
    shortdesc = '''Time to wait after the first CKE high, tINIT2.'''
    longdesc = '''Unit: 1 clock cycle. LPDDR3 typically requires 5 x tCK delay.'''
[[register]]
  name = "INIT3"
  type = "rw"
  width = 32
  description = "SDRAM Initialization Register 3"
  default = "0x00000510"
  offset = "0x000000DC"
  [[register.field]]
    name = "MR"
    bits = "31:16"
    type = "rw"
    shortdesc = '''DDR3/DDR4: Value loaded into MR0 register.'''
    longdesc = '''LPDDR3/LPDDR4 - Value to write to MR1 register Programming Mode: Quasi-dynamic Group 1 and Group 4'''
  [[register.field]]
    name = "EMR"
    bits = "15:0"
    type = "rw"
    shortdesc = '''DDR3/DDR4: Value to write to MR1 register Set bit 7 to 0.'''
    longdesc = '''If PHY-evaluation mode training is enabled, this bit is set appropriately by the DDRC during write leveling. LPDDR3/LPDDR4 - Value to write to MR2 register Programming Mode: Quasi-dynamic Group 4'''
[[register]]
  name = "INIT4"
  type = "rw"
  width = 32
  description = "SDRAM Initialization Register 4"
  default = "0x00000000"
  offset = "0x000000E0"
  [[register.field]]
    name = "EMR2"
    bits = "31:16"
    type = "rw"
  [[register.field]]
    name = "EMR3"
    bits = "15:0"
    type = "rw"
[[register]]
  name = "INIT5"
  type = "rw"
  width = 32
  description = "SDRAM Initialization Register 5"
  default = "0x00100004"
  offset = "0x000000E4"
  [[register.field]]
    name = "DEV_ZQINIT_X32"
    bits = "23:16"
    type = "rw"
    shortdesc = '''ZQ initial calibration, tZQINIT.'''
    longdesc = '''Unit: 32 clock cycles. DDR3 typically requires 512 clocks. DDR4 requires 1024 clocks. LPDDR3 requires 1us.'''
  [[register.field]]
    name = "MAX_AUTO_INIT_X1024"
    bits = "9:0"
    type = "rw"
    shortdesc = '''Maximum duration of the auto initialization, tINIT5.'''
    longdesc = '''LPDDR3 typically requires 10us.'''
[[register]]
  name = "INIT6"
  type = "rw"
  width = 32
  description = "SDRAM Initialization Register 6"
  default = "0x00000000"
  offset = "0x000000E8"
  [[register.field]]
    name = "MR4"
    bits = "31:16"
    type = "rw"
    shortdesc = '''DDR4- Value to be loaded into SDRAM MR4 registers.'''
    longdesc = '''Used in DDR4 designs only. Programming Mode: Quasi-dynamic Group 2 and Group 4'''
  [[register.field]]
    name = "MR5"
    bits = "15:0"
    type = "rw"
    shortdesc = '''DDR4- Value to be loaded into SDRAM MR5 registers.'''
    longdesc = '''Used in DDR4 designs only. Programming Mode: Quasi-dynamic Group 1 and Group 4'''
[[register]]
  name = "INIT7"
  type = "rw"
  width = 32
  description = "SDRAM Initialization Register 7"
  default = "0x00000000"
  offset = "0x000000EC"
  [[register.field]]
    name = "MR6"
    bits = "31:16"
    type = "rw"
    shortdesc = '''DDR4- Value to be loaded into SDRAM MR6 registers.'''
    longdesc = '''Used in DDR4 designs only.'''
[[register]]
  name = "DIMMCTL"
  type = "rw"
  width = 32
  description = "DIMM Control Register"
  default = "0x00000000"
  offset = "0x000000F0"
  [[register.field]]
    name = "DIMM_DIS_BG_MIRRORING"
    bits = "5"
    type = "rw"
    shortdesc = '''Disabling Address Mirroring for BG bits.'''
    longdesc = '''When this is set to 1, BG0 and BG1 are NOT swapped even if Address Mirroring is enabled. This will be required for DDR4 DIMMs with x16 devices. - 1 - BG0 and BG1 are NOT swapped. - 0 - BG0 and BG1 are swapped if address mirroring is enabled.'''
  [[register.field]]
    name = "MRS_BG1_EN"
    bits = "4"
    type = "rw"
    shortdesc = '''Enable for BG1 bit of MRS command.'''
    longdesc = '''BG1 bit of the mode register address is specified as RFU (Reserved for Future Use) and must be programmed to 0 during MRS. In case where DRAMs which do not have BG1 are attached and both the CA parity and the Output Inversion are enabled, this must be set to 0, so that the calculation of CA parity will not include BG1 bit. Note: This has no effect on the address of any other memory accesses, or of software-driven mode register accesses. If address mirroring is enabled, this is applied to BG1 of even ranks and BG0 of odd ranks. - 1 - Enabled - 0 - Disabled'''
  [[register.field]]
    name = "MRS_A17_EN"
    bits = "3"
    type = "rw"
    shortdesc = '''Enable for A17 bit of MRS command.'''
    longdesc = '''A17 bit of the mode register address is specified as RFU (Reserved for Future Use) and must be programmed to 0 during MRS. In case where DRAMs which do not have A17 are attached and the Output Inversion are enabled, this must be set to 0, so that the calculation of CA parity will not include A17 bit. Note: This has no effect on the address of any other memory accesses, or of software-driven mode register accesses. - 1 - Enabled - 0 - Disabled'''
  [[register.field]]
    name = "DIMM_OUTPUT_INV_EN"
    bits = "2"
    type = "rw"
    shortdesc = '''Output Inversion Enable (for DDR4 RDIMM implementations only).'''
    longdesc = '''DDR4 RDIMM implements the Output Inversion feature by default, which means that the following address, bank address and bank group bits of B-side DRAMs are inverted: A3-A9, A11, A13, A17, BA0-BA1, BG0-BG1. Setting this bit ensures that, for mode register accesses generated by the DDRC during the automatic initialization routine and enabling of a particular DDR4 feature, separate A-side and B-side mode register accesses are generated. For B-side mode register accesses, these bits are inverted within the DDRC to compensate for this RDIMM inversion. Note: This has no effect on the address of any other memory accesses, or of software-driven mode register accesses. - 1 - Implement output inversion for B-side DRAMs. - 0 - Do not implement output inversion for B-side DRAMs.'''
  [[register.field]]
    name = "DIMM_ADDR_MIRR_EN"
    bits = "1"
    type = "rw"
    shortdesc = '''Address Mirroring Enable (for multi-rank UDIMM implementations and multi-rank DDR4 RDIMM implementations).'''
    longdesc = '''Some UDIMMs and DDR4 RDIMMs implement address mirroring for odd ranks, which means that the following address, bank address and bank group bits are swapped: (A3, A4), (A5, A6), (A7, A8), (BA0, BA1) and also (A11, A13), (BG0, BG1) for the DDR4. Setting this bit ensures that, for mode register accesses during the automatic initialization routine, these bits are swapped within the DDRC to compensate for this UDIMM/RDIMM swapping. In addition to the automatic initialization routine, in case of DDR4 UDIMM/RDIMM, they are swapped during the automatic MRS access to enable/disable of a particular DDR4 feature. Note: This has no effect on the address of any other memory accesses, or of software-driven mode register accesses. This is not supported for LPDDR3 or LPDDR4 SDRAMs. Note: In case of x16 DDR4 DIMMs, BG1 output of MRS for the odd ranks is same as BG0 because BG1 is invalid, hence dimm_dis_bg_mirroring register must be set to 1. - 1 - For odd ranks, implement address mirroring for MRS commands to during initialization and for any automatic DDR4 MRS commands (to be used if UDIMM/RDIMM implements address mirroring) - 0 - Do not implement address mirroring'''
  [[register.field]]
    name = "DIMM_STAGGER_CS_EN"
    bits = "0"
    type = "rw"
    shortdesc = '''Staggering enable for multi-rank accesses (for multi-rank UDIMM and RDIMM implementations only).'''
    longdesc = '''This is not supported for LPDDR3 or LPDDR4 SDRAMs. Note: Even if this bit is set it does not take care of software driven MR commands (via MRCTRL0/MRCTRL1), where software is responsible to send them to separate ranks as appropriate. - 1 - (DDR4) Send MRS commands to each ranks separately - 1 - (non-DDR4) Send all commands to even and odd ranks separately - 0 - Do not stagger accesses'''
[[register]]
  name = "RANKCTL"
  type = "rw"
  width = 32
  description = "Rank Control Register"
  default = "0x0000066F"
  offset = "0x000000F4"
  [[register.field]]
    name = "DIFF_RANK_WR_GAP"
    bits = "11:8"
    type = "rw"
    shortdesc = '''Indicates the number of clocks of gap in data responses when performing consecutive writes to different ranks.'''
    longdesc = '''This is used to switch the delays in the PHY to match the rank requirements. This value should consider both PHY requirement and ODT requirement. - PHY requirement: 7 If CRC feature is enabled, should be increased by 1. If write preamble is set to 2tCK(DDR4/LPDDR4 only), should be increased by 1. If write postamble is set to 1.5tCK(LPDDR4 only), should be increased by 1. - ODT requirement: The value programmed in this register takes care of the ODT switch off timing requirement when switching ranks during writes. For LPDDR4, the requirement is ODTLoff - ODTLon - BL/2 + 1 Program this to the larger value divided by two and round it up to the next integer.'''
  [[register.field]]
    name = "DIFF_RANK_RD_GAP"
    bits = "7:4"
    type = "rw"
    shortdesc = '''Indicates the number of clocks of gap in data responses when performing consecutive reads to different ranks.'''
    longdesc = '''This is used to switch the delays in the PHY to match the rank requirements. This value should consider both PHY requirement and ODT requirement. - PHY requirement: 5 If read preamble is set to 2tCK(DDR4/LPDDR4 only), should be increased by 1. If read postamble is set to 1.5tCK(LPDDR4 only), should be increased by 1. - ODT requirement: The value programmed in this register takes care of the ODT switch off timing requirement when switching ranks during reads. Program this to the larger value divided by two and round it up to the next integer.'''
  [[register.field]]
    name = "MAX_RANK_RD"
    bits = "3:0"
    type = "rw"
    shortdesc = '''Background: Reads to the same rank can be performed back-to-back.'''
    longdesc = '''Reads to different ranks require additional gap dictated by the register RANKCTL.diff_rank_rd_gap. This is to avoid possible data bus contention as well as to give PHY enough time to switch the delay when changing ranks. The DDRC arbitrates for bus access on a cycle-by-cycle basis; therefore after a read is scheduled, there are few clock cycles (determined by the value on RANKCTL.diff_rank_rd_gap register) in which only reads from the same rank are eligible to be scheduled. This prevents reads from other ranks from having fair access to the data bus. This parameter represents the maximum number of reads that can be scheduled consecutively to the same rank. After this number is reached, a delay equal to RANKCTL.diff_rank_rd_gap is inserted by the scheduler to allow all ranks a fair opportunity to be scheduled. Higher numbers increase bandwidth utilization, lower numbers increase fairness. This feature can be DISABLED by setting this register to 0. When set to 0, the Controller will stay on the same rank as long as commands are available for it. Minimum programmable value is 0 (feature disabled) and maximum programmable value is 0xF. FOR PERFORMANCE ONLY.'''
[[register]]
  name = "DRAMTMG0"
  type = "rw"
  width = 32
  description = "SDRAM Timing Register 0"
  default = "0x0F101B0F"
  offset = "0x00000100"
  [[register.field]]
    name = "WR2PRE"
    bits = "30:24"
    type = "rw"
    shortdesc = '''Minimum time between write and precharge to same bank.'''
    longdesc = '''Unit: Clocks Specifications: WL + BL/2 + tWR = approximately 8 cycles + 15 ns = 14 clocks @400MHz and less for lower frequencies where: - WL = write latency - BL = burst length. This must match the value programmed in the BL bit of the mode register to the SDRAM. BST (burst terminate) is not supported at present. - tWR = Write recovery time. This comes directly from the SDRAM specification. Add one extra cycle for LPDDR3/LPDDR4 for this parameter. For 1T mode, divide the above value by 2. No rounding up. For 2T mode or LPDDR4 mode, divide the above value by 2 and round it up to the next integer value. Programming Mode: Quasi-dynamic Group 1, Group 2, and Group 4'''
  [[register.field]]
    name = "T_FAW"
    bits = "21:16"
    type = "rw"
    shortdesc = '''tFAW Valid only when 8 or more banks(or banks x bank groups) are present.'''
    longdesc = '''In 8-bank design, at most 4 banks must be activated in a rolling window of tFAW cycles. Program this to (tFAW/2) and round up to next integer value. In a 4-bank design, set this register to 0x1. Unit: Clocks'''
  [[register.field]]
    name = "T_RAS_MAX"
    bits = "14:8"
    type = "rw"
    shortdesc = '''tRAS(max): Maximum time between activate and precharge to same bank.'''
    longdesc = '''This is the maximum time that a page can be kept open Minimum value of this register is 1. Zero is invalid. Program this to (tRAS(max)-1)/2. No rounding up. Unit: Multiples of 1024 clocks.'''
  [[register.field]]
    name = "T_RAS_MIN"
    bits = "5:0"
    type = "rw"
    shortdesc = '''tRAS(min): Minimum time between activate and precharge to the same bank.'''
    longdesc = '''For 1T mode, program this to tRAS(min)/2. No rounding up. For 2T mode or LPDDR4 mode, program this to (tRAS(min)/2) and round it up to the next integer value. Unit: Clocks'''
[[register]]
  name = "DRAMTMG1"
  type = "rw"
  width = 32
  description = "SDRAM Timing Register 1"
  default = "0x00080414"
  offset = "0x00000104"
  [[register.field]]
    name = "T_XP"
    bits = "20:16"
    type = "rw"
    shortdesc = '''tXP: Minimum time after power-down exit to any operation.'''
    longdesc = '''For DDR3, this should be programmed to tXPDLL if slow powerdown exit is selected in MR0[12]. If C/A parity for DDR4 is used, set to (tXP+PL) instead. Program this to (tXP/2) and round it up to the next integer value. Units: Clocks'''
  [[register.field]]
    name = "RD2PRE"
    bits = "12:8"
    type = "rw"
    shortdesc = '''tRTP: Minimum time from read to precharge of same bank.'''
    longdesc = '''- DDR3: tAL + max (tRTP, 4) - DDR4: Max of following two equations: tAL + max (tRTP, 4) or, RL + BL/2 - tRP. - LPDDR3: BL/2 + max(tRTP,4) - 4 - LPDDR4: BL/2 + max(tRTP,8) - 8 For 1T mode, divide the above value by 2. No rounding up. For 2T mode or LPDDR4 mode, divide the above value by 2 and round it up to the next integer value. Unit: Clocks. Programming Mode: Quasi-dynamic Group 1, Group 2, and Group 4'''
  [[register.field]]
    name = "T_RC"
    bits = "6:0"
    type = "rw"
    shortdesc = '''tRC: Minimum time between activates to same bank.'''
    longdesc = '''Program this to (tRC/2) and round up to next integer value. Unit: Clocks.'''
[[register]]
  name = "DRAMTMG2"
  type = "rw"
  width = 32
  description = "SDRAM Timing Register 2"
  default = "0x0305060D"
  offset = "0x00000108"
  [[register.field]]
    name = "WRITE_LATENCY"
    bits = "29:24"
    type = "rw"
    shortdesc = '''Set to WL Time from write command to write data on SDRAM interface.'''
    longdesc = '''This must be set to WL. Note that, depending on the PHY, if using RDIMM, it may be necessary to use a value of WL + 1 to compensate for the extra cycle of latency through the RDIMM Divide the value calculated using the above equation by 2, and round it up to next integer. This register field is not required for DDR3, as the DFI read and write latencies defined in DFITMG0 and DFITMG1 are sufficient for those protocols Unit: clocks'''
  [[register.field]]
    name = "READ_LATENCY"
    bits = "21:16"
    type = "rw"
    shortdesc = '''Set to RL Time from read command to read data on SDRAM interface.'''
    longdesc = '''This must be set to RL. Note that, depending on the PHY, if using RDIMM, it mat be necessary to use a value of RL + 1 to compensate for the extra cycle of latency through the RDIMM Divide the value calculated using the above equation by 2, and round it up to next integer. This register field is not required for DDR3, as the DFI read and write latencies defined in DFITMG0 and DFITMG1 are sufficient for those protocols Unit: clocks'''
  [[register.field]]
    name = "RD2WR"
    bits = "13:8"
    type = "rw"
    shortdesc = '''DDR3: RL + BL/2 + 2 - WL DDR4: RL + BL/2 + 1 + WR_PREAMBLE - WL LPDDR3: RL + BL/2 + RU(tDQSCKmax/tCK) + 1 - WL LPDDR4(DQ ODT is Disabled): RL + BL/2 + RU(tDQSCKmax/tCK) + WR_PREAMBLE + RD_POSTAMBLE - WL LPDDR4(DQ ODT is Enabled): RL + BL/2 + RU(tDQSCKmax/tCK) + RD_POSTAMBLE - ODTLon - RU(tODTon(min)/tCK) Minimum time from read command to write command.'''
    longdesc = '''Include time for bus turnaround and all per-bank, per-rank, and global constraints. Unit: Clocks. Where: - WL = write latency - BL = burst length. This must match the value programmed in the BL bit of the mode register to the SDRAM - RL = read latency = CAS latency - WR_PREAMBLE = write preamble. This is unique to DDR4 and LPDDR4. - RD_POSTAMBLE = read postamble. This is unique to LPDDR4. For LPDDR3/LPDDR4, if derating is enabled (DERATEEN.derate_enable=1), derated tDQSCKmax should be used. Divide the value calculated using the above equation by 2, and round it up to next integer.'''
  [[register.field]]
    name = "WR2RD"
    bits = "5:0"
    type = "rw"
    shortdesc = '''DDR4: CWL + PL + BL/2 + tWTR_L Others: CWL + BL/2 + tWTR In DDR4, minimum time from write command to read command for same bank group.'''
    longdesc = '''In others, minimum time from write command to read command. Includes time for bus turnaround, recovery times, and all per-bank, per-rank, and global constraints. Unit: Clocks. Where: - CWL = CAS write latency - PL = Parity latency - BL = burst length. This must match the value programmed in the BL bit of the mode register to the SDRAM - tWTR_L = internal write to read command delay for same bank group. This comes directly from the SDRAM specification. - tWTR = internal write to read command delay. This comes directly from the SDRAM specification. Add one extra cycle for LPDDR3/LPDDR4 operation. Divide the value calculated using the above equation by 2, and round it up to next integer.'''
[[register]]
  name = "DRAMTMG3"
  type = "rw"
  width = 32
  description = "SDRAM Timing Register 3"
  default = "0x0050400C"
  offset = "0x0000010C"
  [[register.field]]
    name = "T_MRW"
    bits = "29:20"
    type = "rw"
    shortdesc = '''Time to wait after a mode register write or read (MRW or MRR).'''
    longdesc = '''LPDDR3 typically requires value of 10. LPDDR4: Set this to the larger of tMRW and tMRWCKEL. For this register is used for the time from a MRW/MRR to all other commands. For LDPDR3, this register is used for the time from a MRW/MRR to a MRW/MRR.'''
  [[register.field]]
    name = "T_MRD"
    bits = "17:12"
    type = "rw"
    shortdesc = '''tMRD: Cycles to wait after a mode register write or read.'''
    longdesc = '''Depending on the connected SDRAM, tMRD represents: DDR3/4: Time from MRS to MRS command LPDDR3/4: Time from MRS to non-MRS command Program this to (tMRD/2) and round it up to the next integer value. If C/A parity for DDR4 is used, set to tMRD_PAR(tMOD+PL) instead.'''
  [[register.field]]
    name = "T_MOD"
    bits = "9:0"
    type = "rw"
    shortdesc = '''tMOD: Parameter used only in DDR3 and DDR4.'''
    longdesc = '''Cycles between load mode command and following non-load mode command. If C/A parity for DDR4 is used, set to tMOD_PAR(tMOD+PL) instead. Set to tMOD/2 (rounded up to next integer). Note that if using RDIMM, depending on the PHY, it may be necessary to use a value of tMOD + 1 or (tMOD + 1)/2 to compensate for the extra cycle of latency applied to mode register writes by the RDIMM chip.'''
[[register]]
  name = "DRAMTMG4"
  type = "rw"
  width = 32
  description = "SDRAM Timing Register 4"
  default = "0x05040405"
  offset = "0x00000110"
  [[register.field]]
    name = "T_RCD"
    bits = "28:24"
    type = "rw"
    shortdesc = '''tRCD - tAL: Minimum time from activate to read or write command to same bank.'''
    longdesc = '''Program this to ((tRCD - tAL)/2) and round it up to the next integer value. Minimum value allowed for this register is 1, which implies minimum (tRCD - tAL) value to be 2. Unit: Clocks. Programming Mode: Quasi-dynamic Group 1, Group 2, and Group 4'''
  [[register.field]]
    name = "T_CCD"
    bits = "19:16"
    type = "rw"
    shortdesc = '''DDR4: tCCD_L: This is the minimum time between two reads or two writes for same bank group.'''
    longdesc = '''Others: tCCD: This is the minimum time between two reads or two writes. Program this to (tCCD_L/2 or tCCD/2) and round it up to the next integer value. Unit: clocks.'''
  [[register.field]]
    name = "T_RRD"
    bits = "11:8"
    type = "rw"
    shortdesc = '''DDR4: tRRD_L: Minimum time between activates from bank 'a' to bank 'b' for same bank group.'''
    longdesc = '''Others: tRRD: Minimum time between activates from bank 'a' to bank 'b'Program this to (tRRD_L/2 or tRRD/2) and round it up to the next integer value. Unit: Clocks.'''
  [[register.field]]
    name = "T_RP"
    bits = "4:0"
    type = "rw"
    shortdesc = '''tRP: Minimum time from precharge to activate of same bank.'''
    longdesc = '''t_rp should be set to RoundDown(RoundUp(tRP/tCK)/2) + 1. For LPDDR4, t_rp should be set to RoundUp(RoundUp(tRP/tCK)/2). Unit: Clocks.'''
[[register]]
  name = "DRAMTMG5"
  type = "rw"
  width = 32
  description = "SDRAM Timing Register 5"
  default = "0x05050403"
  offset = "0x00000114"
  [[register.field]]
    name = "T_CKSRX"
    bits = "27:24"
    type = "rw"
    shortdesc = '''This is the time before Self Refresh Exit that CK is maintained as a valid clock before issuing SRX.'''
    longdesc = '''Specifies the clock stable time before SRX. Recommended settings: - LPDDR3: 2 - LPDDR4: tCKCKEH - DDR3: tCKSRX - DDR4: tCKSRX Program this to recommended value divided by two and round it up to next integer.'''
  [[register.field]]
    name = "T_CKSRE"
    bits = "19:16"
    type = "rw"
    shortdesc = '''This is the time after Self Refresh Down Entry that CK is maintained as a valid clock.'''
    longdesc = '''Specifies the clock disable delay after SRE. Recommended settings: - LPDDR3: 2 - LPDDR4: tCKCKEL - DDR3: max (10 ns, 5 tCK) - DDR4: max (10 ns, 5 tCK) Program this to recommended value divided by two and round it up to next integer.'''
  [[register.field]]
    name = "T_CKESR"
    bits = "13:8"
    type = "rw"
    shortdesc = '''Minimum CKE low width for Self refresh or Self refresh power down entry to exit timing in memory clock cycles.'''
    longdesc = '''Recommended settings: - LPDDR3: tCKESR - LPDDR4: max(tCKELPD, tSR) - DDR3: tCKE + 1 - DDR4: tCKE + 1 Program this to recommended value divided by two and round it up to next integer.'''
  [[register.field]]
    name = "T_CKE"
    bits = "4:0"
    type = "rw"
    shortdesc = '''Minimum number of cycles of CKE HIGH/LOW during power-down and self refresh.'''
    longdesc = '''- LPDDR3 mode: Set this to the larger of tCKE or tCKESR - LPDDR4 mode: Set this to the larger of tCKE, tCKELPD or tSR. - Non-non-LPDDR3/non-LPDDR4 designs: Set this to tCKE value. Program this to (value described above)/2 and round it up to the next integer value. Unit: Clocks.'''
[[register]]
  name = "DRAMTMG6"
  type = "rw"
  width = 32
  description = "SDRAM Timing Register 6"
  default = "0x02020005"
  offset = "0x00000118"
  [[register.field]]
    name = "T_CKDPDE"
    bits = "27:24"
    type = "rw"
    shortdesc = '''LPDDR3: This is the time after Deep Power Down Entry that CK is maintained as a valid clock.'''
    longdesc = '''Specifies the clock disable delay after DPDE. Recommended settings: - LPDDR3: 2 Program this to recommended value divided by two and round it up to next integer.'''
  [[register.field]]
    name = "T_CKDPDX"
    bits = "19:16"
    type = "rw"
    shortdesc = '''This is the time before Deep Power Down Exit that CK is maintained as a valid clock before issuing DPDX.'''
    longdesc = '''Specifies the clock stable time before DPDX. Recommended settings: - LPDDR3: 2 Program this to recommended value divided by two and round it up to next integer.'''
  [[register.field]]
    name = "T_CKCSX"
    bits = "3:0"
    type = "rw"
    shortdesc = '''LPDDR3/LPDDR4: This is the time before Clock Stop Exit that CK is maintained as a valid clock before issuing Clock Stop Exit.'''
    longdesc = '''Specifies the clock stable time before next command after Clock Stop Exit. Recommended settings: - LPDDR3: tXP + 2 - LPDDR4: tXP + 2 Program this to recommended value divided by two and round it up to next integer.'''
[[register]]
  name = "DRAMTMG7"
  type = "rw"
  width = 32
  description = "SDRAM Timing Register 7"
  default = "0x00000202"
  offset = "0x0000011C"
  [[register.field]]
    name = "T_CKPDE"
    bits = "11:8"
    type = "rw"
    shortdesc = '''LPDDR3/LPDDR4: This is the time after Power Down Entry that CK is maintained as a valid clock.'''
    longdesc = '''Specifies the clock disable delay after PDE. Recommended settings: - LPDDR3: 2 - LPDDR4: tCKCKEL Program this to recommended value divided by two and round it up to next integer.'''
  [[register.field]]
    name = "T_CKPDX"
    bits = "3:0"
    type = "rw"
    shortdesc = '''LPDDR3/LPDDR4: This is the time before Power Down Exit that CK is maintained as a valid clock before issuing PDX.'''
    longdesc = '''Specifies the clock stable time before PDX. Recommended settings: - LPDDR3: 2 - LPDDR4: 2 Program this to recommended value divided by two and round it up to next integer.'''
[[register]]
  name = "DRAMTMG8"
  type = "rw"
  width = 32
  description = "SDRAM Timing Register 8"
  default = "0x03034405"
  offset = "0x00000120"
  [[register.field]]
    name = "T_XS_FAST_X32"
    bits = "30:24"
    type = "rw"
    shortdesc = '''tXS_FAST: Exit Self Refresh to ZQCL, ZQCS and MRS (only CL, WR, and RTP).'''
    longdesc = '''Program this to the above value divided by 2 and round up to next integer value. Unit: Multiples of 32 clocks. Note: This is applicable to only ZQCL/ZQCS commands. Note: Ensure this is less than or equal to t_xs_x32.'''
  [[register.field]]
    name = "T_XS_ABORT_X32"
    bits = "22:16"
    type = "rw"
    shortdesc = '''tXS_ABORT: Exit Self Refresh to commands not requiring a locked DLL in Self Refresh Abort.'''
    longdesc = '''Program this to the above value divided by 2 and round up to next integer value. Unit: Multiples of 32 clocks. Note: Ensure this is less than or equal to t_xs_x32.'''
  [[register.field]]
    name = "T_XS_DLL_X32"
    bits = "14:8"
    type = "rw"
    shortdesc = '''tXSDLL: Exit Self Refresh to commands requiring a locked DLL.'''
    longdesc = '''Program this to the above value divided by 2 and round up to next integer value. Unit: Multiples of 32 clocks. Note: Used only for DDR3 and DDR4 SDRAMs.'''
  [[register.field]]
    name = "T_XS_X32"
    bits = "6:0"
    type = "rw"
    shortdesc = '''tXS: Exit Self Refresh to commands not requiring a locked DLL.'''
    longdesc = '''Program this to the above value divided by 2 and round up to next integer value. Unit: Multiples of 32 clocks. Note: Used only for DDR3 and DDR4 SDRAMs.'''
[[register]]
  name = "DRAMTMG9"
  type = "rw"
  width = 32
  description = "SDRAM Timing Register 9"
  default = "0x0004040D"
  offset = "0x00000124"
  [[register.field]]
    name = "DDR4_WR_PREAMBLE"
    bits = "30"
    type = "rw"
  [[register.field]]
    name = "T_CCD_S"
    bits = "18:16"
    type = "rw"
    shortdesc = '''DDR4: tCCD_S: This is the minimum time between two reads or two writes for different bank group.'''
    longdesc = '''For bank switching (from bank 'a' to bank 'b'), the minimum time is this value + 1. Program this to (tCCD_S/2) and round it up to the next integer value. Unit: clocks.'''
  [[register.field]]
    name = "T_RRD_S"
    bits = "11:8"
    type = "rw"
    shortdesc = '''DDR4: tRRD_S: Minimum time between activates from bank 'a' to bank 'b' for different bank group.'''
    longdesc = '''Program this to (tRRD_S/2) and round it up to the next integer value. Unit: Clocks.'''
  [[register.field]]
    name = "WR2RD_S"
    bits = "5:0"
    type = "rw"
    shortdesc = '''CWL + PL + BL/2 + tWTR_S Minimum time from write command to read command for different bank group.'''
    longdesc = '''Includes time for bus turnaround, recovery times, and all per-bank, per-rank, and global constraints. Present only in designs configured to support DDR4. Unit: Clocks. Where: - CWL = CAS write latency - PL = Parity latency - BL = burst length. This must match the value programmed in the BL bit of the mode register to the SDRAM - tWTR_S = internal write to read command delay for different bank group. This comes directly from the SDRAM specification. Divide the value calculated using the above equation by 2, and round it up to next integer. Programming Mode: Quasi-dynamic Group 1, Group 2, and Group 4'''
[[register]]
  name = "DRAMTMG11"
  type = "rw"
  width = 32
  description = "SDRAM Timing Register 11"
  default = "0x440C021C"
  offset = "0x0000012C"
  [[register.field]]
    name = "POST_MPSM_GAP_X32"
    bits = "30:24"
    type = "rw"
    shortdesc = '''tXMPDLL: This is the minimum Exit MPSM to commands requiring a locked DLL.'''
    longdesc = '''For DDR4 designs, program this to (tXMPDLL/2) and round it up to the next integer value. Unit: Multiples of 32 clocks.'''
  [[register.field]]
    name = "T_MPX_LH"
    bits = "20:16"
    type = "rw"
    shortdesc = '''tMPX_LH: This is the minimum CS_n Low hold time to CKE rising edge.'''
    longdesc = '''For DDR4 designs, program this to RoundUp(tMPX_LH/2)+1. Unit: clocks.'''
  [[register.field]]
    name = "T_MPX_S"
    bits = "9:8"
    type = "rw"
    shortdesc = '''tMPX_S: Minimum time CS setup time to CKE.'''
    longdesc = '''For DDR4 designs, program this to (tMPX_S/2) and round it up to the next integer value. Unit: Clocks.'''
  [[register.field]]
    name = "T_CKMPE"
    bits = "4:0"
    type = "rw"
    shortdesc = '''DDR4: tCKMPE: Minimum valid clock requirement after MPSM entry.'''
    longdesc = '''Unit: Clocks. Divide the value calculated using the above equation by 2, and round it up to next integer.'''
[[register]]
  name = "DRAMTMG12"
  type = "rw"
  width = 32
  description = "SDRAM Timing Register 12"
  default = "0x00020610"
  offset = "0x00000130"
  [[register.field]]
    name = "T_CMDCKE"
    bits = "17:16"
    type = "rw"
    shortdesc = '''tCMDCKE: Delay from valid command to CKE input LOW.'''
    longdesc = '''Set this to the larger of tESCKE or tCMDCKE Program this to (max(tESCKE, tCMDCKE)/2) and round it up to next integer value.'''
  [[register.field]]
    name = "T_CKEHCMD"
    bits = "11:8"
    type = "rw"
    shortdesc = '''tCKEHCMD: Valid command requirement after CKE input HIGH.'''
    longdesc = '''Program this to (tCKEHCMD/2) and round it up to next integer value.'''
  [[register.field]]
    name = "T_MRD_PDA"
    bits = "4:0"
    type = "rw"
    shortdesc = '''tMRD_PDA: This is the Mode Register Set command cycle time in PDA mode.'''
    longdesc = '''Program this to (tMRD_PDA/2) and round it up to next integer value.'''
[[register]]
  name = "DRAMTMG13"
  type = "rw"
  width = 32
  description = "SDRAM Timing Register 13"
  default = "0x1C200004"
  offset = "0x00000134"
  [[register.field]]
    name = "ODTLOFF"
    bits = "30:24"
    type = "rw"
    shortdesc = '''LPDDR4: tODTLoff: This is the latency from CAS-2 command to tODToff reference.'''
    longdesc = '''Program this to (tODTLoff/2) and round it up to next integer value. Unit: Clocks.'''
  [[register.field]]
    name = "T_CCD_MW"
    bits = "21:16"
    type = "rw"
    shortdesc = '''LPDDR4: tCCDMW: This is the minimum time from write or masked write to masked write command for same bank.'''
    longdesc = '''Program this to (tCCDMW/2) and round it up to next integer value. Unit: Clocks.'''
  [[register.field]]
    name = "T_PPD"
    bits = "2:0"
    type = "rw"
    shortdesc = '''LPDDR4: tPPD: This is the minimum time from precharge to precharge command.'''
    longdesc = '''Program this to (tPPD/2) and round it up to next integer value. Unit: Clocks.'''
[[register]]
  name = "DRAMTMG14"
  type = "rw"
  width = 32
  description = "SDRAM Timing Register 14"
  default = "0x000000A0"
  offset = "0x00000138"
  [[register.field]]
    name = "T_XSR"
    bits = "11:0"
    type = "rw"
    shortdesc = '''tXSR: Exit Self Refresh to any command.'''
    longdesc = '''Program this to the above value divided by 2 and round up to next integer value. Note: Used only for LPDDR3/LPDDR4 mode.'''
[[register]]
  name = "ZQCTL0"
  type = "rw"
  width = 32
  description = "ZQ Control Register 0"
  default = "0x02000040"
  offset = "0x00000180"
  [[register.field]]
    name = "DIS_AUTO_ZQ"
    bits = "31"
    type = "rw"
    shortdesc = '''- 1 - Disable DDRC generation of ZQCS/MPC(ZQ calibration) command.'''
    longdesc = '''Register DBGCMD.zq_calib_short can be used instead to issue ZQ calibration request from APB module. - 0 - Internally generate ZQCS/MPC(ZQ calibration) commands based on ZQCTL1.t_zq_short_interval_x1024. Programming Mode: Dynamic'''
  [[register.field]]
    name = "DIS_SRX_ZQCL"
    bits = "30"
    type = "rw"
    shortdesc = '''- 1 - Disable issuing of ZQCL/MPC(ZQ calibration) command at Self-Refresh/SR-Powerdown exit.'''
    longdesc = '''- 0 - Enable issuing of ZQCL/MPC(ZQ calibration) command at Self-Refresh/SR-Powerdown exit. Programming Mode: Quasi-dynamic Group 2 and Group 4'''
  [[register.field]]
    name = "ZQ_RESISTOR_SHARED"
    bits = "29"
    type = "rw"
    shortdesc = '''- 1 - Denotes that ZQ resistor is shared between ranks.'''
    longdesc = '''Means ZQinit/ZQCL/ZQCS/MPC(ZQ calibration) commands are sent to one rank at a time with tZQinit/tZQCL/tZQCS/tZQCAL/tZQLAT timing met between commands so that commands to different ranks do not overlap. - 0 - ZQ resistor is not shared.'''
  [[register.field]]
    name = "DIS_MPSMX_ZQCL"
    bits = "28"
    type = "rw"
    shortdesc = '''- 1 - Disable issuing of ZQCL command at Maximum Power Saving Mode exit.'''
    longdesc = '''Only applicable when run in DDR4 mode. - 0 - Enable issuing of ZQCL command at Maximum Power Saving Mode exit. Only applicable when run in DDR4 mode.'''
  [[register.field]]
    name = "T_ZQ_LONG_NOP"
    bits = "26:16"
    type = "rw"
    shortdesc = '''tZQoper for DDR3/DDR4, tZQCL for LPDDR3, tZQCAL for LPDDR4: Number of cycles of NOP required after a ZQCL (ZQ calibration long)/MPC(ZQ Start) command is issued to SDRAM.'''
    longdesc = '''DDR3/DDR4: program this to tZQoper/2 and round it up to the next integer value. LPDDR3: program this to tZQCL/2 and round it up to the next integer value. LPDDR4: program this to tZQCAL/2 and round it up to the next integer value. Unit: Clock cycles.'''
  [[register.field]]
    name = "T_ZQ_SHORT_NOP"
    bits = "9:0"
    type = "rw"
    shortdesc = '''tZQCS for DDR3/DD4/LPDDR3, tZQLAT for LPDDR4: Number of cycles of NOP required after a ZQCS (ZQ calibration short)/MPC(ZQ Latch) command is issued to SDRAM.'''
    longdesc = '''Program this to tZQCS/2 and round it up to the next integer value. Unit: Clock cycles.'''
[[register]]
  name = "ZQCTL1"
  type = "rw"
  width = 32
  description = "ZQ Control Register 1"
  default = "0x02000100"
  offset = "0x00000184"
  [[register.field]]
    name = "T_ZQ_RESET_NOP"
    bits = "29:20"
    type = "rw"
    shortdesc = '''tZQReset: Number of cycles of NOP required after a ZQReset (ZQ calibration Reset) command is issued to SDRAM.'''
    longdesc = '''For LPDDR3/LPDDR4 designs, program this to tZQReset/2 and round it up to the next integer value. Unit: Clock cycles.'''
  [[register.field]]
    name = "T_ZQ_SHORT_INTERVAL_X1024"
    bits = "19:0"
    type = "rw"
    shortdesc = '''Average interval to wait between automatically issuing ZQCS (ZQ calibration short)/MPC(ZQ calibration) commands to DDR3/DDR4/LPDDR3/LPDDR4 devices.'''
    longdesc = '''Meaningless, if ZQCTL0.dis_auto_zq=1. Unit: 1024 clock cycles.'''
[[register]]
  name = "ZQCTL2"
  type = "rw"
  width = 32
  description = "ZQ Control Register 2"
  default = "0x00000000"
  offset = "0x00000188"
  [[register.field]]
    name = "ZQ_RESET"
    bits = "0"
    type = "rw"
    shortdesc = '''For LPDDR3/LPDDR4 designs, setting this register bit to 1 triggers a ZQ Reset operation.'''
    longdesc = '''When the ZQ Reset operation is complete, the DDRC automatically clears this bit. It is recommended NOT to set this signal if in Init, Self-Refresh(except LPDDR4) or SR-Powerdown(LPDDR4) or Deep power-down operating modes.'''
[[register]]
  name = "ZQSTAT"
  type = "ro"
  width = 32
  description = "ZQ Status Register"
  default = "0x00000000"
  offset = "0x0000018C"
  [[register.field]]
    name = "ZQ_RESET_BUSY"
    bits = "0"
    type = "ro"
    shortdesc = '''SoC core may initiate a ZQ Reset operation only if this signal is low.'''
    longdesc = '''This signal goes high in the clock after the DDRC accepts the ZQ Reset request. It goes low when the ZQ Reset command is issued to the SDRAM and the associated NOP period is over. It is recommended not to perform ZQ Reset commands when this signal is high. - 0 - Indicates that the SoC core can initiate a ZQ Reset operation - 1 - Indicates that ZQ Reset operation is in progress'''
[[register]]
  name = "DFITMG0"
  type = "rw"
  width = 32
  description = "DFI Timing Register 0"
  default = "0x07020002"
  offset = "0x00000190"
  [[register.field]]
    name = "DFI_T_CTRL_DELAY"
    bits = "28:24"
    type = "rw"
    shortdesc = '''Specifies the number of DFI clock cycles after an assertion or de-assertion of the DFI control signals that the control signals at the PHY-DRAM interface reflect the assertion or de-assertion.'''
    longdesc = '''If the DFI clock and the memory clock are not phase-aligned, this timing parameter should be rounded up to the next integer value. Note that if using RDIMM, it is necessary to increment this parameter by RDIMM's extra cycle of latency in terms of DFI clock. This should be set to 4. Programming Mode: Quasi-dynamic Group 4'''
  [[register.field]]
    name = "DFI_RDDATA_USE_SDR"
    bits = "23"
    type = "rw"
    shortdesc = '''Defines whether dfi_rddata_en/dfi_rddata/dfi_rddata_valid is generated using HDR or SDR values Selects whether value in DFITMG0.'''
    longdesc = '''dfi_t_rddata_en is in terms of SDR or HDR clock cycles: - 0 in terms of HDR clock cycles - 1 in terms of SDR clock cycles This should be set to 1.'''
  [[register.field]]
    name = "DFI_T_RDDATA_EN"
    bits = "21:16"
    type = "rw"
    shortdesc = '''Time from the assertion of a read command on the DFI interface to the assertion of the dfi_rddata_en signal.'''
    longdesc = '''For DDR3 and DDR4, set to RL-4. For LPDDR3, set to RL+int(1.5/clock_period)-4. For LPDDR4 with speed bin >= 1600, set to RL+int(1.5/clock_period)-4. For LPDDR4 with speed bin < 1600, set to RL-3. This corresponds to the DFI parameter trddata_en. Unit: Clocks Programming Mode: Quasi-dynamic Group 1 and Group 4'''
  [[register.field]]
    name = "DFI_WRDATA_USE_SDR"
    bits = "15"
    type = "rw"
    shortdesc = '''Defines whether dfi_wrdata_en/dfi_wrdata/dfi_wrdata_mask is generated using HDR or SDR values Selects whether value in DFITMG0.'''
    longdesc = '''dfi_tphy_wrlat is in terms of SDR or HDR clock cycles Selects whether value in DFITMG0.dfi_tphy_wrdata is in terms of SDR or HDR clock cycles - 0 in terms of HDR clock cycles - 1 in terms of SDR clock cycles This should be set to 1.'''
  [[register.field]]
    name = "DFI_TPHY_WRDATA"
    bits = "13:8"
    type = "rw"
    shortdesc = '''Specifies the number of clock cycles between when dfi_wrdata_en is asserted to when the associated write data is driven on the dfi_wrdata signal.'''
    longdesc = '''This corresponds to the DFI timing parameter tphy_wrdata. This should be set to 2. Note, max supported value is 8. Unit: Clocks Programming Mode: Quasi-dynamic Group 4'''
  [[register.field]]
    name = "DFI_TPHY_WRLAT"
    bits = "5:0"
    type = "rw"
    shortdesc = '''Write latency Number of clocks from the write command to write data enable (dfi_wrdata_en).'''
    longdesc = '''This corresponds to the DFI timing parameter tphy_wrlat. This should be set to WL-3 for DDR3 and DDR4 component and SODIMM designs. It should be set to WL-2 for LPDDR3 and LPDDR4 designs as well as DDR3 and DDR4 RDIMM designs. Programming Mode: Quasi-dynamic Group 1 and Group 4'''
[[register]]
  name = "DFITMG1"
  type = "rw"
  width = 32
  description = "DFI Timing Register 1"
  default = "0x00000404"
  offset = "0x00000194"
  [[register.field]]
    name = "DFI_T_CMD_LAT"
    bits = "31:28"
    type = "rw"
    shortdesc = '''Specifies the number of DFI PHY clocks between when the dfi_cs signal is asserted and when the associated command is driven.'''
    longdesc = '''This field is used for CAL mode, should be set to '0' or the value which matches the CAL mode register setting in the DRAM. If the PHY can add the latency for CAL mode, this should be set to '0'. Valid Range: 0, 3, 4, 5, 6, and 8 Programming Mode: Quasi-dynamic Group 2 and Group 4'''
  [[register.field]]
    name = "DFI_T_PARIN_LAT"
    bits = "25:24"
    type = "rw"
  [[register.field]]
    name = "DFI_T_WRDATA_DELAY"
    bits = "20:16"
    type = "rw"
    shortdesc = '''Specifies the number of DFI clocks between when the dfi_wrdata_en signal is asserted and when the corresponding write data transfer is completed on the DRAM bus.'''
    longdesc = '''This corresponds to the DFI timing parameter twrdata_delay. Set to twrdata_delay, a new timing parameter introduced in DFI 3.0. Value to be programmed is in terms of DFI clocks, not PHY clocks. Divide PHY's value by 2 and round up to next integer. If using DFITMG0.dfi_wrdata_use_sdr=1, add 1 to the value. For DDR4 and LPDDR4, this should be set to 3. For DDR3 and LPDDR3, this should be set to 2. Unit: Clocks'''
  [[register.field]]
    name = "DFI_T_DRAM_CLK_DISABLE"
    bits = "11:8"
    type = "rw"
    shortdesc = '''Specifies the number of DFI clock cycles from the assertion of the dfi_dram_clk_disable signal on the DFI until the clock to the DRAM memory devices, at the PHY-DRAM boundary, maintains a low value.'''
    longdesc = '''If the DFI clock and the memory clock are not phase aligned, this timing parameter should be rounded up to the next integer value.'''
  [[register.field]]
    name = "DFI_T_DRAM_CLK_ENABLE"
    bits = "3:0"
    type = "rw"
    shortdesc = '''Specifies the number of DFI clock cycles from the de-assertion of the dfi_dram_clk_disable signal on the DFI until the first valid rising edge of the clock to the DRAM memory devices, at the PHY-DRAM boundary.'''
    longdesc = '''If the DFI clock and the memory clock are not phase aligned, this timing parameter should be rounded up to the next integer value.'''
[[register]]
  name = "DFILPCFG0"
  type = "rw"
  width = 32
  description = "DFI Low Power Configuration Register 0"
  default = "0x07000000"
  offset = "0x00000198"
  [[register.field]]
    name = "DFI_TLP_RESP"
    bits = "27:24"
    type = "rw"
    shortdesc = '''Setting for DFI's tlp_resp time.'''
    longdesc = '''Same value is used for both Power Down, Self Refresh, Deep Power Down and Maximum Power Saving modes. DFI 2.1 specification onwards, recommends using a fixed value of 7 always.'''
  [[register.field]]
    name = "DFI_LP_WAKEUP_DPD"
    bits = "23:20"
    type = "rw"
    shortdesc = '''LPDDR3: Value to drive on dfi_lp_wakeup signal when Deep Power Down mode is entered.'''
    longdesc = '''Determines the DFI's tlp_wakeup time: - 0x0 - 16 cycles - 0x1 - 32 cycles - 0x2 - 64 cycles - 0x3 - 128 cycles - 0x4 - 256 cycles - 0x5 - 512 cycles - 0x6 - 1024 cycles - 0x7 - 2048 cycles - 0x8 - 4096 cycles - 0x9 - 8192 cycles - 0xA - 16384 cycles - 0xB - 32768 cycles - 0xC - 65536 cycles - 0xD - 131072 cycles - 0xE - 262144 cycles - 0xF - Unlimited'''
  [[register.field]]
    name = "DFI_LP_EN_DPD"
    bits = "16"
    type = "rw"
    shortdesc = '''LPDDR3: Enables DFI Low Power interface handshaking during Deep Power Down Entry/Exit.'''
    longdesc = '''- 0 - Disabled - 1 - Enabled'''
  [[register.field]]
    name = "DFI_LP_WAKEUP_SR"
    bits = "15:12"
    type = "rw"
    shortdesc = '''Value to drive on dfi_lp_wakeup signal when Self Refresh mode is entered.'''
    longdesc = '''Determines the DFI's tlp_wakeup time: - 0x0 - 16 cycles - 0x1 - 32 cycles - 0x2 - 64 cycles - 0x3 - 128 cycles - 0x4 - 256 cycles - 0x5 - 512 cycles - 0x6 - 1024 cycles - 0x7 - 2048 cycles - 0x8 - 4096 cycles - 0x9 - 8192 cycles - 0xA - 16384 cycles - 0xB - 32768 cycles - 0xC - 65536 cycles - 0xD - 131072 cycles - 0xE - 262144 cycles - 0xF - Unlimited'''
  [[register.field]]
    name = "DFI_LP_EN_SR"
    bits = "8"
    type = "rw"
    shortdesc = '''Enables DFI Low Power interface handshaking during Self Refresh Entry/Exit.'''
    longdesc = '''- 0 - Disabled - 1 - Enabled'''
  [[register.field]]
    name = "DFI_LP_WAKEUP_PD"
    bits = "7:4"
    type = "rw"
    shortdesc = '''Value to drive on dfi_lp_wakeup signal when Power Down mode is entered.'''
    longdesc = '''Determines the DFI's tlp_wakeup time: - 0x0 - 16 cycles - 0x1 - 32 cycles - 0x2 - 64 cycles - 0x3 - 128 cycles - 0x4 - 256 cycles - 0x5 - 512 cycles - 0x6 - 1024 cycles - 0x7 - 2048 cycles - 0x8 - 4096 cycles - 0x9 - 8192 cycles - 0xA - 16384 cycles - 0xB - 32768 cycles - 0xC - 65536 cycles - 0xD - 131072 cycles - 0xE - 262144 cycles - 0xF - Unlimited'''
  [[register.field]]
    name = "DFI_LP_EN_PD"
    bits = "0"
    type = "rw"
    shortdesc = '''Enables DFI Low Power interface handshaking during Power Down Entry/Exit.'''
    longdesc = '''- 0 - Disabled - 1 - Enabled'''
[[register]]
  name = "DFILPCFG1"
  type = "rw"
  width = 32
  description = "DFI Low Power Configuration Register 1"
  default = "0x00000000"
  offset = "0x0000019C"
  [[register.field]]
    name = "DFI_LP_WAKEUP_MPSM"
    bits = "7:4"
    type = "rw"
    shortdesc = '''DDR4: Value to drive on dfi_lp_wakeup signal when Maximum Power Saving Mode is entered.'''
    longdesc = '''Determines the DFI's tlp_wakeup time: - 0x0 - 16 cycles - 0x1 - 32 cycles - 0x2 - 64 cycles - 0x3 - 128 cycles - 0x4 - 256 cycles - 0x5 - 512 cycles - 0x6 - 1024 cycles - 0x7 - 2048 cycles - 0x8 - 4096 cycles - 0x9 - 8192 cycles - 0xA - 16384 cycles - 0xB - 32768 cycles - 0xC - 65536 cycles - 0xD - 131072 cycles - 0xE - 262144 cycles - 0xF - Unlimited'''
  [[register.field]]
    name = "DFI_LP_EN_MPSM"
    bits = "0"
    type = "rw"
    shortdesc = '''DDR4: Enables DFI Low Power interface handshaking during Maximum Power Saving Mode Entry/Exit.'''
    longdesc = '''- 0 - Disabled - 1 - Enabled'''
[[register]]
  name = "DFIUPD0"
  type = "rw"
  width = 32
  description = "DFI Update Register 0"
  default = "0x00400003"
  offset = "0x000001A0"
  [[register.field]]
    name = "DIS_AUTO_CTRLUPD"
    bits = "31"
    type = "rw"
    shortdesc = '''When '1', disable the automatic dfi_ctrlupd_req generation by the DDRC.'''
    longdesc = '''The core must issue the dfi_ctrlupd_req signal using register reg_ddrc_ctrlupd. When '0', DDRC issues dfi_ctrlupd_req periodically. Quasi-dynamic Group 3'''
  [[register.field]]
    name = "DIS_AUTO_CTRLUPD_SRX"
    bits = "30"
    type = "rw"
    shortdesc = '''When '1', disable the automatic dfi_ctrlupd_req generation by the DDRC following a self-refresh exit.'''
    longdesc = '''The core must issue the dfi_ctrlupd_req signal using register reg_ddrc_ctrlupd. When '0', DDRC issues a dfi_ctrlupd_req after exiting self-refresh.'''
  [[register.field]]
    name = "DFI_T_CTRLUP_MAX"
    bits = "25:16"
    type = "rw"
    shortdesc = '''Specifies the maximum number of clock cycles that the dfi_ctrlupd_req signal can assert.'''
    longdesc = '''Lowest value to assign to this variable is 0x40. Unit: Clocks'''
  [[register.field]]
    name = "DFI_T_CTRLUP_MIN"
    bits = "9:0"
    type = "rw"
    shortdesc = '''Specifies the minimum number of clock cycles that the dfi_ctrlupd_req signal must be asserted.'''
    longdesc = '''The DDRC expects the PHY to respond within this time. If the PHY does not respond, the DDRC will de-assert dfi_ctrlupd_req after dfi_t_ctrlup_min + 2 cycles. Lowest value to assign to this variable is 0x3. Unit: Clocks'''
[[register]]
  name = "DFIUPD1"
  type = "rw"
  width = 32
  description = "DFI Update Register 1"
  default = "0x00000000"
  offset = "0x000001A4"
  [[register.field]]
    name = "DFI_T_CTRLUPD_INTERVAL_MIN_X1024"
    bits = "23:16"
    type = "rw"
    shortdesc = '''This is the minimum amount of time between DDRC initiated DFI update requests (which is executed whenever the DDRC is idle).'''
    longdesc = '''Set this number higher to reduce the frequency of update requests, which can have a small impact on the latency of the first read request when the DDRC is idle. Unit: 1024 clocks'''
  [[register.field]]
    name = "DFI_T_CTRLUPD_INTERVAL_MAX_X1024"
    bits = "7:0"
    type = "rw"
    shortdesc = '''This is the maximum amount of time between DDRC initiated DFI update requests.'''
    longdesc = '''This timer resets with each update request; when the timer expires dfi_ctrlupd_req is sent and traffic is blocked until the dfi_ctrlupd_ackx is received. PHY can use this idle time to recalibrate the delay lines to the DLLs. The DFI controller update is also used to reset PHY FIFO pointers in case of data capture errors. Updates are required to maintain calibration over PVT, but frequent updates may impact performance. Note: Value programmed for DFIUPD1.dfi_t_ctrlupd_interval_max_x1024 must be greater than DFIUPD1.dfi_t_ctrlupd_interval_min_x1024. Unit: 1024 clocks'''
[[register]]
  name = "DFIUPD2"
  type = "rw"
  width = 32
  description = "DFI Update Register 2"
  default = "0x80000000"
  offset = "0x000001A8"
  [[register.field]]
    name = "DFI_PHYUPD_EN"
    bits = "31"
    type = "rw"
[[register]]
  name = "DFIMISC"
  type = "rw"
  width = 32
  description = "DFI Miscellaneous Control Register"
  default = "0x00000001"
  offset = "0x000001B0"
  [[register.field]]
    name = "DFI_DATA_CS_POLARITY"
    bits = "2"
    type = "rw"
    shortdesc = '''Defines polarity of dfi_wrdata_cs and dfi_rddata_cs signals.'''
    longdesc = '''- 0: Signals are active low - 1: Signals are active high'''
  [[register.field]]
    name = "PHY_DBI_MODE"
    bits = "1"
    type = "rw"
    shortdesc = '''DBI implemented in DDRC or PHY.'''
    longdesc = '''- 0 - DDRC implements DBI functionality. - 1 - PHY implements DBI functionality.'''
  [[register.field]]
    name = "DFI_INIT_COMPLETE_EN"
    bits = "0"
    type = "rw"
    shortdesc = '''PHY initialization complete enable signal.'''
    longdesc = '''When asserted the dfi_init_complete signal can be used to trigger SDRAM initialization Programming Mode: Quasi-dynamic Group 3'''
[[register]]
  name = "DFITMG2"
  type = "rw"
  width = 32
  description = "DFI Timing Register 2"
  default = "0x00000202"
  offset = "0x000001B4"
  [[register.field]]
    name = "DFI_TPHY_RDCSLAT"
    bits = "13:8"
    type = "rw"
    shortdesc = '''>Number of clocks between when a read command is sent on the DFI control interface and when the associated dfi_rddata_cs signal is asserted.'''
    longdesc = '''This corresponds to the DFI timing parameter tphy_rdcslat. This should be set to dfi_t_rddata_en - 2.'''
  [[register.field]]
    name = "DFI_TPHY_WRCSLAT"
    bits = "5:0"
    type = "rw"
    shortdesc = '''Number of clocks between when a write command is sent on the DFI control interface and when the associated dfi_wrdata_cs signal is asserted.'''
    longdesc = '''This corresponds to the DFI timing parameter tphy_wrcslat. For non-RDIMM systems, this should be set to dfi_tphy_wrlat-5. For RDIMM systems, this should be set to 2.'''
[[register]]
  name = "DBICTL"
  type = "rw"
  width = 32
  description = "DM/DBI Control Register"
  default = "0x00000001"
  offset = "0x000001C0"
  [[register.field]]
    name = "RD_DBI_EN"
    bits = "2"
    type = "rw"
    shortdesc = '''Read DBI enable signal in DDRC.'''
    longdesc = '''- 0 - Read DBI is disabled. - 1 - Read DBI is enabled. This signal must be set the same value as DRAM's mode register. - DDR4: MR5 bit A12. - LPDDR4: MR3[6]'''
  [[register.field]]
    name = "WR_DBI_EN"
    bits = "1"
    type = "rw"
    shortdesc = '''Write DBI enable signal in DDRC.'''
    longdesc = '''- 0 - Write DBI is disabled. - 1 - Write DBI is enabled. This signal must be set the same value as DRAM's mode register. - DDR4: MR5 bit A11. - LPDDR4: MR3[7]'''
  [[register.field]]
    name = "DM_EN"
    bits = "0"
    type = "rw"
    shortdesc = '''DM enable signal in DDRC.'''
    longdesc = '''- 0 - DM is disabled. - 1 - DM is enabled. This signal must be set the same logical value as DRAM's mode register. - DDR4: Set this to same value as MR5 bit A10. - LPDDR4: Set this to inverted value of MR13[5] which is opposite polarity from this signal Programming Mode: Quasi-dynamic Group 3'''
[[register]]
  name = "ADDRMAP0"
  type = "rw"
  width = 32
  description = "Address Map Register 0"
  default = "0x00000000"
  offset = "0x00000200"
  [[register.field]]
    name = "ADDRMAP_CS_BIT0"
    bits = "4:0"
    type = "rw"
    shortdesc = '''Selects the HIF address bit used as rank address bit 0.'''
    longdesc = '''Valid Range: 0 to 27, and 31 Internal Base: 6 The selected HIF address bit is determined by adding the internal base to the value of this field. If set to 31, rank address bit 0 is set to 0.'''
[[register]]
  name = "ADDRMAP1"
  type = "rw"
  width = 32
  description = "Address Map Register 1"
  default = "0x00000000"
  offset = "0x00000204"
  [[register.field]]
    name = "ADDRMAP_BANK_B2"
    bits = "20:16"
    type = "rw"
    shortdesc = '''Selects the HIF address bit used as bank address bit 2.'''
    longdesc = '''Valid Range: 0 to 29 and 31 Internal Base: 4 The selected HIF address bit is determined by adding the internal base to the value of this field. If set to 31, bank address bit 2 is set to 0.'''
  [[register.field]]
    name = "ADDRMAP_BANK_B1"
    bits = "12:8"
    type = "rw"
    shortdesc = '''Selects the HIF address bits used as bank address bit 1.'''
    longdesc = '''Valid Range: 0 to 30 Internal Base: 3 The selected HIF address bit for each of the bank address bits is determined by adding the internal base to the value of this field.'''
  [[register.field]]
    name = "ADDRMAP_BANK_B0"
    bits = "4:0"
    type = "rw"
    shortdesc = '''Selects the HIF address bits used as bank address bit 0.'''
    longdesc = '''Valid Range: 0 to 30 Internal Base: 2 The selected HIF address bit for each of the bank address bits is determined by adding the internal base to the value of this field.'''
[[register]]
  name = "ADDRMAP2"
  type = "rw"
  width = 32
  description = "Address Map Register 2"
  default = "0x00000000"
  offset = "0x00000208"
  [[register.field]]
    name = "ADDRMAP_COL_B5"
    bits = "27:24"
    type = "rw"
    shortdesc = '''- Full bus width mode: Selects the HIF address bit used as column address bit 5.'''
    longdesc = '''- Half bus width mode: Selects the HIF address bit used as column address bit 6. Valid Range: 0 to 7, and 15 Internal Base: 5 The selected HIF address bit is determined by adding the internal base to the value of this field. If set to 15, this column address bit is set to 0.'''
  [[register.field]]
    name = "ADDRMAP_COL_B4"
    bits = "19:16"
    type = "rw"
    shortdesc = '''- Full bus width mode: Selects the HIF address bit used as column address bit 4.'''
    longdesc = '''- Half bus width mode: Selects the HIF address bit used as column address bit 5. Valid Range: 0 to 7, and 15 Internal Base: 4 The selected HIF address bit is determined by adding the internal base to the value of this field. If set to 15, this column address bit is set to 0.'''
  [[register.field]]
    name = "ADDRMAP_COL_B3"
    bits = "11:8"
    type = "rw"
    shortdesc = '''- Full bus width mode: Selects the HIF address bit used as column address bit 3.'''
    longdesc = '''- Half bus width mode: Selects the HIF address bit used as column address bit 4. Valid Range: 0 Internal Base: 3 The selected HIF address bit is determined by adding the internal base to the value of this field. Note, it is required to program this to 0, hence register does not exist in this case.'''
  [[register.field]]
    name = "ADDRMAP_COL_B2"
    bits = "3:0"
    type = "rw"
    shortdesc = '''- Full bus width mode: Selects the HIF address bit used as column address bit 2.'''
    longdesc = '''- Half bus width mode: Selects the HIF address bit used as column address bit 3. Valid Range: 0 Internal Base: 2 The selected HIF address bit is determined by adding the internal base to the value of this field. Note, it is required to program this to 0.'''
[[register]]
  name = "ADDRMAP3"
  type = "rw"
  width = 32
  description = "Address Map Register 3"
  default = "0x00000000"
  offset = "0x0000020C"
  [[register.field]]
    name = "ADDRMAP_COL_B9"
    bits = "27:24"
    type = "rw"
    shortdesc = '''- Full bus width mode: Selects the HIF address bit used as column address bit 9.'''
    longdesc = '''- Half bus width mode: Selects the HIF address bit used as column address bit 11 (10 in LPDDR3 mode). Valid Range: 0 to 7, and 15 Internal Base: 9 The selected HIF address bit is determined by adding the internal base to the value of this field. If set to 15, this column address bit is set to 0. Note: Per JEDEC DDR3 specification, column address bit 10 is reserved for indicating auto-precharge, and hence no source address bit can be mapped to column address bit 10. In LPDDR3, there is a dedicated bit for auto-precharge in the CA bus and hence column bit 10 is used.'''
  [[register.field]]
    name = "ADDRMAP_COL_B8"
    bits = "19:16"
    type = "rw"
    shortdesc = '''- Full bus width mode: Selects the HIF address bit used as column address bit 8.'''
    longdesc = '''- Half bus width mode: Selects the HIF address bit used as column address bit 9. Valid Range: 0 to 7, and 15 Internal Base: 8 The selected HIF address bit is determined by adding the internal base to the value of this field. If set to 15, this column address bit is set to 0. Note: Per JEDEC DDR3 specification, column address bit 10 is reserved for indicating auto-precharge, and hence no source address bit can be mapped to column address bit 10. In LPDDR3, there is a dedicated bit for auto-precharge in the CA bus and hence column bit 10 is used.'''
  [[register.field]]
    name = "ADDRMAP_COL_B7"
    bits = "11:8"
    type = "rw"
    shortdesc = '''- Full bus width mode: Selects the HIF address bit used as column address bit 7.'''
    longdesc = '''- Half bus width mode: Selects the HIF address bit used as column address bit 8. Valid Range: 0 to 7, and 15 Internal Base: 7 The selected HIF address bit is determined by adding the internal base to the value of this field. If set to 15, this column address bit is set to 0.'''
  [[register.field]]
    name = "ADDRMAP_COL_B6"
    bits = "3:0"
    type = "rw"
    shortdesc = '''- Full bus width mode: Selects the HIF address bit used as column address bit 6.'''
    longdesc = '''- Half bus width mode: Selects the HIF address bit used as column address bit 7. Valid Range: 0 to 7, and 15 Internal Base: 6 The selected HIF address bit is determined by adding the internal base to the value of this field. If set to 15, this column address bit is set to 0.'''
[[register]]
  name = "ADDRMAP4"
  type = "rw"
  width = 32
  description = "Address Map Register 4"
  default = "0x00000000"
  offset = "0x00000210"
  [[register.field]]
    name = "ADDRMAP_COL_B11"
    bits = "11:8"
    type = "rw"
    shortdesc = '''- Full bus width mode: Selects the HIF address bit used as column address bit 13 (11 in LPDDR3 mode).'''
    longdesc = '''- Half bus width mode: Unused. To make it unused, this should be tied to 4'hF. Valid Range: 0 to 7, and 15 Internal Base: 11 The selected HIF address bit is determined by adding the internal base to the value of this field. If set to 15, this column address bit is set to 0. Note: Per JEDEC DDR3 specification, column address bit 10 is reserved for indicating auto-precharge, and hence no source address bit can be mapped to column address bit 10. In LPDDR3, there is a dedicated bit for auto-precharge in the CA bus and hence column bit 10 is used.'''
  [[register.field]]
    name = "ADDRMAP_COL_B10"
    bits = "3:0"
    type = "rw"
    shortdesc = '''- Full bus width mode: Selects the HIF address bit used as column address bit 11 (10 in LPDDR3 mode).'''
    longdesc = '''- Half bus width mode: Selects the HIF address bit used as column address bit 13 (11 in LPDDR3 mode). Valid Range: 0 to 7, and 15 Internal Base: 10 The selected HIF address bit is determined by adding the internal base to the value of this field. If set to 15, this column address bit is set to 0. Note: Per JEDEC DDR3 specification, column address bit 10 is reserved for indicating auto-precharge, and hence no source address bit can be mapped to column address bit 10. In LPDDR3, there is a dedicated bit for auto-precharge in the CA bus and hence column bit 10 is used.'''
[[register]]
  name = "ADDRMAP5"
  type = "rw"
  width = 32
  description = "Address Map Register 5"
  default = "0x00000000"
  offset = "0x00000214"
  [[register.field]]
    name = "ADDRMAP_ROW_B11"
    bits = "27:24"
    type = "rw"
    shortdesc = '''Selects the HIF address bit used as row address bit 11.'''
    longdesc = '''Valid Range: 0 to 11, and 15 Internal Base: 17 The selected HIF address bit is determined by adding the internal base to the value of this field. If set to 15, row address bit 11 is set to 0.'''
  [[register.field]]
    name = "ADDRMAP_ROW_B2_10"
    bits = "19:16"
    type = "rw"
    shortdesc = '''Selects the HIF address bits used as row address bits 2 to 10.'''
    longdesc = '''Valid Range: 0 to 11, and 15 Internal Base: 8 (for row address bit 2), 9 (for row address bit 3), 10 (for row address bit 4) etc increasing to 16 (for row address bit 10) The selected HIF address bit for each of the row address bits is determined by adding the internal base to the value of this field. When value 15 is used the values of row address bits 2 to 10 are defined by registers ADDRMAP9, ADDRMAP10, ADDRMAP11.'''
  [[register.field]]
    name = "ADDRMAP_ROW_B1"
    bits = "11:8"
    type = "rw"
    shortdesc = '''Selects the HIF address bits used as row address bit 1.'''
    longdesc = '''Valid Range: 0 to 11 Internal Base: 7 The selected HIF address bit for each of the row address bits is determined by adding the internal base to the value of this field.'''
  [[register.field]]
    name = "ADDRMAP_ROW_B0"
    bits = "3:0"
    type = "rw"
    shortdesc = '''Selects the HIF address bits used as row address bit 0.'''
    longdesc = '''Valid Range: 0 to 11 Internal Base: 6 The selected HIF address bit for each of the row address bits is determined by adding the internal base to the value of this field.'''
[[register]]
  name = "ADDRMAP6"
  type = "rw"
  width = 32
  description = "Address Map Register 6"
  default = "0x00000000"
  offset = "0x00000218"
  [[register.field]]
    name = "LPDDR3_6GB_12GB"
    bits = "31"
    type = "rw"
    shortdesc = '''Set this to 1 if there is an LPDDR3 SDRAM 6Gb or 12Gb device in use.'''
    longdesc = '''- 1 - LPDDR3 SDRAM 6Gb/12Gb device in use. Every address having row[14:13]==2'b11 is considered as invalid - 0 - non-LPDDR3 6Gb/12Gb device in use. All addresses are valid'''
  [[register.field]]
    name = "ADDRMAP_ROW_B15"
    bits = "27:24"
    type = "rw"
    shortdesc = '''Selects the HIF address bit used as row address bit 15.'''
    longdesc = '''Valid Range: 0 to 11, and 15 Internal Base: 21 The selected HIF address bit is determined by adding the internal base to the value of this field. If set to 15, row address bit 15 is set to 0.'''
  [[register.field]]
    name = "ADDRMAP_ROW_B14"
    bits = "19:16"
    type = "rw"
    shortdesc = '''Selects the HIF address bit used as row address bit 14.'''
    longdesc = '''Valid Range: 0 to 11, and 15 Internal Base: 20 The selected HIF address bit is determined by adding the internal base to the value of this field. If set to 15, row address bit 14 is set to 0.'''
  [[register.field]]
    name = "ADDRMAP_ROW_B13"
    bits = "11:8"
    type = "rw"
    shortdesc = '''Selects the HIF address bit used as row address bit 13.'''
    longdesc = '''Valid Range: 0 to 11, and 15 Internal Base: 19 The selected HIF address bit is determined by adding the internal base to the value of this field. If set to 15, row address bit 13 is set to 0.'''
  [[register.field]]
    name = "ADDRMAP_ROW_B12"
    bits = "3:0"
    type = "rw"
    shortdesc = '''Selects the HIF address bit used as row address bit 12.'''
    longdesc = '''Valid Range: 0 to 11, and 15 Internal Base: 18 The selected HIF address bit is determined by adding the internal base to the value of this field. If set to 15, row address bit 12 is set to 0.'''
[[register]]
  name = "ADDRMAP7"
  type = "rw"
  width = 32
  description = "Address Map Register 7"
  default = "0x00000000"
  offset = "0x0000021C"
  [[register.field]]
    name = "ADDRMAP_ROW_B17"
    bits = "11:8"
    type = "rw"
    shortdesc = '''Selects the HIF address bit used as row address bit 17.'''
    longdesc = '''Valid Range: 0 to 10, and 15 Internal Base: 23 The selected HIF address bit is determined by adding the internal base to the value of this field. If set to 15, row address bit 17 is set to 0.'''
  [[register.field]]
    name = "ADDRMAP_ROW_B16"
    bits = "3:0"
    type = "rw"
    shortdesc = '''Selects the HIF address bit used as row address bit 16.'''
    longdesc = '''Valid Range: 0 to 11, and 15 Internal Base: 22 The selected HIF address bit is determined by adding the internal base to the value of this field. If set to 15, row address bit 16 is set to 0.'''
[[register]]
  name = "ADDRMAP8"
  type = "rw"
  width = 32
  description = "Address Map Register 8"
  default = "0x00000000"
  offset = "0x00000220"
  [[register.field]]
    name = "ADDRMAP_BG_B1"
    bits = "12:8"
    type = "rw"
    shortdesc = '''Selects the HIF address bits used as bank group address bit 1.'''
    longdesc = '''Valid Range: 0 to 30, and 31 Internal Base: 3 The selected HIF address bit for each of the bank group address bits is determined by adding the internal base to the value of this field. If set to 31, bank group address bit 1 is set to 0.'''
  [[register.field]]
    name = "ADDRMAP_BG_B0"
    bits = "4:0"
    type = "rw"
    shortdesc = '''Selects the HIF address bits used as bank group address bit 0.'''
    longdesc = '''Valid Range: 0 to 30 Internal Base: 2 The selected HIF address bit for each of the bank group address bits is determined by adding the internal base to the value of this field.'''
[[register]]
  name = "ADDRMAP9"
  type = "rw"
  width = 32
  description = "Address Map Register 9"
  default = "0x00000000"
  offset = "0x00000224"
  [[register.field]]
    name = "ADDRMAP_ROW_B5"
    bits = "27:24"
    type = "rw"
    shortdesc = '''Selects the HIF address bits used as row address bit 5.'''
    longdesc = '''Valid Range: 0 to 11 Internal Base: 11 The selected HIF address bit for each of the row address bits is determined by adding the internal base to the value of this field. This register field is used only when ADDRMAP5.addrmap_row_b2_10 is set to value 15.'''
  [[register.field]]
    name = "ADDRMAP_ROW_B4"
    bits = "19:16"
    type = "rw"
    shortdesc = '''Selects the HIF address bits used as row address bit 4.'''
    longdesc = '''Valid Range: 0 to 11 Internal Base: 10 The selected HIF address bit for each of the row address bits is determined by adding the internal base to the value of this field. This register field is used only when ADDRMAP5.addrmap_row_b2_10 is set to value 15.'''
  [[register.field]]
    name = "ADDRMAP_ROW_B3"
    bits = "11:8"
    type = "rw"
    shortdesc = '''Selects the HIF address bits used as row address bit 3.'''
    longdesc = '''Valid Range: 0 to 11 Internal Base: 9 The selected HIF address bit for each of the row address bits is determined by adding the internal base to the value of this field. This register field is used only when ADDRMAP5.addrmap_row_b2_10 is set to value 15.'''
  [[register.field]]
    name = "ADDRMAP_ROW_B2"
    bits = "3:0"
    type = "rw"
    shortdesc = '''Selects the HIF address bits used as row address bit 2.'''
    longdesc = '''Valid Range: 0 to 11 Internal Base: 8 The selected HIF address bit for each of the row address bits is determined by adding the internal base to the value of this field. This register field is used only when ADDRMAP5.addrmap_row_b2_10 is set to value 15.'''
[[register]]
  name = "ADDRMAP10"
  type = "rw"
  width = 32
  description = "Address Map Register 10"
  default = "0x00000000"
  offset = "0x00000228"
  [[register.field]]
    name = "ADDRMAP_ROW_B9"
    bits = "27:24"
    type = "rw"
    shortdesc = '''Selects the HIF address bits used as row address bit 9.'''
    longdesc = '''Valid Range: 0 to 11 Internal Base: 15 The selected HIF address bit for each of the row address bits is determined by adding the internal base to the value of this field. This register field is used only when ADDRMAP5.addrmap_row_b2_10 is set to value 15.'''
  [[register.field]]
    name = "ADDRMAP_ROW_B8"
    bits = "19:16"
    type = "rw"
    shortdesc = '''Selects the HIF address bits used as row address bit 8.'''
    longdesc = '''Valid Range: 0 to 11 Internal Base: 14 The selected HIF address bit for each of the row address bits is determined by adding the internal base to the value of this field. This register field is used only when ADDRMAP5.addrmap_row_b2_10 is set to value 15.'''
  [[register.field]]
    name = "ADDRMAP_ROW_B7"
    bits = "11:8"
    type = "rw"
    shortdesc = '''Selects the HIF address bits used as row address bit 7.'''
    longdesc = '''Valid Range: 0 to 11 Internal Base: 13 The selected HIF address bit for each of the row address bits is determined by adding the internal base to the value of this field. This register field is used only when ADDRMAP5.addrmap_row_b2_10 is set to value 15.'''
  [[register.field]]
    name = "ADDRMAP_ROW_B6"
    bits = "3:0"
    type = "rw"
    shortdesc = '''Selects the HIF address bits used as row address bit 6.'''
    longdesc = '''Valid Range: 0 to 11 Internal Base: 12 The selected HIF address bit for each of the row address bits is determined by adding the internal base to the value of this field. This register field is used only when ADDRMAP5.addrmap_row_b2_10 is set to value 15.'''
[[register]]
  name = "ADDRMAP11"
  type = "rw"
  width = 32
  description = "Address Map Register 11"
  default = "0x00000000"
  offset = "0x0000022C"
  [[register.field]]
    name = "ADDRMAP_ROW_B10"
    bits = "3:0"
    type = "rw"
    shortdesc = '''Selects the HIF address bits used as row address bit 10.'''
    longdesc = '''Valid Range: 0 to 11 Internal Base: 16 The selected HIF address bit for each of the row address bits is determined by adding the internal base to the value of this field. This register field is used only when ADDRMAP5.addrmap_row_b2_10 is set to value 15.'''
[[register]]
  name = "ODTCFG"
  type = "rw"
  width = 32
  description = "ODT Configuration Register"
  default = "0x04000400"
  offset = "0x00000240"
  [[register.field]]
    name = "WR_ODT_HOLD"
    bits = "27:24"
    type = "rw"
    shortdesc = '''Cycles to hold ODT for a write command.'''
    longdesc = '''The minimum supported value is 2. Recommended values: DDR3: - BL8: 0x6 DDR4: - BL8: 5 + WR_PREAMBLE + CRC_MODE WR_PREAMBLE = 1 (1tCK write preamble), 2 (2tCK write preamble) CRC_MODE = 0 (not CRC mode), 1 (CRC mode) LPDDR3: - BL8: 7 + RU(tODTon(max)/tCK)'''
  [[register.field]]
    name = "WR_ODT_DELAY"
    bits = "20:16"
    type = "rw"
    shortdesc = '''The delay, in clock cycles, from issuing a write command to setting ODT values associated with that command.'''
    longdesc = '''ODT setting must remain constant for the entire time that DQS is driven by the DDRC. Recommended values: DDR3: - 0x0 DDR4: - DFITMG1.dfi_t_cmd_lat (to adjust for CAL mode) LPDDR3: - WL - 1 - RU(tODTon(max)/tCK))'''
  [[register.field]]
    name = "RD_ODT_HOLD"
    bits = "11:8"
    type = "rw"
    shortdesc = '''Cycles to hold ODT for a read command.'''
    longdesc = '''The minimum supported value is 2. Recommended values: DDR3: - BL8 - 0x6 DDR4: - BL8: 5 + RD_PREAMBLE RD_PREAMBLE = 1 (1tCK write preamble), 2 (2tCK write preamble) LPDDR3: - BL8: 5 + RU(tDQSCK(max)/tCK) - RD(tDQSCK(min)/tCK) + RU(tODTon(max)/tCK)'''
  [[register.field]]
    name = "RD_ODT_DELAY"
    bits = "6:2"
    type = "rw"
    shortdesc = '''The delay, in clock cycles, from issuing a read command to setting ODT values associated with that command.'''
    longdesc = '''ODT setting must remain constant for the entire time that DQS is driven by the DDRC. Recommended values: DDR3: - CL - CWL DDR4: - CL - CWL - RD_PREAMBLE + WR_PREAMBLE + DFITMG1.dfi_t_cmd_lat (to adjust for CAL mode) WR_PREAMBLE = 1 (1tCK write preamble), 2 (2tCK write preamble) RD_PREAMBLE = 1 (1tCK write preamble), 2 (2tCK write preamble) If (CL - CWL - RD_PREAMBLE + WR_PREAMBLE) < 0, DDRC does not support ODT for read operation. LPDDR3: - RL + RD(tDQSCK(min)/tCK) - 1 - RU(tODTon(max)/tCK)'''
[[register]]
  name = "ODTMAP"
  type = "rw"
  width = 32
  description = "ODT/Rank Map Register"
  default = "0x00002211"
  offset = "0x00000244"
  [[register.field]]
    name = "RANK1_RD_ODT"
    bits = "13:12"
    type = "rw"
    shortdesc = '''Indicates which remote ODTs must be turned on during a read from rank 1.'''
    longdesc = '''Each rank has a remote ODT (in the SDRAM) which can be turned on by setting the appropriate bit here. Rank 0 is controlled by the LSB; rank 1 is controlled by bit next to the LSB, etc. For each rank, set its bit to 1 to enable its ODT.'''
  [[register.field]]
    name = "RANK1_WR_ODT"
    bits = "9:8"
    type = "rw"
    shortdesc = '''Indicates which remote ODTs must be turned on during a write to rank 1.'''
    longdesc = '''Each rank has a remote ODT (in the SDRAM) which can be turned on by setting the appropriate bit here. Rank 0 is controlled by the LSB; rank 1 is controlled by bit next to the LSB, etc. For each rank, set its bit to 1 to enable its ODT.'''
  [[register.field]]
    name = "RANK0_RD_ODT"
    bits = "5:4"
    type = "rw"
    shortdesc = '''Indicates which remote ODTs must be turned on during a read from rank 0.'''
    longdesc = '''Each rank has a remote ODT (in the SDRAM) which can be turned on by setting the appropriate bit here. Rank 0 is controlled by the LSB; rank 1 is controlled by bit next to the LSB, etc. For each rank, set its bit to 1 to enable its ODT.'''
  [[register.field]]
    name = "RANK0_WR_ODT"
    bits = "1:0"
    type = "rw"
    shortdesc = '''Indicates which remote ODTs must be turned on during a write to rank 0.'''
    longdesc = '''Each rank has a remote ODT (in the SDRAM) which can be turned on by setting the appropriate bit here. Rank 0 is controlled by the LSB; rank 1 is controlled by bit next to the LSB, etc. For each rank, set its bit to 1 to enable its ODT.'''
[[register]]
  name = "SCHED"
  type = "rw"
  width = 32
  description = "Scheduler Control Register"
  default = "0x00002005"
  offset = "0x00000250"
  [[register.field]]
    name = "RDWR_IDLE_GAP"
    bits = "30:24"
    type = "rw"
    shortdesc = '''When the preferred transaction store is empty for these many clock cycles, switch to the alternate transaction store if it is non-empty.'''
    longdesc = '''The read transaction store (both high and low priority) is the default preferred transaction store and the write transaction store is the alternative store. When prefer write over read is set this is reversed. 0x0 is a legal value for this register. When set to 0x0, the transaction store switching will happen immediately when the switching conditions become true. FOR PERFORMANCE ONLY'''
  [[register.field]]
    name = "GO2CRITICAL_HYSTERESIS"
    bits = "23:16"
    type = "rw"
  [[register.field]]
    name = "LPR_NUM_ENTRIES"
    bits = "13:8"
    type = "rw"
    shortdesc = '''Number of entries in the low priority transaction store is this value + 1.'''
    longdesc = '''(64 - (SCHED.lpr_num_entries + 1)) is the number of entries available for the high priority transaction store. Setting this to maximum value allocates all entries to low priority transaction store. Setting this to 0 allocates 1 entry to low priority transaction store and the rest to high priority transaction store. Note: In ECC configurations, the numbers of write and low priority read credits issued is one less than in the non-ECC case. One entry each is reserved in the write and low-priority read CAMs for storing the RMW requests arising out of single bit error correction RMW operation.'''
  [[register.field]]
    name = "PAGECLOSE"
    bits = "2"
    type = "rw"
    shortdesc = '''If true, bank is kept open only while there are page hit transactions available in the CAM to that bank.'''
    longdesc = '''The last read or write command in the CAM with a bank and page hit will be executed with auto-precharge if SCHED1.pageclose_timer=0. Even if this register set to 1 and SCHED1.pageclose_timer is set to 0, explicit precharge (and not auto-precharge) may be issued in some cases where there is a mode switch between Write and Read or between LPR and HPR. The Read and Write commands that are executed as part of the ECC scrub requests are also executed without auto-precharge. If false, the bank remains open until there is a need to close it (to open a different page, or for page timeout or refresh timeout) - also known as open page policy. The open page policy can be overridden by setting the per-command-autopre bit on the HIF interface (hif_cmd_autopre). The pageclose feature provides a midway between Open and Close page policies. FOR PERFORMANCE ONLY. Programming Mode: Quasi-dynamic Group 3'''
  [[register.field]]
    name = "PREFER_WRITE"
    bits = "1"
    type = "rw"
    shortdesc = '''If set then the bank selector prefers writes over reads.'''
    longdesc = '''FOR DEBUG ONLY.'''
  [[register.field]]
    name = "FORCE_LOW_PRI_N"
    bits = "0"
    type = "rw"
    shortdesc = '''Active low signal.'''
    longdesc = '''When asserted ('0'), all incoming transactions are forced to low priority. This implies that all High Priority Read (HPR) and Variable Priority Read commands (VPR) will be treated as Low Priority Read (LPR) commands. On the write side, all Variable Priority Write (VPW) commands will be treated as Normal Priority Write (NPW) commands. Forcing the incoming transactions to low priority implicitly turns off Bypass path for read commands. FOR PERFORMANCE ONLY.'''
[[register]]
  name = "SCHED1"
  type = "rw"
  width = 32
  description = "Scheduler Control Register 1"
  default = "0x00000000"
  offset = "0x00000254"
  [[register.field]]
    name = "PAGECLOSE_TIMER"
    bits = "7:0"
    type = "rw"
    shortdesc = '''This field works in conjunction with SCHED.'''
    longdesc = '''pageclose. It only has meaning if SCHED.pageclose==1. If SCHED.pageclose==1 and pageclose_timer==0, then an auto-precharge may be scheduled for last read or write command in the CAM with a bank and page hit. Note, sometimes an explicit precharge is scheduled instead of the auto-precharge. See SCHED.pageclose for details of when this may happen. If SCHED.pageclose==1 and pageclose_timer>0, then an auto-precharge is not scheduled for last read or write command in the CAM with a bank and page hit. Instead, a timer is started, with pageclose_timer as the initial value. There is a timer on a per bank basis. The timer decrements unless the next read or write in the CAM to a bank is a page hit. It gets reset to pageclose_timer value if the next read or write in the CAM to a bank is a page hit. Once the timer has reached zero, an explicit precharge will be attempted to be scheduled.'''
[[register]]
  name = "PERFHPR1"
  type = "rw"
  width = 32
  description = "High Priority Read CAM Register 1"
  default = "0x0F000001"
  offset = "0x0000025C"
  [[register.field]]
    name = "HPR_XACT_RUN_LENGTH"
    bits = "31:24"
    type = "rw"
    shortdesc = '''Number of transactions that are serviced once the HPR queue goes critical is the smaller of: - (a) This number - (b) Number of transactions available.'''
    longdesc = '''Unit: Transaction. FOR PERFORMANCE ONLY.'''
  [[register.field]]
    name = "HPR_MAX_STARVE"
    bits = "15:0"
    type = "rw"
    shortdesc = '''Number of clocks that the HPR queue can be starved before it goes critical.'''
    longdesc = '''The minimum valid functional value for this register is 0x1. Programming it to 0x0 will disable the starvation functionality; during normal operation, this function should not be disabled as it will cause excessive latencies. Unit: Clock cycles. FOR PERFORMANCE ONLY.'''
[[register]]
  name = "PERFLPR1"
  type = "rw"
  width = 32
  description = "Low Priority Read CAM Register 1"
  default = "0x0F00007F"
  offset = "0x00000264"
  [[register.field]]
    name = "LPR_XACT_RUN_LENGTH"
    bits = "31:24"
    type = "rw"
    shortdesc = '''Number of transactions that are serviced once the LPR queue goes critical is the smaller of: - (a) This number - (b) Number of transactions available.'''
    longdesc = '''Unit: Transaction. FOR PERFORMANCE ONLY.'''
  [[register.field]]
    name = "LPR_MAX_STARVE"
    bits = "15:0"
    type = "rw"
    shortdesc = '''Number of clocks that the LPR queue can be starved before it goes critical.'''
    longdesc = '''The minimum valid functional value for this register is 0x1. Programming it to 0x0 will disable the starvation functionality; during normal operation, this function should not be disabled as it will cause excessive latencies. Unit: Clock cycles. FOR PERFORMANCE ONLY.'''
[[register]]
  name = "PERFWR1"
  type = "rw"
  width = 32
  description = "Write CAM Register 1"
  default = "0x0F00007F"
  offset = "0x0000026C"
  [[register.field]]
    name = "W_XACT_RUN_LENGTH"
    bits = "31:24"
    type = "rw"
    shortdesc = '''Number of transactions that are serviced once the WR queue goes critical is the smaller of: - (a) This number - (b) Number of transactions available.'''
    longdesc = '''Unit: Transaction. FOR PERFORMANCE ONLY.'''
  [[register.field]]
    name = "W_MAX_STARVE"
    bits = "15:0"
    type = "rw"
    shortdesc = '''Number of clocks that the WR queue can be starved before it goes critical.'''
    longdesc = '''The minimum valid functional value for this register is 0x1. Programming it to 0x0 will disable the starvation functionality; during normal operation, this function should not be disabled as it will cause excessive latencies. Unit: Clock cycles. FOR PERFORMANCE ONLY.'''
[[register]]
  name = "PERFVPR1"
  type = "rw"
  width = 32
  description = "Variable Priority Read CAM Register 1"
  default = "0x00000000"
  offset = "0x00000274"
  [[register.field]]
    name = "VPR_TIMEOUT_RANGE"
    bits = "10:0"
    type = "rw"
    shortdesc = '''Indicates the range of the timeout value that is used for grouping the expired VPR commands in the CAM in DDRC.'''
    longdesc = '''For example, if the register value is set to 0xF, then the priorities of all the VPR commands whose timeout counters are 15 or below will be considered as expired-VPR commands when the timeout value of any of the VPR commands reach 0. The expired-VPR commands, when present, are given higher priority than HPR commands. The VPR commands are expected to consist of largely page hit traffic and by grouping them together the bus utilization is expected to increase. This register applies to transactions inside the DDRC only. The Max value for this register is 0x7FF and the Min value is 0x0. When programmed to the Max value of 0x7FF, all the VPR commands that come in to DDRC will time-out right-away and will be considered as expired-VPR. When programmed to the Min value of 0x0, the timer of each command would have to reach a value of 0 before it will be considered as expired-VPR. Unit: Clock cycles. FOR PERFORMANCE ONLY.'''
[[register]]
  name = "PERFVPW1"
  type = "rw"
  width = 32
  description = "Variable Priority Write CAM Register 1"
  default = "0x00000000"
  offset = "0x00000278"
  [[register.field]]
    name = "VPW_TIMEOUT_RANGE"
    bits = "10:0"
    type = "rw"
    shortdesc = '''Indicates the range of the timeout value that is used for grouping the expired VPW commands in the CAM in DDRC.'''
    longdesc = '''For example, if the register value is set to 0xF, then the priorities of all the VPW commands whose timeout counters are 15 or below will be considered as expired-VPW commands when the timeout value of any of the VPW commands reach 0. The expired-VPW commands, when present, are given higher priority than normal Write commands. The VPW commands are expected to consist of largely page hit traffic and by grouping them together the bus utilization is expected to increase. This register applies to transactions inside the DDRC only. The Max value for this register is 0x7FF and the Min value is 0x0. When programmed to the Max value of 0x7FF, all the VPW commands that come in to DDRC will time-out right-away and will be considered as expired-VPW. When programmed to the Min value of 0x0, the timer of each command would have to reach a value of 0 before it will be considered as expired-VPW. Unit: Clock cycles. FOR PERFORMANCE ONLY.'''
[[register]]
  name = "DQMAP0"
  type = "rw"
  width = 32
  description = "DQ Map Register 0"
  default = "0x00000000"
  offset = "0x00000280"
  [[register.field]]
    name = "DQ_NIBBLE_MAP_12_15"
    bits = "31:24"
    type = "rw"
  [[register.field]]
    name = "DQ_NIBBLE_MAP_8_11"
    bits = "23:16"
    type = "rw"
  [[register.field]]
    name = "DQ_NIBBLE_MAP_4_7"
    bits = "15:8"
    type = "rw"
  [[register.field]]
    name = "DQ_NIBBLE_MAP_0_3"
    bits = "7:0"
    type = "rw"
[[register]]
  name = "DQMAP1"
  type = "rw"
  width = 32
  description = "DQ Map Register 1"
  default = "0x00000000"
  offset = "0x00000284"
  [[register.field]]
    name = "DQ_NIBBLE_MAP_28_31"
    bits = "31:24"
    type = "rw"
  [[register.field]]
    name = "DQ_NIBBLE_MAP_24_27"
    bits = "23:16"
    type = "rw"
  [[register.field]]
    name = "DQ_NIBBLE_MAP_20_23"
    bits = "15:8"
    type = "rw"
  [[register.field]]
    name = "DQ_NIBBLE_MAP_16_19"
    bits = "7:0"
    type = "rw"
[[register]]
  name = "DQMAP2"
  type = "rw"
  width = 32
  description = "DQ Map Register 2"
  default = "0x00000000"
  offset = "0x00000288"
  [[register.field]]
    name = "DQ_NIBBLE_MAP_44_47"
    bits = "31:24"
    type = "rw"
  [[register.field]]
    name = "DQ_NIBBLE_MAP_40_43"
    bits = "23:16"
    type = "rw"
  [[register.field]]
    name = "DQ_NIBBLE_MAP_36_39"
    bits = "15:8"
    type = "rw"
  [[register.field]]
    name = "DQ_NIBBLE_MAP_32_35"
    bits = "7:0"
    type = "rw"
[[register]]
  name = "DQMAP3"
  type = "rw"
  width = 32
  description = "DQ Map Register 3"
  default = "0x00000000"
  offset = "0x0000028C"
  [[register.field]]
    name = "DQ_NIBBLE_MAP_60_63"
    bits = "31:24"
    type = "rw"
  [[register.field]]
    name = "DQ_NIBBLE_MAP_56_59"
    bits = "23:16"
    type = "rw"
  [[register.field]]
    name = "DQ_NIBBLE_MAP_52_55"
    bits = "15:8"
    type = "rw"
  [[register.field]]
    name = "DQ_NIBBLE_MAP_48_51"
    bits = "7:0"
    type = "rw"
[[register]]
  name = "DQMAP4"
  type = "rw"
  width = 32
  description = "DQ Map Register 4"
  default = "0x00000000"
  offset = "0x00000290"
  [[register.field]]
    name = "DQ_NIBBLE_MAP_CB_4_7"
    bits = "15:8"
    type = "rw"
  [[register.field]]
    name = "DQ_NIBBLE_MAP_CB_0_3"
    bits = "7:0"
    type = "rw"
[[register]]
  name = "DQMAP5"
  type = "rw"
  width = 32
  description = "DQ Map Register 5"
  default = "0x00000000"
  offset = "0x00000294"
  [[register.field]]
    name = "DIS_DQ_RANK_SWAP"
    bits = "0"
    type = "rw"
    shortdesc = '''In DDR4 designs, all even ranks have the same DQ mapping controlled by DQMAP0-4 register as rank 0.'''
    longdesc = '''This register provides DQ swap function for all odd ranks to support CRC feature. rank based DQ swapping is: swap bit 0 with 1, swap bit 2 with 3, swap bit 4 with 5 and swap bit 6 with 7. 1: Disable rank based DQ swapping 0: Enable rank based DQ swapping'''
[[register]]
  name = "DBGCMD"
  type = "rw"
  width = 32
  description = "Command Debug Register"
  default = "0x00000000"
  offset = "0x0000030C"
  [[register.field]]
    name = "HW_REF_ZQ_EN"
    bits = "31"
    type = "rw"
    shortdesc = '''Setting this register bit to 1 allows refresh and ZQCS commands to be triggered from hardware via the IOs ext_*.'''
    longdesc = '''If set to 1, the fields DBGCMD.zq_calib_short and DBGCMD.rank*_refresh have no function, and are ignored by the DDRC logic. Setting this register bit to 0 allows refresh and ZQCS to be triggered from software, via the fields DBGCMD.zq_calib_short and DBGCMD.rank*_refresh. If set to 0, the hardware pins ext_* have no function, and are ignored by the DDRC logic. This register is static, and may only be changed when the DDRC reset signal, core_ddrc_rstn, is asserted (0).'''
  [[register.field]]
    name = "CTRLUPD"
    bits = "5"
    type = "rw"
    shortdesc = '''Setting this register bit to 1 indicates to the DDRC to issue a dfi_ctrlupd_req to the PHY.'''
    longdesc = '''When this request is stored in the DDRC, the bit is automatically cleared. This operation must only be performed when DFIUPD0.dis_auto_ctrlupd=1.'''
  [[register.field]]
    name = "ZQ_CALIB_SHORT"
    bits = "4"
    type = "rw"
    shortdesc = '''Setting this register bit to 1 indicates to the DDRC to issue a ZQCS (ZQ calibration short)/MPC(ZQ calibration) command to the SDRAM.'''
    longdesc = '''When this request is stored in the DDRC, the bit is automatically cleared. This operation can be performed only when ZQCTL0.dis_auto_zq=1. It is recommended NOT to set this register bit if in Init operating mode. This register bit is ignored when in Self-Refresh(except LPDDR4) and SR-Powerdown(LPDDR4) and Deep power-down operating modes and Maximum Power Saving Mode.'''
  [[register.field]]
    name = "RANK1_REFRESH"
    bits = "1"
    type = "rw"
    shortdesc = '''Setting this register bit to 1 indicates to the DDRC to issue a refresh to rank 1.'''
    longdesc = '''Writing to this bit causes DBGSTAT.rank1_refresh_busy to be set. When DBGSTAT.rank1_refresh_busy is cleared, the command has been stored in DDRC. This operation can be performed only when RFSHCTL3.dis_auto_refresh=1. It is recommended NOT to set this register bit if in Init or Deep power-down operating modes or Maximum Power Saving Mode.'''
  [[register.field]]
    name = "RANK0_REFRESH"
    bits = "0"
    type = "rw"
    shortdesc = '''Setting this register bit to 1 indicates to the DDRC to issue a refresh to rank 0.'''
    longdesc = '''Writing to this bit causes DBGSTAT.rank0_refresh_busy to be set. When DBGSTAT.rank0_refresh_busy is cleared, the command has been stored in DDRC. This operation can be performed only when RFSHCTL3.dis_auto_refresh=1. It is recommended NOT to set this register bit if in Init or Deep power-down operating modes or Maximum Power Saving Mode.'''
[[register]]
  name = "DBGSTAT"
  type = "ro"
  width = 32
  description = "Status Debug Register"
  default = "0x00000000"
  offset = "0x00000310"
  [[register.field]]
    name = "CTRLUPD_BUSY"
    bits = "5"
    type = "ro"
    shortdesc = '''SoC core may initiate a ctrlupd operation only if this signal is low.'''
    longdesc = '''This signal goes high in the clock after the DDRC accepts the ctrlupd request. It goes low when the ctrlupd operation is initiated in the DDRC. It is recommended not to perform ctrlupd operations when this signal is high. - 0 - Indicates that the SoC core can initiate a ctrlupd operation - 1 - Indicates that ctrlupd operation has not been initiated yet in the DDRC'''
  [[register.field]]
    name = "ZQ_CALIB_SHORT_BUSY"
    bits = "4"
    type = "ro"
    shortdesc = '''SoC core may initiate a ZQCS (ZQ calibration short) operation only if this signal is low.'''
    longdesc = '''This signal goes high in the clock after the DDRC accepts the ZQCS request. It goes low when the ZQCS operation is initiated in the DDRC. It is recommended not to perform ZQCS operations when this signal is high. - 0 - Indicates that the SoC core can initiate a ZQCS operation - 1 - Indicates that ZQCS operation has not been initiated yet in the DDRC'''
  [[register.field]]
    name = "RANK1_REFRESH_BUSY"
    bits = "1"
    type = "ro"
    shortdesc = '''SoC core may initiate a rank1_refresh operation (refresh operation to rank 1) only if this signal is low.'''
    longdesc = '''This signal goes high in the clock after DBGCMD.rank1_refresh is set to one. It goes low when the rank1_refresh operation is stored in the DDRC. It is recommended not to perform rank1_refresh operations when this signal is high. - 0 - Indicates that the SoC core can initiate a rank1_refresh operation - 1 - Indicates that rank1_refresh operation has not been stored yet in the DDRC'''
  [[register.field]]
    name = "RANK0_REFRESH_BUSY"
    bits = "0"
    type = "ro"
    shortdesc = '''SoC core may initiate a rank0_refresh operation (refresh operation to rank 0) only if this signal is low.'''
    longdesc = '''This signal goes high in the clock after DBGCMD.rank0_refresh is set to one. It goes low when the rank0_refresh operation is stored in the DDRC. It is recommended not to perform rank0_refresh operations when this signal is high. - 0 - Indicates that the SoC core can initiate a rank0_refresh operation - 1 - Indicates that rank0_refresh operation has not been stored yet in the DDRC'''
[[register]]
  name = "SWCTL"
  type = "rw"
  width = 32
  description = "Software register programming control enable"
  default = "0x00000001"
  offset = "0x00000320"
  [[register.field]]
    name = "SW_DONE"
    bits = "0"
    type = "rw"
    shortdesc = '''Enable quasi-dynamic register programming outside reset.'''
    longdesc = '''Program register to 0 to enable quasi-dynamic programming. Set back register to 1 once programming is done.'''
[[register]]
  name = "SWSTAT"
  type = "ro"
  width = 32
  description = "Software register programming control status"
  default = "0x00000000"
  offset = "0x00000324"
  [[register.field]]
    name = "SW_DONE_ACK"
    bits = "0"
    type = "ro"
    shortdesc = '''Register programming done.'''
    longdesc = '''This register is the echo of SWCTL.sw_done. Wait for sw_done value 1 to propagate to sw_done_ack at the end of the programming sequence to ensure that the correct registers values are propagated to the destination clock domains.'''
[[register]]
  name = "POISONCFG"
  type = "mixed"
  width = 32
  description = "AXI Poison Configuration Register"
  default = "0x00110011"
  offset = "0x0000036C"
  [[register.field]]
    name = "RD_POISON_INTR_CLR"
    bits = "24"
    type = "wtc"
    shortdesc = '''Interrupt clear for read transaction poisoning.'''
    longdesc = '''Allow 2/3 clock cycles for correct value to propagate to core logic and clear the interrupts.'''
  [[register.field]]
    name = "RD_POISON_INTR_EN"
    bits = "20"
    type = "rw"
  [[register.field]]
    name = "RD_POISON_SLVERR_EN"
    bits = "16"
    type = "rw"
  [[register.field]]
    name = "WR_POISON_INTR_CLR"
    bits = "8"
    type = "wtc"
    shortdesc = '''Interrupt clear for write transaction poisoning.'''
    longdesc = '''Allow 2/3 clock cycles for correct value to propagate to core logic and clear the interrupts.'''
  [[register.field]]
    name = "WR_POISON_INTR_EN"
    bits = "4"
    type = "rw"
  [[register.field]]
    name = "WR_POISON_SLVERR_EN"
    bits = "0"
    type = "rw"
[[register]]
  name = "POISONSTAT"
  type = "ro"
  width = 32
  description = "AXI Poison status register"
  default = "0x00000000"
  offset = "0x00000370"
  [[register.field]]
    name = "RD_POISON_INTR_5"
    bits = "21"
    type = "ro"
    shortdesc = '''Read transaction poisoning error interrupt on input for port 5.'''
    longdesc = '''This register is a APB clock copy (double register synchronizer) of the interrupt asserted when a transaction is poisoned on the corresponding AXI port's read address channel. Bit 0 corresponds to Port 0, and so on. Interrupt is cleared by register rd_poison_intr_clr, then value propagated to APB clock.'''
  [[register.field]]
    name = "RD_POISON_INTR_4"
    bits = "20"
    type = "ro"
    shortdesc = '''Read transaction poisoning error interrupt on input for port 4.'''
    longdesc = '''This register is a APB clock copy (double register synchronizer) of the interrupt asserted when a transaction is poisoned on the corresponding AXI port's read address channel. Bit 0 corresponds to Port 0, and so on. Interrupt is cleared by register rd_poison_intr_clr, then value propagated to APB clock.'''
  [[register.field]]
    name = "RD_POISON_INTR_3"
    bits = "19"
    type = "ro"
    shortdesc = '''Read transaction poisoning error interrupt on input for port 3.'''
    longdesc = '''This register is a APB clock copy (double register synchronizer) of the interrupt asserted when a transaction is poisoned on the corresponding AXI port's read address channel. Bit 0 corresponds to Port 0, and so on. Interrupt is cleared by register rd_poison_intr_clr, then value propagated to APB clock.'''
  [[register.field]]
    name = "RD_POISON_INTR_2"
    bits = "18"
    type = "ro"
    shortdesc = '''Read transaction poisoning error interrupt on input for port 2.'''
    longdesc = '''This register is a APB clock copy (double register synchronizer) of the interrupt asserted when a transaction is poisoned on the corresponding AXI port's read address channel. Bit 0 corresponds to Port 0, and so on. Interrupt is cleared by register rd_poison_intr_clr, then value propagated to APB clock.'''
  [[register.field]]
    name = "RD_POISON_INTR_1"
    bits = "17"
    type = "ro"
    shortdesc = '''Read transaction poisoning error interrupt on input for port 1.'''
    longdesc = '''This register is a APB clock copy (double register synchronizer) of the interrupt asserted when a transaction is poisoned on the corresponding AXI port's read address channel. Bit 0 corresponds to Port 0, and so on. Interrupt is cleared by register rd_poison_intr_clr, then value propagated to APB clock.'''
  [[register.field]]
    name = "RD_POISON_INTR_0"
    bits = "16"
    type = "ro"
    shortdesc = '''Read transaction poisoning error interrupt on input for port 0.'''
    longdesc = '''This register is a APB clock copy (double register synchronizer) of the interrupt asserted when a transaction is poisoned on the corresponding AXI port's read address channel. Bit 0 corresponds to Port 0, and so on. Interrupt is cleared by register rd_poison_intr_clr, then value propagated to APB clock.'''
  [[register.field]]
    name = "WR_POISON_INTR_5"
    bits = "5"
    type = "ro"
    shortdesc = '''Write transaction poisoning error interrupt on input for port 5.'''
    longdesc = '''This register is a APB clock copy (double register synchronizer) of the interrupt asserted when a transaction is poisoned on the corresponding AXI port's write address channel. Bit 0 corresponds to Port 0, and so on. Interrupt is cleared by register wr_poison_intr_clr, then value propagated to APB clock.'''
  [[register.field]]
    name = "WR_POISON_INTR_4"
    bits = "4"
    type = "ro"
    shortdesc = '''Write transaction poisoning error interrupt on input for port 4.'''
    longdesc = '''This register is a APB clock copy (double register synchronizer) of the interrupt asserted when a transaction is poisoned on the corresponding AXI port's write address channel. Bit 0 corresponds to Port 0, and so on. Interrupt is cleared by register wr_poison_intr_clr, then value propagated to APB clock.'''
  [[register.field]]
    name = "WR_POISON_INTR_3"
    bits = "3"
    type = "ro"
    shortdesc = '''Write transaction poisoning error interrupt on input for port 3.'''
    longdesc = '''This register is a APB clock copy (double register synchronizer) of the interrupt asserted when a transaction is poisoned on the corresponding AXI port's write address channel. Bit 0 corresponds to Port 0, and so on. Interrupt is cleared by register wr_poison_intr_clr, then value propagated to APB clock.'''
  [[register.field]]
    name = "WR_POISON_INTR_2"
    bits = "2"
    type = "ro"
    shortdesc = '''Write transaction poisoning error interrupt on input for port 2.'''
    longdesc = '''This register is a APB clock copy (double register synchronizer) of the interrupt asserted when a transaction is poisoned on the corresponding AXI port's write address channel. Bit 0 corresponds to Port 0, and so on. Interrupt is cleared by register wr_poison_intr_clr, then value propagated to APB clock.'''
  [[register.field]]
    name = "WR_POISON_INTR_1"
    bits = "1"
    type = "ro"
    shortdesc = '''Write transaction poisoning error interrupt on input for port 1.'''
    longdesc = '''This register is a APB clock copy (double register synchronizer) of the interrupt asserted when a transaction is poisoned on the corresponding AXI port's write address channel. Bit 0 corresponds to Port 0, and so on. Interrupt is cleared by register wr_poison_intr_clr, then value propagated to APB clock.'''
  [[register.field]]
    name = "WR_POISON_INTR_0"
    bits = "0"
    type = "ro"
    shortdesc = '''Write transaction poisoning error interrupt on input for port 0.'''
    longdesc = '''This register is a APB clock copy (double register synchronizer) of the interrupt asserted when a transaction is poisoned on the corresponding AXI port's write address channel. Bit 0 corresponds to Port 0, and so on. Interrupt is cleared by register wr_poison_intr_clr, then value propagated to APB clock.'''
[[register]]
  name = "PSTAT"
  type = "ro"
  width = 32
  description = "Port Status Register"
  default = "0x00000000"
  offset = "0x000003FC"
  [[register.field]]
    name = "WR_PORT_BUSY_5"
    bits = "21"
    type = "ro"
  [[register.field]]
    name = "WR_PORT_BUSY_4"
    bits = "20"
    type = "ro"
  [[register.field]]
    name = "WR_PORT_BUSY_3"
    bits = "19"
    type = "ro"
  [[register.field]]
    name = "WR_PORT_BUSY_2"
    bits = "18"
    type = "ro"
  [[register.field]]
    name = "WR_PORT_BUSY_1"
    bits = "17"
    type = "ro"
  [[register.field]]
    name = "WR_PORT_BUSY_0"
    bits = "16"
    type = "ro"
  [[register.field]]
    name = "RD_PORT_BUSY_5"
    bits = "5"
    type = "ro"
  [[register.field]]
    name = "RD_PORT_BUSY_4"
    bits = "4"
    type = "ro"
  [[register.field]]
    name = "RD_PORT_BUSY_3"
    bits = "3"
    type = "ro"
  [[register.field]]
    name = "RD_PORT_BUSY_2"
    bits = "2"
    type = "ro"
  [[register.field]]
    name = "RD_PORT_BUSY_1"
    bits = "1"
    type = "ro"
  [[register.field]]
    name = "RD_PORT_BUSY_0"
    bits = "0"
    type = "ro"
[[register]]
  name = "PCCFG"
  type = "rw"
  width = 32
  description = "Port Common Configuration Register"
  default = "0x00000000"
  offset = "0x00000400"
  [[register.field]]
    name = "BL_EXP_MODE"
    bits = "8"
    type = "rw"
    shortdesc = '''Burst length expansion mode.'''
    longdesc = '''By default (i.e. bl_exp_mode==0) XPI expands every AXI burst into multiple HIF commands, using the memory burst length as a unit. If set to 1, then XPI will use half of the memory burst length as a unit. This applies to both reads and writes. When MSTR.data_bus_width==00, setting bl_exp_mode to 1 has no effect. This can be used in cases where Partial Writes is enabled and DBG0.dis_wc=1, in order to avoid or minimize t_ccd_l penalty in DDR4 and t_ccd_mw penalty in LPDDR4. Note that if DBICTL.reg_ddrc_dm_en=0, functionality is not supported in the following cases: - MSTR.reg_ddrc_data_bus_width=01 and MSTR.reg_ddrc_burst_rdwr=1000 (LPDDR4 only) Functionality is also not supported if Shared-AC is enabled'''
  [[register.field]]
    name = "PAGEMATCH_LIMIT"
    bits = "4"
    type = "rw"
    shortdesc = '''Page match four limit.'''
    longdesc = '''If set to 1, limits the number of consecutive same page DDRC transactions that can be granted by the Port Arbiter to four when Page Match feature is enabled. If set to 0, there is no limit imposed on number of consecutive same page DDRC transactions.'''
  [[register.field]]
    name = "GO2CRITICAL_EN"
    bits = "0"
    type = "rw"
    shortdesc = '''If set to 1 (enabled), sets co_gs_go2critical_wr and co_gs_go2critical_lpr/co_gs_go2critical_hpr signals going to DDRC based on urgent input (awurgent, arurgent) coming from AXI master.'''
    longdesc = '''If set to 0 (disabled), co_gs_go2critical_wr and co_gs_go2critical_lpr/co_gs_go2critical_hpr signals at DDRC are driven to 1b'0.'''
[[register]]
  name = "PCFGR_0"
  type = "rw"
  width = 32
  description = "Port 0 Configuration Read Register"
  default = "0x00000000"
  offset = "0x00000404"
  [[register.field]]
    name = "RD_PORT_PAGEMATCH_EN"
    bits = "14"
    type = "rw"
    shortdesc = '''If set to 1, enables the Page Match feature.'''
    longdesc = '''If enabled, once a requesting port is granted, the port is continued to be granted if the following immediate commands are to the same memory page (same bank and same row). See also related PCCFG.pagematch_limit register.'''
  [[register.field]]
    name = "RD_PORT_URGENT_EN"
    bits = "13"
    type = "rw"
    shortdesc = '''If set to 1, enables the AXI urgent sideband signal (arurgent).'''
    longdesc = '''When enabled and arurgent is asserted by the master, that port becomes the highest priority and co_gs_go2critical_lpr/co_gs_go2critical_hpr signal to DDRC is asserted if enabled in PCCFG.go2critical_en register. Note that arurgent signal can be asserted anytime and as long as required which is independent of address handshaking (it is not associated with any particular command).'''
  [[register.field]]
    name = "RD_PORT_AGING_EN"
    bits = "12"
    type = "rw"
  [[register.field]]
    name = "RD_PORT_PRIORITY"
    bits = "9:0"
    type = "rw"
    shortdesc = '''Determines the initial load value of read aging counters.'''
    longdesc = '''These counters will be parallel loaded after reset, or after each grant to the corresponding port. The aging counters down-count every clock cycle where the port is requesting but not granted. The higher significant 5-bits of the read aging counter sets the priority of the read channel of a given port. Port's priority will increase as the higher significant 5-bits of the counter starts to decrease. When the aging counter becomes 0, the corresponding port channel will have the highest priority level (timeout condition - Priority0). For multi-port configurations, the aging counters cannot be used to set port priorities when external dynamic priority inputs (arqos) are enabled (timeout is still applicable). For single-port configurations, the aging counters are only used when they timeout (become 0) to force read-write direction switching. In this case, external dynamic priority input, arqos (for reads only) can still be used to set the DDRC read priority (2 priority levels: low priority read - LPR, high priority read - HPR) on a command by command basis. Note: The two LSBs of this register field are tied internally to 2'b00.'''
[[register]]
  name = "PCFGW_0"
  type = "rw"
  width = 32
  description = "Port 0 Configuration Write Register"
  default = "0x00004000"
  offset = "0x00000408"
  [[register.field]]
    name = "WR_PORT_PAGEMATCH_EN"
    bits = "14"
    type = "rw"
    shortdesc = '''If set to 1, enables the Page Match feature.'''
    longdesc = '''If enabled, once a requesting port is granted, the port is continued to be granted if the following immediate commands are to the same memory page (same bank and same row). See also related PCCFG.pagematch_limit register.'''
  [[register.field]]
    name = "WR_PORT_URGENT_EN"
    bits = "13"
    type = "rw"
    shortdesc = '''If set to 1, enables the AXI urgent sideband signal (awurgent).'''
    longdesc = '''When enabled and awurgent is asserted by the master, that port becomes the highest priority and co_gs_go2critical_wr signal to DDRC is asserted if enabled in PCCFG.go2critical_en register. Note that awurgent signal can be asserted anytime and as long as required which is independent of address handshaking (it is not associated with any particular command).'''
  [[register.field]]
    name = "WR_PORT_AGING_EN"
    bits = "12"
    type = "rw"
  [[register.field]]
    name = "WR_PORT_PRIORITY"
    bits = "9:0"
    type = "rw"
    shortdesc = '''Determines the initial load value of write aging counters.'''
    longdesc = '''These counters will be parallel loaded after reset, or after each grant to the corresponding port. The aging counters down-count every clock cycle where the port is requesting but not granted. The higher significant 5-bits of the write aging counter sets the initial priority of the write channel of a given port. Port's priority will increase as the higher significant 5-bits of the counter starts to decrease. When the aging counter becomes 0, the corresponding port channel will have the highest priority level. For multi-port configurations, the aging counters cannot be used to set port priorities when external dynamic priority inputs (awqos) are enabled (timeout is still applicable). For single-port configurations, the aging counters are only used when they timeout (become 0) to force read-write direction switching. Note: The two LSBs of this register field are tied internally to 2'b00.'''
[[register]]
  name = "PCTRL_0"
  type = "rw"
  width = 32
  description = "Port 0 Control Register"
  default = "0x00000000"
  offset = "0x00000490"
  [[register.field]]
    name = "PORT_EN"
    bits = "0"
    type = "rw"
[[register]]
  name = "PCFGQOS0_0"
  type = "rw"
  width = 32
  description = "Port 0 Read QoS Configuration Register 0"
  default = "0x00000000"
  offset = "0x00000494"
  [[register.field]]
    name = "RQOS_MAP_REGION1"
    bits = "21:20"
    type = "rw"
    shortdesc = '''This bitfield indicates the traffic class of region 1.'''
    longdesc = '''Valid values are: 0: LPR, 1: VPR, 2: HPR. For dual address queue configurations, region1 maps to the blue address queue. In this case, valid values are 0: LPR and 1: VPR only.'''
  [[register.field]]
    name = "RQOS_MAP_REGION0"
    bits = "17:16"
    type = "rw"
    shortdesc = '''This bitfield indicates the traffic class of region 0.'''
    longdesc = '''Valid values are: 0: LPR, 1: VPR, 2: HPR. For dual address queue configurations, region 0 maps to the blue address queue. In this case, valid values are: 0: LPR and 1: VPR only.'''
  [[register.field]]
    name = "RQOS_MAP_LEVEL1"
    bits = "3:0"
    type = "rw"
    shortdesc = '''Separation level1 indicating the end of region0 mapping; start of region0 is 0.'''
    longdesc = '''Possible values for level1 are 0 to 13 (for dual RAQ) or 0 to 14 (for single RAQ) which corresponds to arqos. Note that for PA, arqos values are used directly as port priorities, where the higher the value corresponds to higher port priority. All of the map_level* registers must be set to distinct values.'''
[[register]]
  name = "PCFGQOS1_0"
  type = "rw"
  width = 32
  description = "Port 0 Read QoS Configuration Register 1"
  default = "0x00000000"
  offset = "0x00000498"
  [[register.field]]
    name = "RQOS_MAP_TIMEOUTR"
    bits = "26:16"
    type = "rw"
  [[register.field]]
    name = "RQOS_MAP_TIMEOUTB"
    bits = "10:0"
    type = "rw"
[[register]]
  name = "PCFGWQOS0_0"
  type = "rw"
  width = 32
  description = "Port 0 Write QoS Configuration Register 0"
  default = "0x00000000"
  offset = "0x0000049C"
  [[register.field]]
    name = "WQOS_MAP_REGION1"
    bits = "21:20"
    type = "rw"
    shortdesc = '''This bitfield indicates the traffic class of region 1.'''
    longdesc = '''Valid values are: 0: NPW, 1: VPW.'''
  [[register.field]]
    name = "WQOS_MAP_REGION0"
    bits = "17:16"
    type = "rw"
    shortdesc = '''This bitfield indicates the traffic class of region 0.'''
    longdesc = '''Valid values are: 0: NPW, 1: VPW.'''
  [[register.field]]
    name = "WQOS_MAP_LEVEL"
    bits = "3:0"
    type = "rw"
    shortdesc = '''Separation level indicating the end of region0 mapping; start of region0 is 0.'''
    longdesc = '''Possible values for level1 are 0 to 14 which corresponds to awqos. Note that for PA, awqos values are used directly as port priorities, where the higher the value corresponds to higher port priority.'''
[[register]]
  name = "PCFGWQOS1_0"
  type = "rw"
  width = 32
  description = "Port 0 Write QoS Configuration Register 1"
  default = "0x00000000"
  offset = "0x000004A0"
  [[register.field]]
    name = "WQOS_MAP_TIMEOUT"
    bits = "10:0"
    type = "rw"
[[register]]
  name = "PCFGR_1"
  type = "rw"
  width = 32
  description = "Port 1 Configuration Read Register"
  default = "0x00000000"
  offset = "0x000004B4"
  [[register.field]]
    name = "RD_PORT_PAGEMATCH_EN"
    bits = "14"
    type = "rw"
    shortdesc = '''If set to 1, enables the Page Match feature.'''
    longdesc = '''If enabled, once a requesting port is granted, the port is continued to be granted if the following immediate commands are to the same memory page (same bank and same row). See also related PCCFG.pagematch_limit register.'''
  [[register.field]]
    name = "RD_PORT_URGENT_EN"
    bits = "13"
    type = "rw"
    shortdesc = '''If set to 1, enables the AXI urgent sideband signal (arurgent).'''
    longdesc = '''When enabled and arurgent is asserted by the master, that port becomes the highest priority and co_gs_go2critical_lpr/co_gs_go2critical_hpr signal to DDRC is asserted if enabled in PCCFG.go2critical_en register. Note that arurgent signal can be asserted anytime and as long as required which is independent of address handshaking (it is not associated with any particular command).'''
  [[register.field]]
    name = "RD_PORT_AGING_EN"
    bits = "12"
    type = "rw"
  [[register.field]]
    name = "RD_PORT_PRIORITY"
    bits = "9:0"
    type = "rw"
    shortdesc = '''Determines the initial load value of read aging counters.'''
    longdesc = '''These counters will be parallel loaded after reset, or after each grant to the corresponding port. The aging counters down-count every clock cycle where the port is requesting but not granted. The higher significant 5-bits of the read aging counter sets the priority of the read channel of a given port. Port's priority will increase as the higher significant 5-bits of the counter starts to decrease. When the aging counter becomes 0, the corresponding port channel will have the highest priority level (timeout condition - Priority0). For multi-port configurations, the aging counters cannot be used to set port priorities when external dynamic priority inputs (arqos) are enabled (timeout is still applicable). For single-port configurations, the aging counters are only used when they timeout (become 0) to force read-write direction switching. In this case, external dynamic priority input, arqos (for reads only) can still be used to set the DDRC read priority (2 priority levels: low priority read - LPR, high priority read - HPR) on a command by command basis. Note: The two LSBs of this register field are tied internally to 2'b00.'''
[[register]]
  name = "PCFGW_1"
  type = "rw"
  width = 32
  description = "Port 1 Configuration Write Register"
  default = "0x00004000"
  offset = "0x000004B8"
  [[register.field]]
    name = "WR_PORT_PAGEMATCH_EN"
    bits = "14"
    type = "rw"
    shortdesc = '''If set to 1, enables the Page Match feature.'''
    longdesc = '''If enabled, once a requesting port is granted, the port is continued to be granted if the following immediate commands are to the same memory page (same bank and same row). See also related PCCFG.pagematch_limit register.'''
  [[register.field]]
    name = "WR_PORT_URGENT_EN"
    bits = "13"
    type = "rw"
    shortdesc = '''If set to 1, enables the AXI urgent sideband signal (awurgent).'''
    longdesc = '''When enabled and awurgent is asserted by the master, that port becomes the highest priority and co_gs_go2critical_wr signal to DDRC is asserted if enabled in PCCFG.go2critical_en register. Note that awurgent signal can be asserted anytime and as long as required which is independent of address handshaking (it is not associated with any particular command).'''
  [[register.field]]
    name = "WR_PORT_AGING_EN"
    bits = "12"
    type = "rw"
  [[register.field]]
    name = "WR_PORT_PRIORITY"
    bits = "9:0"
    type = "rw"
    shortdesc = '''Determines the initial load value of write aging counters.'''
    longdesc = '''These counters will be parallel loaded after reset, or after each grant to the corresponding port. The aging counters down-count every clock cycle where the port is requesting but not granted. The higher significant 5-bits of the write aging counter sets the initial priority of the write channel of a given port. Port's priority will increase as the higher significant 5-bits of the counter starts to decrease. When the aging counter becomes 0, the corresponding port channel will have the highest priority level. For multi-port configurations, the aging counters cannot be used to set port priorities when external dynamic priority inputs (awqos) are enabled (timeout is still applicable). For single-port configurations, the aging counters are only used when they timeout (become 0) to force read-write direction switching. Note: The two LSBs of this register field are tied internally to 2'b00.'''
[[register]]
  name = "PCTRL_1"
  type = "rw"
  width = 32
  description = "Port 1 Control Register"
  default = "0x00000000"
  offset = "0x00000540"
  [[register.field]]
    name = "PORT_EN"
    bits = "0"
    type = "rw"
[[register]]
  name = "PCFGQOS0_1"
  type = "rw"
  width = 32
  description = "Port 1 Read QoS Configuration Register 0"
  default = "0x02000E00"
  offset = "0x00000544"
  [[register.field]]
    name = "RQOS_MAP_REGION2"
    bits = "25:24"
    type = "rw"
    shortdesc = '''This bitfield indicates the traffic class of region2.'''
    longdesc = '''For dual address queue configurations, region2 maps to the red address queue. Valid values are 1: VPR and 2: HPR only.'''
  [[register.field]]
    name = "RQOS_MAP_REGION1"
    bits = "21:20"
    type = "rw"
    shortdesc = '''This bitfield indicates the traffic class of region 1.'''
    longdesc = '''Valid values are: 0: LPR, 1: VPR, 2: HPR. For dual address queue configurations, region1 maps to the blue address queue. In this case, valid values are 0: LPR and 1: VPR only.'''
  [[register.field]]
    name = "RQOS_MAP_REGION0"
    bits = "17:16"
    type = "rw"
    shortdesc = '''This bitfield indicates the traffic class of region 0.'''
    longdesc = '''Valid values are: 0: LPR, 1: VPR, 2: HPR. For dual address queue configurations, region 0 maps to the blue address queue. In this case, valid values are: 0: LPR and 1: VPR only.'''
  [[register.field]]
    name = "RQOS_MAP_LEVEL2"
    bits = "11:8"
    type = "rw"
    shortdesc = '''Separation level2 indicating the end of region1 mapping; start of region1 is (level1 + 1).'''
    longdesc = '''Possible values for level2 are (level1 + 1) to 14 which corresponds to arqos. Region2 starts from (level2 + 1) up to 15. Note that for PA, arqos values are used directly as port priorities, where the higher the value corresponds to higher port priority. All of the map_level* registers must be set to distinct values.'''
  [[register.field]]
    name = "RQOS_MAP_LEVEL1"
    bits = "3:0"
    type = "rw"
    shortdesc = '''Separation level1 indicating the end of region0 mapping; start of region0 is 0.'''
    longdesc = '''Possible values for level1 are 0 to 13 (for dual RAQ) or 0 to 14 (for single RAQ) which corresponds to arqos. Note that for PA, arqos values are used directly as port priorities, where the higher the value corresponds to higher port priority. All of the map_level* registers must be set to distinct values.'''
[[register]]
  name = "PCFGQOS1_1"
  type = "rw"
  width = 32
  description = "Port 1 Read QoS Configuration Register 1"
  default = "0x00000000"
  offset = "0x00000548"
  [[register.field]]
    name = "RQOS_MAP_TIMEOUTR"
    bits = "26:16"
    type = "rw"
  [[register.field]]
    name = "RQOS_MAP_TIMEOUTB"
    bits = "10:0"
    type = "rw"
[[register]]
  name = "PCFGWQOS0_1"
  type = "rw"
  width = 32
  description = "Port 1 Write QoS Configuration Register 0"
  default = "0x00000000"
  offset = "0x0000054C"
  [[register.field]]
    name = "WQOS_MAP_REGION1"
    bits = "21:20"
    type = "rw"
    shortdesc = '''This bitfield indicates the traffic class of region 1.'''
    longdesc = '''Valid values are: 0: NPW, 1: VPW.'''
  [[register.field]]
    name = "WQOS_MAP_REGION0"
    bits = "17:16"
    type = "rw"
    shortdesc = '''This bitfield indicates the traffic class of region 0.'''
    longdesc = '''Valid values are: 0: NPW, 1: VPW.'''
  [[register.field]]
    name = "WQOS_MAP_LEVEL"
    bits = "3:0"
    type = "rw"
    shortdesc = '''Separation level indicating the end of region0 mapping; start of region0 is 0.'''
    longdesc = '''Possible values for level1 are 0 to 14 which corresponds to awqos. Note that for PA, awqos values are used directly as port priorities, where the higher the value corresponds to higher port priority.'''
[[register]]
  name = "PCFGWQOS1_1"
  type = "rw"
  width = 32
  description = "Port 1 Write QoS Configuration Register 1"
  default = "0x00000000"
  offset = "0x00000550"
  [[register.field]]
    name = "WQOS_MAP_TIMEOUT"
    bits = "10:0"
    type = "rw"
[[register]]
  name = "PCFGR_2"
  type = "rw"
  width = 32
  description = "Port 2 Configuration Read Register"
  default = "0x00000000"
  offset = "0x00000564"
  [[register.field]]
    name = "RD_PORT_PAGEMATCH_EN"
    bits = "14"
    type = "rw"
    shortdesc = '''If set to 1, enables the Page Match feature.'''
    longdesc = '''If enabled, once a requesting port is granted, the port is continued to be granted if the following immediate commands are to the same memory page (same bank and same row). See also related PCCFG.pagematch_limit register.'''
  [[register.field]]
    name = "RD_PORT_URGENT_EN"
    bits = "13"
    type = "rw"
    shortdesc = '''If set to 1, enables the AXI urgent sideband signal (arurgent).'''
    longdesc = '''When enabled and arurgent is asserted by the master, that port becomes the highest priority and co_gs_go2critical_lpr/co_gs_go2critical_hpr signal to DDRC is asserted if enabled in PCCFG.go2critical_en register. Note that arurgent signal can be asserted anytime and as long as required which is independent of address handshaking (it is not associated with any particular command).'''
  [[register.field]]
    name = "RD_PORT_AGING_EN"
    bits = "12"
    type = "rw"
  [[register.field]]
    name = "RD_PORT_PRIORITY"
    bits = "9:0"
    type = "rw"
    shortdesc = '''Determines the initial load value of read aging counters.'''
    longdesc = '''These counters will be parallel loaded after reset, or after each grant to the corresponding port. The aging counters down-count every clock cycle where the port is requesting but not granted. The higher significant 5-bits of the read aging counter sets the priority of the read channel of a given port. Port's priority will increase as the higher significant 5-bits of the counter starts to decrease. When the aging counter becomes 0, the corresponding port channel will have the highest priority level (timeout condition - Priority0). For multi-port configurations, the aging counters cannot be used to set port priorities when external dynamic priority inputs (arqos) are enabled (timeout is still applicable). For single-port configurations, the aging counters are only used when they timeout (become 0) to force read-write direction switching. In this case, external dynamic priority input, arqos (for reads only) can still be used to set the DDRC read priority (2 priority levels: low priority read - LPR, high priority read - HPR) on a command by command basis. Note: The two LSBs of this register field are tied internally to 2'b00.'''
[[register]]
  name = "PCFGW_2"
  type = "rw"
  width = 32
  description = "Port 2 Configuration Write Register"
  default = "0x00004000"
  offset = "0x00000568"
  [[register.field]]
    name = "WR_PORT_PAGEMATCH_EN"
    bits = "14"
    type = "rw"
    shortdesc = '''If set to 1, enables the Page Match feature.'''
    longdesc = '''If enabled, once a requesting port is granted, the port is continued to be granted if the following immediate commands are to the same memory page (same bank and same row). See also related PCCFG.pagematch_limit register.'''
  [[register.field]]
    name = "WR_PORT_URGENT_EN"
    bits = "13"
    type = "rw"
    shortdesc = '''If set to 1, enables the AXI urgent sideband signal (awurgent).'''
    longdesc = '''When enabled and awurgent is asserted by the master, that port becomes the highest priority and co_gs_go2critical_wr signal to DDRC is asserted if enabled in PCCFG.go2critical_en register. Note that awurgent signal can be asserted anytime and as long as required which is independent of address handshaking (it is not associated with any particular command).'''
  [[register.field]]
    name = "WR_PORT_AGING_EN"
    bits = "12"
    type = "rw"
  [[register.field]]
    name = "WR_PORT_PRIORITY"
    bits = "9:0"
    type = "rw"
    shortdesc = '''Determines the initial load value of write aging counters.'''
    longdesc = '''These counters will be parallel loaded after reset, or after each grant to the corresponding port. The aging counters down-count every clock cycle where the port is requesting but not granted. The higher significant 5-bits of the write aging counter sets the initial priority of the write channel of a given port. Port's priority will increase as the higher significant 5-bits of the counter starts to decrease. When the aging counter becomes 0, the corresponding port channel will have the highest priority level. For multi-port configurations, the aging counters cannot be used to set port priorities when external dynamic priority inputs (awqos) are enabled (timeout is still applicable). For single-port configurations, the aging counters are only used when they timeout (become 0) to force read-write direction switching. Note: The two LSBs of this register field are tied internally to 2'b00.'''
[[register]]
  name = "PCTRL_2"
  type = "rw"
  width = 32
  description = "Port 2 Control Register"
  default = "0x00000000"
  offset = "0x000005F0"
  [[register.field]]
    name = "PORT_EN"
    bits = "0"
    type = "rw"
[[register]]
  name = "PCFGQOS0_2"
  type = "rw"
  width = 32
  description = "Port 2 Read QoS Configuration Register 0"
  default = "0x02000E00"
  offset = "0x000005F4"
  [[register.field]]
    name = "RQOS_MAP_REGION2"
    bits = "25:24"
    type = "rw"
    shortdesc = '''This bitfield indicates the traffic class of region2.'''
    longdesc = '''For dual address queue configurations, region2 maps to the red address queue. Valid values are 1: VPR and 2: HPR only.'''
  [[register.field]]
    name = "RQOS_MAP_REGION1"
    bits = "21:20"
    type = "rw"
    shortdesc = '''This bitfield indicates the traffic class of region 1.'''
    longdesc = '''Valid values are: 0: LPR, 1: VPR, 2: HPR. For dual address queue configurations, region1 maps to the blue address queue. In this case, valid values are 0: LPR and 1: VPR only.'''
  [[register.field]]
    name = "RQOS_MAP_REGION0"
    bits = "17:16"
    type = "rw"
    shortdesc = '''This bitfield indicates the traffic class of region 0.'''
    longdesc = '''Valid values are: 0: LPR, 1: VPR, 2: HPR. For dual address queue configurations, region 0 maps to the blue address queue. In this case, valid values are: 0: LPR and 1: VPR only.'''
  [[register.field]]
    name = "RQOS_MAP_LEVEL2"
    bits = "11:8"
    type = "rw"
    shortdesc = '''Separation level2 indicating the end of region1 mapping; start of region1 is (level1 + 1).'''
    longdesc = '''Possible values for level2 are (level1 + 1) to 14 which corresponds to arqos. Region2 starts from (level2 + 1) up to 15. Note that for PA, arqos values are used directly as port priorities, where the higher the value corresponds to higher port priority. All of the map_level* registers must be set to distinct values.'''
  [[register.field]]
    name = "RQOS_MAP_LEVEL1"
    bits = "3:0"
    type = "rw"
    shortdesc = '''Separation level1 indicating the end of region0 mapping; start of region0 is 0.'''
    longdesc = '''Possible values for level1 are 0 to 13 (for dual RAQ) or 0 to 14 (for single RAQ) which corresponds to arqos. Note that for PA, arqos values are used directly as port priorities, where the higher the value corresponds to higher port priority. All of the map_level* registers must be set to distinct values.'''
[[register]]
  name = "PCFGQOS1_2"
  type = "rw"
  width = 32
  description = "Port 2 Read QoS Configuration Register 1"
  default = "0x00000000"
  offset = "0x000005F8"
  [[register.field]]
    name = "RQOS_MAP_TIMEOUTR"
    bits = "26:16"
    type = "rw"
  [[register.field]]
    name = "RQOS_MAP_TIMEOUTB"
    bits = "10:0"
    type = "rw"
[[register]]
  name = "PCFGWQOS0_2"
  type = "rw"
  width = 32
  description = "Port 2 Write QoS Configuration Register 0"
  default = "0x00000000"
  offset = "0x000005FC"
  [[register.field]]
    name = "WQOS_MAP_REGION1"
    bits = "21:20"
    type = "rw"
    shortdesc = '''This bitfield indicates the traffic class of region 1.'''
    longdesc = '''Valid values are: 0: NPW, 1: VPW.'''
  [[register.field]]
    name = "WQOS_MAP_REGION0"
    bits = "17:16"
    type = "rw"
    shortdesc = '''This bitfield indicates the traffic class of region 0.'''
    longdesc = '''Valid values are: 0: NPW, 1: VPW.'''
  [[register.field]]
    name = "WQOS_MAP_LEVEL"
    bits = "3:0"
    type = "rw"
    shortdesc = '''Separation level indicating the end of region0 mapping; start of region0 is 0.'''
    longdesc = '''Possible values for level1 are 0 to 14 which corresponds to awqos. Note that for PA, awqos values are used directly as port priorities, where the higher the value corresponds to higher port priority.'''
[[register]]
  name = "PCFGWQOS1_2"
  type = "rw"
  width = 32
  description = "Port 2 Write QoS Configuration Register 1"
  default = "0x00000000"
  offset = "0x00000600"
  [[register.field]]
    name = "WQOS_MAP_TIMEOUT"
    bits = "10:0"
    type = "rw"
[[register]]
  name = "PCFGR_3"
  type = "rw"
  width = 32
  description = "Port 3 Configuration Read Register"
  default = "0x00000000"
  offset = "0x00000614"
  [[register.field]]
    name = "RD_PORT_PAGEMATCH_EN"
    bits = "14"
    type = "rw"
    shortdesc = '''If set to 1, enables the Page Match feature.'''
    longdesc = '''If enabled, once a requesting port is granted, the port is continued to be granted if the following immediate commands are to the same memory page (same bank and same row). See also related PCCFG.pagematch_limit register.'''
  [[register.field]]
    name = "RD_PORT_URGENT_EN"
    bits = "13"
    type = "rw"
    shortdesc = '''If set to 1, enables the AXI urgent sideband signal (arurgent).'''
    longdesc = '''When enabled and arurgent is asserted by the master, that port becomes the highest priority and co_gs_go2critical_lpr/co_gs_go2critical_hpr signal to DDRC is asserted if enabled in PCCFG.go2critical_en register. Note that arurgent signal can be asserted anytime and as long as required which is independent of address handshaking (it is not associated with any particular command).'''
  [[register.field]]
    name = "RD_PORT_AGING_EN"
    bits = "12"
    type = "rw"
  [[register.field]]
    name = "RD_PORT_PRIORITY"
    bits = "9:0"
    type = "rw"
    shortdesc = '''Determines the initial load value of read aging counters.'''
    longdesc = '''These counters will be parallel loaded after reset, or after each grant to the corresponding port. The aging counters down-count every clock cycle where the port is requesting but not granted. The higher significant 5-bits of the read aging counter sets the priority of the read channel of a given port. Port's priority will increase as the higher significant 5-bits of the counter starts to decrease. When the aging counter becomes 0, the corresponding port channel will have the highest priority level (timeout condition - Priority0). For multi-port configurations, the aging counters cannot be used to set port priorities when external dynamic priority inputs (arqos) are enabled (timeout is still applicable). For single-port configurations, the aging counters are only used when they timeout (become 0) to force read-write direction switching. In this case, external dynamic priority input, arqos (for reads only) can still be used to set the DDRC read priority (2 priority levels: low priority read - LPR, high priority read - HPR) on a command by command basis. Note: The two LSBs of this register field are tied internally to 2'b00.'''
[[register]]
  name = "PCFGW_3"
  type = "rw"
  width = 32
  description = "Port 3 Configuration Write Register"
  default = "0x00004000"
  offset = "0x00000618"
  [[register.field]]
    name = "WR_PORT_PAGEMATCH_EN"
    bits = "14"
    type = "rw"
    shortdesc = '''If set to 1, enables the Page Match feature.'''
    longdesc = '''If enabled, once a requesting port is granted, the port is continued to be granted if the following immediate commands are to the same memory page (same bank and same row). See also related PCCFG.pagematch_limit register.'''
  [[register.field]]
    name = "WR_PORT_URGENT_EN"
    bits = "13"
    type = "rw"
    shortdesc = '''If set to 1, enables the AXI urgent sideband signal (awurgent).'''
    longdesc = '''When enabled and awurgent is asserted by the master, that port becomes the highest priority and co_gs_go2critical_wr signal to DDRC is asserted if enabled in PCCFG.go2critical_en register. Note that awurgent signal can be asserted anytime and as long as required which is independent of address handshaking (it is not associated with any particular command).'''
  [[register.field]]
    name = "WR_PORT_AGING_EN"
    bits = "12"
    type = "rw"
  [[register.field]]
    name = "WR_PORT_PRIORITY"
    bits = "9:0"
    type = "rw"
    shortdesc = '''Determines the initial load value of write aging counters.'''
    longdesc = '''These counters will be parallel loaded after reset, or after each grant to the corresponding port. The aging counters down-count every clock cycle where the port is requesting but not granted. The higher significant 5-bits of the write aging counter sets the initial priority of the write channel of a given port. Port's priority will increase as the higher significant 5-bits of the counter starts to decrease. When the aging counter becomes 0, the corresponding port channel will have the highest priority level. For multi-port configurations, the aging counters cannot be used to set port priorities when external dynamic priority inputs (awqos) are enabled (timeout is still applicable). For single-port configurations, the aging counters are only used when they timeout (become 0) to force read-write direction switching. Note: The two LSBs of this register field are tied internally to 2'b00.'''
[[register]]
  name = "PCTRL_3"
  type = "rw"
  width = 32
  description = "Port 3 Control Register"
  default = "0x00000000"
  offset = "0x000006A0"
  [[register.field]]
    name = "PORT_EN"
    bits = "0"
    type = "rw"
[[register]]
  name = "PCFGQOS0_3"
  type = "rw"
  width = 32
  description = "Port 3 Read QoS Configuration Register 0"
  default = "0x00000000"
  offset = "0x000006A4"
  [[register.field]]
    name = "RQOS_MAP_REGION1"
    bits = "21:20"
    type = "rw"
    shortdesc = '''This bitfield indicates the traffic class of region 1.'''
    longdesc = '''Valid values are: 0: LPR, 1: VPR, 2: HPR. For dual address queue configurations, region1 maps to the blue address queue. In this case, valid values are 0: LPR and 1: VPR only.'''
  [[register.field]]
    name = "RQOS_MAP_REGION0"
    bits = "17:16"
    type = "rw"
    shortdesc = '''This bitfield indicates the traffic class of region 0.'''
    longdesc = '''Valid values are: 0: LPR, 1: VPR, 2: HPR. For dual address queue configurations, region 0 maps to the blue address queue. In this case, valid values are: 0: LPR and 1: VPR only.'''
  [[register.field]]
    name = "RQOS_MAP_LEVEL1"
    bits = "3:0"
    type = "rw"
    shortdesc = '''Separation level1 indicating the end of region0 mapping; start of region0 is 0.'''
    longdesc = '''Possible values for level1 are 0 to 13 (for dual RAQ) or 0 to 14 (for single RAQ) which corresponds to arqos. Note that for PA, arqos values are used directly as port priorities, where the higher the value corresponds to higher port priority. All of the map_level* registers must be set to distinct values.'''
[[register]]
  name = "PCFGQOS1_3"
  type = "rw"
  width = 32
  description = "Port 3 Read QoS Configuration Register 1"
  default = "0x00000000"
  offset = "0x000006A8"
  [[register.field]]
    name = "RQOS_MAP_TIMEOUTR"
    bits = "26:16"
    type = "rw"
  [[register.field]]
    name = "RQOS_MAP_TIMEOUTB"
    bits = "10:0"
    type = "rw"
[[register]]
  name = "PCFGWQOS0_3"
  type = "rw"
  width = 32
  description = "Port 3 Write QoS Configuration Register 0"
  default = "0x00000000"
  offset = "0x000006AC"
  [[register.field]]
    name = "WQOS_MAP_REGION1"
    bits = "21:20"
    type = "rw"
    shortdesc = '''This bitfield indicates the traffic class of region 1.'''
    longdesc = '''Valid values are: 0: NPW, 1: VPW.'''
  [[register.field]]
    name = "WQOS_MAP_REGION0"
    bits = "17:16"
    type = "rw"
    shortdesc = '''This bitfield indicates the traffic class of region 0.'''
    longdesc = '''Valid values are: 0: NPW, 1: VPW.'''
  [[register.field]]
    name = "WQOS_MAP_LEVEL"
    bits = "3:0"
    type = "rw"
    shortdesc = '''Separation level indicating the end of region0 mapping; start of region0 is 0.'''
    longdesc = '''Possible values for level1 are 0 to 14 which corresponds to awqos. Note that for PA, awqos values are used directly as port priorities, where the higher the value corresponds to higher port priority.'''
[[register]]
  name = "PCFGWQOS1_3"
  type = "rw"
  width = 32
  description = "Port 3 Write QoS Configuration Register 1"
  default = "0x00000000"
  offset = "0x000006B0"
  [[register.field]]
    name = "WQOS_MAP_TIMEOUT"
    bits = "10:0"
    type = "rw"
[[register]]
  name = "PCFGR_4"
  type = "rw"
  width = 32
  description = "Port 4 Configuration Read Register"
  default = "0x00000000"
  offset = "0x000006C4"
  [[register.field]]
    name = "RD_PORT_PAGEMATCH_EN"
    bits = "14"
    type = "rw"
    shortdesc = '''If set to 1, enables the Page Match feature.'''
    longdesc = '''If enabled, once a requesting port is granted, the port is continued to be granted if the following immediate commands are to the same memory page (same bank and same row). See also related PCCFG.pagematch_limit register.'''
  [[register.field]]
    name = "RD_PORT_URGENT_EN"
    bits = "13"
    type = "rw"
    shortdesc = '''If set to 1, enables the AXI urgent sideband signal (arurgent).'''
    longdesc = '''When enabled and arurgent is asserted by the master, that port becomes the highest priority and co_gs_go2critical_lpr/co_gs_go2critical_hpr signal to DDRC is asserted if enabled in PCCFG.go2critical_en register. Note that arurgent signal can be asserted anytime and as long as required which is independent of address handshaking (it is not associated with any particular command).'''
  [[register.field]]
    name = "RD_PORT_AGING_EN"
    bits = "12"
    type = "rw"
  [[register.field]]
    name = "RD_PORT_PRIORITY"
    bits = "9:0"
    type = "rw"
    shortdesc = '''Determines the initial load value of read aging counters.'''
    longdesc = '''These counters will be parallel loaded after reset, or after each grant to the corresponding port. The aging counters down-count every clock cycle where the port is requesting but not granted. The higher significant 5-bits of the read aging counter sets the priority of the read channel of a given port. Port's priority will increase as the higher significant 5-bits of the counter starts to decrease. When the aging counter becomes 0, the corresponding port channel will have the highest priority level (timeout condition - Priority0). For multi-port configurations, the aging counters cannot be used to set port priorities when external dynamic priority inputs (arqos) are enabled (timeout is still applicable). For single-port configurations, the aging counters are only used when they timeout (become 0) to force read-write direction switching. In this case, external dynamic priority input, arqos (for reads only) can still be used to set the DDRC read priority (2 priority levels: low priority read - LPR, high priority read - HPR) on a command by command basis. Note: The two LSBs of this register field are tied internally to 2'b00.'''
[[register]]
  name = "PCFGW_4"
  type = "rw"
  width = 32
  description = "Port 4 Configuration Write Register"
  default = "0x00004000"
  offset = "0x000006C8"
  [[register.field]]
    name = "WR_PORT_PAGEMATCH_EN"
    bits = "14"
    type = "rw"
    shortdesc = '''If set to 1, enables the Page Match feature.'''
    longdesc = '''If enabled, once a requesting port is granted, the port is continued to be granted if the following immediate commands are to the same memory page (same bank and same row). See also related PCCFG.pagematch_limit register.'''
  [[register.field]]
    name = "WR_PORT_URGENT_EN"
    bits = "13"
    type = "rw"
    shortdesc = '''If set to 1, enables the AXI urgent sideband signal (awurgent).'''
    longdesc = '''When enabled and awurgent is asserted by the master, that port becomes the highest priority and co_gs_go2critical_wr signal to DDRC is asserted if enabled in PCCFG.go2critical_en register. Note that awurgent signal can be asserted anytime and as long as required which is independent of address handshaking (it is not associated with any particular command).'''
  [[register.field]]
    name = "WR_PORT_AGING_EN"
    bits = "12"
    type = "rw"
  [[register.field]]
    name = "WR_PORT_PRIORITY"
    bits = "9:0"
    type = "rw"
    shortdesc = '''Determines the initial load value of write aging counters.'''
    longdesc = '''These counters will be parallel loaded after reset, or after each grant to the corresponding port. The aging counters down-count every clock cycle where the port is requesting but not granted. The higher significant 5-bits of the write aging counter sets the initial priority of the write channel of a given port. Port's priority will increase as the higher significant 5-bits of the counter starts to decrease. When the aging counter becomes 0, the corresponding port channel will have the highest priority level. For multi-port configurations, the aging counters cannot be used to set port priorities when external dynamic priority inputs (awqos) are enabled (timeout is still applicable). For single-port configurations, the aging counters are only used when they timeout (become 0) to force read-write direction switching. Note: The two LSBs of this register field are tied internally to 2'b00.'''
[[register]]
  name = "PCTRL_4"
  type = "rw"
  width = 32
  description = "Port 4 Control Register"
  default = "0x00000000"
  offset = "0x00000750"
  [[register.field]]
    name = "PORT_EN"
    bits = "0"
    type = "rw"
[[register]]
  name = "PCFGQOS0_4"
  type = "rw"
  width = 32
  description = "Port 4 Read QoS Configuration Register 0"
  default = "0x00000000"
  offset = "0x00000754"
  [[register.field]]
    name = "RQOS_MAP_REGION1"
    bits = "21:20"
    type = "rw"
    shortdesc = '''This bitfield indicates the traffic class of region 1.'''
    longdesc = '''Valid values are: 0: LPR, 1: VPR, 2: HPR. For dual address queue configurations, region1 maps to the blue address queue. In this case, valid values are 0: LPR and 1: VPR only.'''
  [[register.field]]
    name = "RQOS_MAP_REGION0"
    bits = "17:16"
    type = "rw"
    shortdesc = '''This bitfield indicates the traffic class of region 0.'''
    longdesc = '''Valid values are: 0: LPR, 1: VPR, 2: HPR. For dual address queue configurations, region 0 maps to the blue address queue. In this case, valid values are: 0: LPR and 1: VPR only.'''
  [[register.field]]
    name = "RQOS_MAP_LEVEL1"
    bits = "3:0"
    type = "rw"
    shortdesc = '''Separation level1 indicating the end of region0 mapping; start of region0 is 0.'''
    longdesc = '''Possible values for level1 are 0 to 13 (for dual RAQ) or 0 to 14 (for single RAQ) which corresponds to arqos. Note that for PA, arqos values are used directly as port priorities, where the higher the value corresponds to higher port priority. All of the map_level* registers must be set to distinct values.'''
[[register]]
  name = "PCFGQOS1_4"
  type = "rw"
  width = 32
  description = "Port 4 Read QoS Configuration Register 1"
  default = "0x00000000"
  offset = "0x00000758"
  [[register.field]]
    name = "RQOS_MAP_TIMEOUTR"
    bits = "26:16"
    type = "rw"
  [[register.field]]
    name = "RQOS_MAP_TIMEOUTB"
    bits = "10:0"
    type = "rw"
[[register]]
  name = "PCFGWQOS0_4"
  type = "rw"
  width = 32
  description = "Port 4 Write QoS Configuration Register 0"
  default = "0x00000000"
  offset = "0x0000075C"
  [[register.field]]
    name = "WQOS_MAP_REGION1"
    bits = "21:20"
    type = "rw"
    shortdesc = '''This bitfield indicates the traffic class of region 1.'''
    longdesc = '''Valid values are: 0: NPW, 1: VPW.'''
  [[register.field]]
    name = "WQOS_MAP_REGION0"
    bits = "17:16"
    type = "rw"
    shortdesc = '''This bitfield indicates the traffic class of region 0.'''
    longdesc = '''Valid values are: 0: NPW, 1: VPW.'''
  [[register.field]]
    name = "WQOS_MAP_LEVEL"
    bits = "3:0"
    type = "rw"
    shortdesc = '''Separation level indicating the end of region0 mapping; start of region0 is 0.'''
    longdesc = '''Possible values for level1 are 0 to 14 which corresponds to awqos. Note that for PA, awqos values are used directly as port priorities, where the higher the value corresponds to higher port priority.'''
[[register]]
  name = "PCFGWQOS1_4"
  type = "rw"
  width = 32
  description = "Port 4 Write QoS Configuration Register 1"
  default = "0x00000000"
  offset = "0x00000760"
  [[register.field]]
    name = "WQOS_MAP_TIMEOUT"
    bits = "10:0"
    type = "rw"
[[register]]
  name = "PCFGR_5"
  type = "rw"
  width = 32
  description = "Port 5 Configuration Read Register"
  default = "0x00000000"
  offset = "0x00000774"
  [[register.field]]
    name = "RD_PORT_PAGEMATCH_EN"
    bits = "14"
    type = "rw"
    shortdesc = '''If set to 1, enables the Page Match feature.'''
    longdesc = '''If enabled, once a requesting port is granted, the port is continued to be granted if the following immediate commands are to the same memory page (same bank and same row). See also related PCCFG.pagematch_limit register.'''
  [[register.field]]
    name = "RD_PORT_URGENT_EN"
    bits = "13"
    type = "rw"
    shortdesc = '''If set to 1, enables the AXI urgent sideband signal (arurgent).'''
    longdesc = '''When enabled and arurgent is asserted by the master, that port becomes the highest priority and co_gs_go2critical_lpr/co_gs_go2critical_hpr signal to DDRC is asserted if enabled in PCCFG.go2critical_en register. Note that arurgent signal can be asserted anytime and as long as required which is independent of address handshaking (it is not associated with any particular command).'''
  [[register.field]]
    name = "RD_PORT_AGING_EN"
    bits = "12"
    type = "rw"
  [[register.field]]
    name = "RD_PORT_PRIORITY"
    bits = "9:0"
    type = "rw"
    shortdesc = '''Determines the initial load value of read aging counters.'''
    longdesc = '''These counters will be parallel loaded after reset, or after each grant to the corresponding port. The aging counters down-count every clock cycle where the port is requesting but not granted. The higher significant 5-bits of the read aging counter sets the priority of the read channel of a given port. Port's priority will increase as the higher significant 5-bits of the counter starts to decrease. When the aging counter becomes 0, the corresponding port channel will have the highest priority level (timeout condition - Priority0). For multi-port configurations, the aging counters cannot be used to set port priorities when external dynamic priority inputs (arqos) are enabled (timeout is still applicable). For single-port configurations, the aging counters are only used when they timeout (become 0) to force read-write direction switching. In this case, external dynamic priority input, arqos (for reads only) can still be used to set the DDRC read priority (2 priority levels: low priority read - LPR, high priority read - HPR) on a command by command basis. Note: The two LSBs of this register field are tied internally to 2'b00.'''
[[register]]
  name = "PCFGW_5"
  type = "rw"
  width = 32
  description = "Port 5 Configuration Write Register"
  default = "0x00004000"
  offset = "0x00000778"
  [[register.field]]
    name = "WR_PORT_PAGEMATCH_EN"
    bits = "14"
    type = "rw"
    shortdesc = '''If set to 1, enables the Page Match feature.'''
    longdesc = '''If enabled, once a requesting port is granted, the port is continued to be granted if the following immediate commands are to the same memory page (same bank and same row). See also related PCCFG.pagematch_limit register.'''
  [[register.field]]
    name = "WR_PORT_URGENT_EN"
    bits = "13"
    type = "rw"
    shortdesc = '''If set to 1, enables the AXI urgent sideband signal (awurgent).'''
    longdesc = '''When enabled and awurgent is asserted by the master, that port becomes the highest priority and co_gs_go2critical_wr signal to DDRC is asserted if enabled in PCCFG.go2critical_en register. Note that awurgent signal can be asserted anytime and as long as required which is independent of address handshaking (it is not associated with any particular command).'''
  [[register.field]]
    name = "WR_PORT_AGING_EN"
    bits = "12"
    type = "rw"
  [[register.field]]
    name = "WR_PORT_PRIORITY"
    bits = "9:0"
    type = "rw"
    shortdesc = '''Determines the initial load value of write aging counters.'''
    longdesc = '''These counters will be parallel loaded after reset, or after each grant to the corresponding port. The aging counters down-count every clock cycle where the port is requesting but not granted. The higher significant 5-bits of the write aging counter sets the initial priority of the write channel of a given port. Port's priority will increase as the higher significant 5-bits of the counter starts to decrease. When the aging counter becomes 0, the corresponding port channel will have the highest priority level. For multi-port configurations, the aging counters cannot be used to set port priorities when external dynamic priority inputs (awqos) are enabled (timeout is still applicable). For single-port configurations, the aging counters are only used when they timeout (become 0) to force read-write direction switching. Note: The two LSBs of this register field are tied internally to 2'b00.'''
[[register]]
  name = "PCTRL_5"
  type = "rw"
  width = 32
  description = "Port 5 Control Register"
  default = "0x00000000"
  offset = "0x00000800"
  [[register.field]]
    name = "PORT_EN"
    bits = "0"
    type = "rw"
[[register]]
  name = "PCFGQOS0_5"
  type = "rw"
  width = 32
  description = "Port 5 Read QoS Configuration Register 0"
  default = "0x00000000"
  offset = "0x00000804"
  [[register.field]]
    name = "RQOS_MAP_REGION1"
    bits = "21:20"
    type = "rw"
    shortdesc = '''This bitfield indicates the traffic class of region 1.'''
    longdesc = '''Valid values are: 0: LPR, 1: VPR, 2: HPR. For dual address queue configurations, region1 maps to the blue address queue. In this case, valid values are 0: LPR and 1: VPR only.'''
  [[register.field]]
    name = "RQOS_MAP_REGION0"
    bits = "17:16"
    type = "rw"
    shortdesc = '''This bitfield indicates the traffic class of region 0.'''
    longdesc = '''Valid values are: 0: LPR, 1: VPR, 2: HPR. For dual address queue configurations, region 0 maps to the blue address queue. In this case, valid values are: 0: LPR and 1: VPR only.'''
  [[register.field]]
    name = "RQOS_MAP_LEVEL1"
    bits = "3:0"
    type = "rw"
    shortdesc = '''Separation level1 indicating the end of region0 mapping; start of region0 is 0.'''
    longdesc = '''Possible values for level1 are 0 to 13 (for dual RAQ) or 0 to 14 (for single RAQ) which corresponds to arqos. Note that for PA, arqos values are used directly as port priorities, where the higher the value corresponds to higher port priority. All of the map_level* registers must be set to distinct values.'''
[[register]]
  name = "PCFGQOS1_5"
  type = "rw"
  width = 32
  description = "Port 5 Read QoS Configuration Register 1"
  default = "0x00000000"
  offset = "0x00000808"
  [[register.field]]
    name = "RQOS_MAP_TIMEOUTR"
    bits = "26:16"
    type = "rw"
  [[register.field]]
    name = "RQOS_MAP_TIMEOUTB"
    bits = "10:0"
    type = "rw"
[[register]]
  name = "PCFGWQOS0_5"
  type = "rw"
  width = 32
  description = "Port 5 Write QoS Configuration Register 0"
  default = "0x00000000"
  offset = "0x0000080C"
  [[register.field]]
    name = "WQOS_MAP_REGION1"
    bits = "21:20"
    type = "rw"
    shortdesc = '''This bitfield indicates the traffic class of region 1.'''
    longdesc = '''Valid values are: 0: NPW, 1: VPW.'''
  [[register.field]]
    name = "WQOS_MAP_REGION0"
    bits = "17:16"
    type = "rw"
    shortdesc = '''This bitfield indicates the traffic class of region 0.'''
    longdesc = '''Valid values are: 0: NPW, 1: VPW.'''
  [[register.field]]
    name = "WQOS_MAP_LEVEL"
    bits = "3:0"
    type = "rw"
    shortdesc = '''Separation level indicating the end of region0 mapping; start of region0 is 0.'''
    longdesc = '''Possible values for level1 are 0 to 14 which corresponds to awqos. Note that for PA, awqos values are used directly as port priorities, where the higher the value corresponds to higher port priority.'''
[[register]]
  name = "PCFGWQOS1_5"
  type = "rw"
  width = 32
  description = "Port 5 Write QoS Configuration Register 1"
  default = "0x00000000"
  offset = "0x00000810"
  [[register.field]]
    name = "WQOS_MAP_TIMEOUT"
    bits = "10:0"
    type = "rw"
[[register]]
  name = "SARBASE0"
  type = "rw"
  width = 32
  description = "SAR Base Address Register 0"
  default = "0x00000000"
  offset = "0x00000F04"
  [[register.field]]
    name = "BASE_ADDR"
    bits = "8:0"
    type = "rw"
[[register]]
  name = "SARSIZE0"
  type = "rw"
  width = 32
  description = "SAR Size Register 0"
  default = "0x00000000"
  offset = "0x00000F08"
  [[register.field]]
    name = "NBLOCKS"
    bits = "7:0"
    type = "rw"
    shortdesc = '''Number of blocks for address region 0.'''
    longdesc = '''This register determines the total size of the region in multiples of minimum block size as specified by the hardware parameter UMCTL2_SARMINSIZE=4. The register value is encoded as number of blocks = nblocks + 1. For example, if register is programmed to 0, region will have 1 block.'''
[[register]]
  name = "SARBASE1"
  type = "rw"
  width = 32
  description = "SAR Base Address Register 1"
  default = "0x00000001"
  offset = "0x00000F0C"
  [[register.field]]
    name = "BASE_ADDR"
    bits = "8:0"
    type = "rw"
[[register]]
  name = "SARSIZE1"
  type = "rw"
  width = 32
  description = "SAR Size Register 1"
  default = "0x00000000"
  offset = "0x00000F10"
  [[register.field]]
    name = "NBLOCKS"
    bits = "7:0"
    type = "rw"
    shortdesc = '''Number of blocks for address region 1.'''
    longdesc = '''This register determines the total size of the region in multiples of minimum block size as specified by the hardware parameter UMCTL2_SARMINSIZE=4. The register value is encoded as number of blocks = nblocks + 1. For example, if register is programmed to 0, region will have 1 block.'''
[[register]]
  name = "DERATEINT_SHADOW"
  type = "rw"
  width = 32
  description = "Temperature Derate Interval Shadow Register"
  default = "0x00800000"
  offset = "0x00002024"
  [[register.field]]
    name = "MR4_READ_INTERVAL"
    bits = "31:0"
    type = "rw"
    shortdesc = '''LPDDR3/LPDDR4: Interval between two MR4 reads, used to derate the timing parameters.'''
    longdesc = '''This register must not be set to zero'''
[[register]]
  name = "RFSHCTL0_SHADOW"
  type = "rw"
  width = 32
  description = "Refresh Control Shadow Register 0"
  default = "0x00210000"
  offset = "0x00002050"
  [[register.field]]
    name = "REFRESH_MARGIN"
    bits = "23:20"
    type = "rw"
    shortdesc = '''Threshold value in number of clock cycles before the critical refresh or page timer expires.'''
    longdesc = '''A critical refresh is to be issued before this threshold is reached. It is recommended that this not be changed from the default value, currently shown as 0x2. It must always be less than internally used t_rfc_nom_x32. Note that, in LPDDR3, internally used t_rfc_nom_x32 may be equal to RFSHTMG_SHADOW.t_rfc_nom_x32_shadow>>2 if derating is enabled (DERATEEN.derate_enable=1). Otherwise, internally used t_rfc_nom_x32 will be equal to RFSHTMG_SHADOW.t_rfc_nom_x32_shadow. Unit: Multiples of 32 clocks.'''
  [[register.field]]
    name = "REFRESH_TO_X32"
    bits = "16:12"
    type = "rw"
    shortdesc = '''If the refresh timer (tRFCnom, also known as tREFI) has expired at least once, but it has not expired (RFSHCTL0_SHADOW.'''
    longdesc = '''refresh_burst_shadow+1) times yet, then a speculative refresh may be performed. A speculative refresh is a refresh performed at a time when refresh would be useful, but before it is absolutely required. When the SDRAM bus is idle for a period of time determined by this RFSHCTL0_SHADOW.refresh_to_x32_shadow and the refresh timer has expired at least once since the last refresh, then a speculative refresh is performed. Speculative refreshes continues successively until there are no refreshes pending or until new reads or writes are issued to the DDRC. FOR PERFORMANCE ONLY.'''
  [[register.field]]
    name = "REFRESH_BURST"
    bits = "8:4"
    type = "rw"
    shortdesc = '''The programmed value + 1 is the number of refresh timeouts that is allowed to accumulate before traffic is blocked and the refreshes are forced to execute.'''
    longdesc = '''Closing pages to perform a refresh is a one-time penalty that must be paid for each group of refreshes. Therefore, performing refreshes in a burst reduces the per-refresh penalty of these page closings. Higher numbers for RFSHCTL0_SHADOW.refresh_burst_shadow slightly increases utilization; lower numbers decreases the worst-case latency associated with refreshes. - 0 - single refresh - 1 - burst-of-2 refresh - 7 - burst-of-8 refresh For DDR3, the refresh is always per-rank and not per-bank. The rank refresh can be accumulated over 8*tREFI cycles using the burst refresh feature. In DDR4 mode, according to Fine Granularity feature, 8 refreshes can be postponed in 1X mode, 16 refreshes in 2X mode and 32 refreshes in 4X mode. If using PHY-initiated updates, care must be taken in the setting of RFSHCTL0_SHADOW.refresh_burst_shadow, to ensure that tRFCmax is not violated due to a PHY-initiated update occurring shortly before a refresh burst was due. In this situation, the refresh burst will be delayed until the PHY-initiated update is complete.'''
  [[register.field]]
    name = "PER_BANK_REFRESH"
    bits = "2"
    type = "rw"
    shortdesc = '''- 1 - Per bank refresh; - 0 - All bank refresh.'''
    longdesc = '''Per bank refresh allows traffic to flow to other banks. Per bank refresh is supported by all LPDDR3/LPDDR4 devices. Programming Mode: Static'''
[[register]]
  name = "RFSHTMG_SHADOW"
  type = "rw"
  width = 32
  description = "Refresh Timing Shadow Register"
  default = "0x0062008C"
  offset = "0x00002064"
  [[register.field]]
    name = "T_RFC_NOM_X32"
    bits = "27:16"
    type = "rw"
    shortdesc = '''tREFI: Average time interval between refreshes per rank (Specification: 7.'''
    longdesc = '''8us for DDR3 and DDR4. See JEDEC specification for LPDDR3). For LPDDR3: - if using all-bank refreshes (RFSHCTL0_SHADOW.per_bank_refresh_shadow = 0), this register should be set to tREFIab - if using per-bank refreshes (RFSHCTL0_SHADOW.per_bank_refresh_shadow = 1), this register should be set to tREFIpb Program this to (tREFI/2), no rounding up. In DDR4 mode, tREFI value is different depending on the refresh mode. The user should program the appropriate value from the spec based on the value programmed in the refresh mode register. Note that RFSHTMG_SHADOW.t_rfc_nom_x32_shadow * 32 must be greater than RFSHTMG_SHADOW.t_rfc_min_shadow, and RFSHTMG_SHADOW.t_rfc_nom_x32_shadow must be greater than 0x1. Unit: Multiples of 32 clocks.'''
  [[register.field]]
    name = "LPDDR3_TREFBW_EN"
    bits = "15"
    type = "rw"
    shortdesc = '''Used only when LPDDR3 memory type is connected.'''
    longdesc = '''Should only be changed when DDRC is in reset. Specifies whether to use the tREFBW parameter (required by some LPDDR3 devices which comply with earlier versions of the LPDDR3 JEDEC specification) or not: - 0 - tREFBW parameter not used - 1 - tREFBW parameter used Programming Mode: Static'''
  [[register.field]]
    name = "T_RFC_MIN"
    bits = "9:0"
    type = "rw"
    shortdesc = '''tRFC (min): Minimum time from refresh to refresh or activate.'''
    longdesc = '''t_rfc_min should be set to RoundUp(RoundUp(tRFCmin/tCK)/2). In LPDDR3/LPDDR4 mode: - if using all-bank refreshes, the tRFCmin value in the above equations is equal to tRFCab - if using per-bank refreshes, the tRFCmin value in the above equations is equal to tRFCpb In DDR4 mode, the tRFCmin value in the above equations is different depending on the refresh mode (fixed 1X,2X,4X) and the device density. The user should program the appropriate value from the spec based on the 'refresh_mode' and the device density that is used. Unit: Clocks.'''
[[register]]
  name = "INIT3_SHADOW"
  type = "rw"
  width = 32
  description = "SDRAM Initialization Shadow Register 3"
  default = "0x00000510"
  offset = "0x000020DC"
  [[register.field]]
    name = "MR"
    bits = "31:16"
    type = "rw"
    shortdesc = '''DDR3/DDR4: Value loaded into MR0 register.'''
    longdesc = '''LPDDR3/LPDDR4 - Value to write to MR1 register Programming Mode: Quasi-dynamic Group 1 and Group 4'''
  [[register.field]]
    name = "EMR"
    bits = "15:0"
    type = "rw"
    shortdesc = '''DDR3/DDR4: Value to write to MR1 register Set bit 7 to 0.'''
    longdesc = '''If PHY-evaluation mode training is enabled, this bit is set appropriately by the DDRC during write leveling. LPDDR3/LPDDR4 - Value to write to MR2 register'''
[[register]]
  name = "INIT4_SHADOW"
  type = "rw"
  width = 32
  description = "SDRAM Initialization Shadow Register 4"
  default = "0x00000000"
  offset = "0x000020E0"
  [[register.field]]
    name = "EMR2"
    bits = "31:16"
    type = "rw"
  [[register.field]]
    name = "EMR3"
    bits = "15:0"
    type = "rw"
[[register]]
  name = "INIT6_SHADOW"
  type = "rw"
  width = 32
  description = "SDRAM Initialization Shadow Register 6"
  default = "0x00000000"
  offset = "0x000020E8"
  [[register.field]]
    name = "MR4"
    bits = "31:16"
    type = "rw"
    shortdesc = '''DDR4- Value to be loaded into SDRAM MR4 registers.'''
    longdesc = '''Used in DDR4 designs only.'''
  [[register.field]]
    name = "MR5"
    bits = "15:0"
    type = "rw"
    shortdesc = '''DDR4- Value to be loaded into SDRAM MR5 registers.'''
    longdesc = '''Used in DDR4 designs only. Programming Mode: Quasi-dynamic Group 1 and Group 4'''
[[register]]
  name = "INIT7_SHADOW"
  type = "rw"
  width = 32
  description = "SDRAM Initialization Shadow Register 7"
  default = "0x00000000"
  offset = "0x000020EC"
  [[register.field]]
    name = "MR6"
    bits = "31:16"
    type = "rw"
    shortdesc = '''DDR4- Value to be loaded into SDRAM MR6 registers.'''
    longdesc = '''Used in DDR4 designs only.'''
[[register]]
  name = "DRAMTMG0_SHADOW"
  type = "rw"
  width = 32
  description = "SDRAM Timing Shadow Register 0"
  default = "0x0F101B0F"
  offset = "0x00002100"
  [[register.field]]
    name = "WR2PRE"
    bits = "30:24"
    type = "rw"
    shortdesc = '''Minimum time between write and precharge to same bank.'''
    longdesc = '''Unit: Clocks Specifications: WL + BL/2 + tWR = approximately 8 cycles + 15 ns = 14 clocks @400MHz and less for lower frequencies where: - WL = write latency - BL = burst length. This must match the value programmed in the BL bit of the mode register to the SDRAM. BST (burst terminate) is not supported at present. - tWR = Write recovery time. This comes directly from the SDRAM specification. Add one extra cycle for LPDDR3/LPDDR4 for this parameter. For 1T mode, divide the above value by 2. No rounding up. For 2T mode or LPDDR4 mode, divide the above value by 2 and round it up to the next integer value. Programming Mode: Quasi-dynamic Group 1, Group 2, and Group 4'''
  [[register.field]]
    name = "T_FAW"
    bits = "21:16"
    type = "rw"
    shortdesc = '''tFAW Valid only when 8 or more banks(or banks x bank groups) are present.'''
    longdesc = '''In 8-bank design, at most 4 banks must be activated in a rolling window of tFAW cycles. Program this to (tFAW/2) and round up to next integer value. In a 4-bank design, set this register to 0x1. Unit: Clocks'''
  [[register.field]]
    name = "T_RAS_MAX"
    bits = "14:8"
    type = "rw"
    shortdesc = '''tRAS(max): Maximum time between activate and precharge to same bank.'''
    longdesc = '''This is the maximum time that a page can be kept open Minimum value of this register is 1. Zero is invalid. Program this to (tRAS(max)-1)/2. No rounding up. Unit: Multiples of 1024 clocks.'''
  [[register.field]]
    name = "T_RAS_MIN"
    bits = "5:0"
    type = "rw"
    shortdesc = '''tRAS(min): Minimum time between activate and precharge to the same bank.'''
    longdesc = '''For 1T mode, program this to tRAS(min)/2. No rounding up. For 2T mode or LPDDR4 mode, program this to (tRAS(min)/2) and round it up to the next integer value. Unit: Clocks'''
[[register]]
  name = "DRAMTMG1_SHADOW"
  type = "rw"
  width = 32
  description = "SDRAM Timing Shadow Register 1"
  default = "0x00080414"
  offset = "0x00002104"
  [[register.field]]
    name = "T_XP"
    bits = "20:16"
    type = "rw"
    shortdesc = '''tXP: Minimum time after power-down exit to any operation.'''
    longdesc = '''For DDR3, this should be programmed to tXPDLL if slow powerdown exit is selected in MR0[12]. If C/A parity for DDR4 is used, set to (tXP+PL) instead. Program this to (tXP/2) and round it up to the next integer value. Units: Clocks'''
  [[register.field]]
    name = "RD2PRE"
    bits = "12:8"
    type = "rw"
    shortdesc = '''tRTP: Minimum time from read to precharge of same bank.'''
    longdesc = '''- DDR3: tAL + max (tRTP, 4) - DDR4: Max of following two equations: tAL + max (tRTP, 4) or, RL + BL/2 - tRP. - LPDDR3: BL/2 + max(tRTP,4) - 4 - LPDDR4: BL/2 + max(tRTP,8) - 8 For 1T mode, divide the above value by 2. No rounding up. For 2T mode or LPDDR4 mode, divide the above value by 2 and round it up to the next integer value. Unit: Clocks. Programming Mode: Quasi-dynamic Group 1, Group 2, and Group 4'''
  [[register.field]]
    name = "T_RC"
    bits = "6:0"
    type = "rw"
    shortdesc = '''tRC: Minimum time between activates to same bank.'''
    longdesc = '''Program this to (tRC/2) and round up to next integer value. Unit: Clocks.'''
[[register]]
  name = "DRAMTMG2_SHADOW"
  type = "rw"
  width = 32
  description = "SDRAM Timing Shadow Register 2"
  default = "0x0305060D"
  offset = "0x00002108"
  [[register.field]]
    name = "WRITE_LATENCY"
    bits = "29:24"
    type = "rw"
    shortdesc = '''Set to WL Time from write command to write data on SDRAM interface.'''
    longdesc = '''This must be set to WL. Note that, depending on the PHY, if using RDIMM, it may be necessary to use a value of WL + 1 to compensate for the extra cycle of latency through the RDIMM Divide the value calculated using the above equation by 2, and round it up to next integer. This register field is not required for DDR3, as the DFI read and write latencies defined in DFITMG0 and DFITMG1 are sufficient for those protocols Unit: clocks'''
  [[register.field]]
    name = "READ_LATENCY"
    bits = "21:16"
    type = "rw"
    shortdesc = '''Set to RL Time from read command to read data on SDRAM interface.'''
    longdesc = '''This must be set to RL. Note that, depending on the PHY, if using RDIMM, it mat be necessary to use a value of RL + 1 to compensate for the extra cycle of latency through the RDIMM Divide the value calculated using the above equation by 2, and round it up to next integer. This register field is not required for DDR3, as the DFI read and write latencies defined in DFITMG0 and DFITMG1 are sufficient for those protocols Unit: clocks'''
  [[register.field]]
    name = "RD2WR"
    bits = "13:8"
    type = "rw"
    shortdesc = '''DDR3: RL + BL/2 + 2 - WL DDR4: RL + BL/2 + 1 + WR_PREAMBLE - WL LPDDR3: RL + BL/2 + RU(tDQSCKmax/tCK) + 1 - WL LPDDR4(DQ ODT is Disabled): RL + BL/2 + RU(tDQSCKmax/tCK) + WR_PREAMBLE + RD_POSTAMBLE - WL LPDDR4(DQ ODT is Enabled): RL + BL/2 + RU(tDQSCKmax/tCK) + RD_POSTAMBLE - ODTLon - RU(tODTon(min)/tCK) Minimum time from read command to write command.'''
    longdesc = '''Include time for bus turnaround and all per-bank, per-rank, and global constraints. Unit: Clocks. Where: - WL = write latency - BL = burst length. This must match the value programmed in the BL bit of the mode register to the SDRAM - RL = read latency = CAS latency - WR_PREAMBLE = write preamble. This is unique to DDR4 and LPDDR4. - RD_POSTAMBLE = read postamble. This is unique to LPDDR4. For LPDDR3/LPDDR4, if derating is enabled (DERATEEN.derate_enable=1), derated tDQSCKmax should be used. Divide the value calculated using the above equation by 2, and round it up to next integer.'''
  [[register.field]]
    name = "WR2RD"
    bits = "5:0"
    type = "rw"
    shortdesc = '''DDR4: CWL + PL + BL/2 + tWTR_L Others: CWL + BL/2 + tWTR In DDR4, minimum time from write command to read command for same bank group.'''
    longdesc = '''In others, minimum time from write command to read command. Includes time for bus turnaround, recovery times, and all per-bank, per-rank, and global constraints. Unit: Clocks. Where: - CWL = CAS write latency - PL = Parity latency - BL = burst length. This must match the value programmed in the BL bit of the mode register to the SDRAM - tWTR_L = internal write to read command delay for same bank group. This comes directly from the SDRAM specification. - tWTR = internal write to read command delay. This comes directly from the SDRAM specification. Add one extra cycle for LPDDR3/LPDDR4 operation. Divide the value calculated using the above equation by 2, and round it up to next integer.'''
[[register]]
  name = "DRAMTMG3_SHADOW"
  type = "rw"
  width = 32
  description = "SDRAM Timing Shadow Register 3"
  default = "0x0050400C"
  offset = "0x0000210C"
  [[register.field]]
    name = "T_MRW"
    bits = "29:20"
    type = "rw"
    shortdesc = '''LPDDR3/LPDDR4: Time to wait after a mode register write or read (MRW or MRR).'''
    longdesc = '''LPDDR3 typically requires value of 10. LPDDR4: Set this to the larger of tMRW and tMRWCKEL. For this register is used for the time from a MRW/MRR to all other commands. For LDPDR3, this register is used for the time from a MRW/MRR to a MRW/MRR.'''
  [[register.field]]
    name = "T_MRD"
    bits = "17:12"
    type = "rw"
    shortdesc = '''tMRD: Cycles to wait after a mode register write or read.'''
    longdesc = '''Depending on the connected SDRAM, tMRD represents: DDR3/4: Time from MRS to MRS command LPDDR3/4: Time from MRS to non-MRS command Program this to (tMRD/2) and round it up to the next integer value. If C/A parity for DDR4 is used, set to tMRD_PAR(tMOD+PL) instead.'''
  [[register.field]]
    name = "T_MOD"
    bits = "9:0"
    type = "rw"
    shortdesc = '''tMOD: Parameter used only in DDR3 and DDR4.'''
    longdesc = '''Cycles between load mode command and following non-load mode command. If C/A parity for DDR4 is used, set to tMOD_PAR(tMOD+PL) instead. Set to tMOD/2 (rounded up to next integer). Note that if using RDIMM, depending on the PHY, it may be necessary to use a value of tMOD + 1 or (tMOD + 1)/2 to compensate for the extra cycle of latency applied to mode register writes by the RDIMM chip.'''
[[register]]
  name = "DRAMTMG4_SHADOW"
  type = "rw"
  width = 32
  description = "SDRAM Timing Shadow Register 4"
  default = "0x05040405"
  offset = "0x00002110"
  [[register.field]]
    name = "T_RCD"
    bits = "28:24"
    type = "rw"
    shortdesc = '''tRCD - tAL: Minimum time from activate to read or write command to same bank.'''
    longdesc = '''Program this to ((tRCD - tAL)/2) and round it up to the next integer value. Minimum value allowed for this register is 1, which implies minimum (tRCD - tAL) value to be 2. Unit: Clocks. Programming Mode: Quasi-dynamic Group 1, Group 2, and Group 4'''
  [[register.field]]
    name = "T_CCD"
    bits = "19:16"
    type = "rw"
    shortdesc = '''DDR4: tCCD_L: This is the minimum time between two reads or two writes for same bank group.'''
    longdesc = '''Others: tCCD: This is the minimum time between two reads or two writes. Program this to (tCCD_L/2 or tCCD/2) and round it up to the next integer value. Unit: clocks.'''
  [[register.field]]
    name = "T_RRD"
    bits = "11:8"
    type = "rw"
    shortdesc = '''DDR4: tRRD_L: Minimum time between activates from bank 'a' to bank 'b' for same bank group.'''
    longdesc = '''Others: tRRD: Minimum time between activates from bank 'a' to bank 'b'Program this to (tRRD_L/2 or tRRD/2) and round it up to the next integer value. Unit: Clocks.'''
  [[register.field]]
    name = "T_RP"
    bits = "4:0"
    type = "rw"
    shortdesc = '''tRP: Minimum time from precharge to activate of same bank.'''
    longdesc = '''t_rp should be set to RoundDown(RoundUp(tRP/tCK)/2) + 1. In LPDDR4, t_rp should be set to RoundUp(RoundUp(tRP/tCK)/2). Unit: Clocks.'''
[[register]]
  name = "DRAMTMG5_SHADOW"
  type = "rw"
  width = 32
  description = "SDRAM Timing Shadow Register 5"
  default = "0x05050403"
  offset = "0x00002114"
  [[register.field]]
    name = "T_CKSRX"
    bits = "27:24"
    type = "rw"
    shortdesc = '''This is the time before Self Refresh Exit that CK is maintained as a valid clock before issuing SRX.'''
    longdesc = '''Specifies the clock stable time before SRX. Recommended settings: - LPDDR3: 2 - LPDDR4: tCKCKEH - DDR3: tCKSRX - DDR4: tCKSRX Program this to recommended value divided by two and round it up to next integer.'''
  [[register.field]]
    name = "T_CKSRE"
    bits = "19:16"
    type = "rw"
    shortdesc = '''This is the time after Self Refresh Down Entry that CK is maintained as a valid clock.'''
    longdesc = '''Specifies the clock disable delay after SRE. Recommended settings: - LPDDR3: 2 - LPDDR4: tCKCKEL - DDR3: max (10 ns, 5 tCK) - DDR4: max (10 ns, 5 tCK) Program this to recommended value divided by two and round it up to next integer.'''
  [[register.field]]
    name = "T_CKESR"
    bits = "13:8"
    type = "rw"
    shortdesc = '''Minimum CKE low width for Self refresh or Self refresh power down entry to exit timing in memory clock cycles.'''
    longdesc = '''Recommended settings: - LPDDR3: tCKESR - LPDDR4: max(tCKELPD, tSR) - DDR3: tCKE + 1 - DDR4: tCKE + 1 Program this to recommended value divided by two and round it up to next integer.'''
  [[register.field]]
    name = "T_CKE"
    bits = "4:0"
    type = "rw"
    shortdesc = '''Minimum number of cycles of CKE HIGH/LOW during power-down and self refresh.'''
    longdesc = '''- LPDDR3 mode: Set this to the larger of tCKE or tCKESR - LPDDR4 mode: Set this to the larger of tCKE, tCKELPD or tSR. - Non-non-LPDDR3/non-LPDDR4 designs: Set this to tCKE value. Program this to (value described above)/2 and round it up to the next integer value. Unit: Clocks.'''
[[register]]
  name = "DRAMTMG6_SHADOW"
  type = "rw"
  width = 32
  description = "SDRAM Timing Shadow Register 6"
  default = "0x02020005"
  offset = "0x00002118"
  [[register.field]]
    name = "T_CKDPDE"
    bits = "27:24"
    type = "rw"
    shortdesc = '''LPDDR3: This is the time after Deep Power Down Entry that CK is maintained as a valid clock.'''
    longdesc = '''Specifies the clock disable delay after DPDE. Recommended settings: - LPDDR3: 2 Program this to recommended value divided by two and round it up to next integer.'''
  [[register.field]]
    name = "T_CKDPDX"
    bits = "19:16"
    type = "rw"
    shortdesc = '''This is the time before Deep Power Down Exit that CK is maintained as a valid clock before issuing DPDX.'''
    longdesc = '''Specifies the clock stable time before DPDX. Recommended settings: - LPDDR3: 2 Program this to recommended value divided by two and round it up to next integer.'''
  [[register.field]]
    name = "T_CKCSX"
    bits = "3:0"
    type = "rw"
    shortdesc = '''LPDDR3/LPDDR4: This is the time before Clock Stop Exit that CK is maintained as a valid clock before issuing Clock Stop Exit.'''
    longdesc = '''Specifies the clock stable time before next command after Clock Stop Exit. Recommended settings: - LPDDR3: tXP + 2 - LPDDR4: tXP + 2 Program this to recommended value divided by two and round it up to next integer.'''
[[register]]
  name = "DRAMTMG7_SHADOW"
  type = "rw"
  width = 32
  description = "SDRAM Timing Shadow Register 7"
  default = "0x00000202"
  offset = "0x0000211C"
  [[register.field]]
    name = "T_CKPDE"
    bits = "11:8"
    type = "rw"
    shortdesc = '''LPDDR3/LPDDR4: This is the time after Power Down Entry that CK is maintained as a valid clock.'''
    longdesc = '''Specifies the clock disable delay after PDE. Recommended settings: - LPDDR3: 2 - LPDDR4: tCKCKEL Program this to recommended value divided by two and round it up to next integer.'''
  [[register.field]]
    name = "T_CKPDX"
    bits = "3:0"
    type = "rw"
    shortdesc = '''LPDDR3/LPDDR4: This is the time before Power Down Exit that CK is maintained as a valid clock before issuing PDX.'''
    longdesc = '''Specifies the clock stable time before PDX. Recommended settings: - LPDDR3: 2 - LPDDR4: 2 Program this to recommended value divided by two and round it up to next integer.'''
[[register]]
  name = "DRAMTMG8_SHADOW"
  type = "rw"
  width = 32
  description = "SDRAM Timing Shadow Register 8"
  default = "0x03034405"
  offset = "0x00002120"
  [[register.field]]
    name = "T_XS_FAST_X32"
    bits = "30:24"
    type = "rw"
    shortdesc = '''tXS_FAST: Exit Self Refresh to ZQCL, ZQCS and MRS (only CL, WR, and RTP).'''
    longdesc = '''Program this to the above value divided by 2 and round up to next integer value. Unit: Multiples of 32 clocks. Note: This is applicable to only ZQCL/ZQCS commands. Note: Ensure this is less than or equal to t_xs_x32.'''
  [[register.field]]
    name = "T_XS_ABORT_X32"
    bits = "22:16"
    type = "rw"
    shortdesc = '''tXS_ABORT: Exit Self Refresh to commands not requiring a locked DLL in Self Refresh Abort.'''
    longdesc = '''Program this to the above value divided by 2 and round up to next integer value. Unit: Multiples of 32 clocks. Note: Ensure this is less than or equal to t_xs_x32.'''
  [[register.field]]
    name = "T_XS_DLL_X32"
    bits = "14:8"
    type = "rw"
    shortdesc = '''tXSDLL: Exit Self Refresh to commands requiring a locked DLL.'''
    longdesc = '''Program this to the above value divided by 2 and round up to next integer value. Unit: Multiples of 32 clocks. Note: Used only for DDR3 and DDR4 SDRAMs.'''
  [[register.field]]
    name = "T_XS_X32"
    bits = "6:0"
    type = "rw"
    shortdesc = '''tXS: Exit Self Refresh to commands not requiring a locked DLL.'''
    longdesc = '''Program this to the above value divided by 2 and round up to next integer value. Unit: Multiples of 32 clocks. Note: Used only for DDR3 and DDR4 SDRAMs.'''
[[register]]
  name = "DRAMTMG9_SHADOW"
  type = "rw"
  width = 32
  description = "SDRAM Timing Shadow Register 9"
  default = "0x0004040D"
  offset = "0x00002124"
  [[register.field]]
    name = "DDR4_WR_PREAMBLE"
    bits = "30"
    type = "rw"
  [[register.field]]
    name = "T_CCD_S"
    bits = "18:16"
    type = "rw"
    shortdesc = '''DDR4: tCCD_S: This is the minimum time between two reads or two writes for different bank group.'''
    longdesc = '''For bank switching (from bank 'a' to bank 'b'), the minimum time is this value + 1. Program this to (tCCD_S/2) and round it up to the next integer value. Unit: clocks.'''
  [[register.field]]
    name = "T_RRD_S"
    bits = "11:8"
    type = "rw"
    shortdesc = '''DDR4: tRRD_S: Minimum time between activates from bank 'a' to bank 'b' for different bank group.'''
    longdesc = '''Program this to (tRRD_S/2) and round it up to the next integer value. Unit: Clocks.'''
  [[register.field]]
    name = "WR2RD_S"
    bits = "5:0"
    type = "rw"
    shortdesc = '''DDR4: CWL + PL + BL/2 + tWTR_S Minimum time from write command to read command for different bank group.'''
    longdesc = '''Includes time for bus turnaround, recovery times, and all per-bank, per-rank, and global constraints. Unit: Clocks. Where: - CWL = CAS write latency - PL = Parity latency - BL = burst length. This must match the value programmed in the BL bit of the mode register to the SDRAM - tWTR_S = internal write to read command delay for different bank group. This comes directly from the SDRAM specification. Divide the value calculated using the above equation by 2, and round it up to next integer. Programming Mode: Quasi-dynamic Group 1, Group 2, and Group 4'''
[[register]]
  name = "DRAMTMG11_SHADOW"
  type = "rw"
  width = 32
  description = "SDRAM Timing Shadow Register 11"
  default = "0x440C021C"
  offset = "0x0000212C"
  [[register.field]]
    name = "POST_MPSM_GAP_X32"
    bits = "30:24"
    type = "rw"
    shortdesc = '''DDR4: tXMPDLL: This is the minimum Exit MPSM to commands requiring a locked DLL.'''
    longdesc = '''Program this to (tXMPDLL/2) and round it up to the next integer value. Unit: Multiples of 32 clocks.'''
  [[register.field]]
    name = "T_MPX_LH"
    bits = "20:16"
    type = "rw"
    shortdesc = '''DDR4: tMPX_LH: This is the minimum CS_n Low hold time to CKE rising edge.'''
    longdesc = '''Program this to RoundUp(tMPX_LH/2)+1. Unit: clocks.'''
  [[register.field]]
    name = "T_MPX_S"
    bits = "9:8"
    type = "rw"
    shortdesc = '''DDR4: tMPX_S: Minimum time CS setup time to CKE.'''
    longdesc = '''Program this to (tMPX_S/2) and round it up to the next integer value. Unit: Clocks.'''
  [[register.field]]
    name = "T_CKMPE"
    bits = "4:0"
    type = "rw"
    shortdesc = '''DDR4: tCKMPE: Minimum valid clock requirement after MPSM entry.'''
    longdesc = '''Unit: Clocks. Divide the value calculated using the above equation by 2, and round it up to next integer.'''
[[register]]
  name = "DRAMTMG12_SHADOW"
  type = "rw"
  width = 32
  description = "SDRAM Timing Shadow Register 12"
  default = "0x00020610"
  offset = "0x00002130"
  [[register.field]]
    name = "T_CMDCKE"
    bits = "17:16"
    type = "rw"
    shortdesc = '''tCMDCKE: Delay from valid command to CKE input LOW.'''
    longdesc = '''Set this to the larger of tESCKE or tCMDCKE Program this to (max(tESCKE, tCMDCKE)/2) and round it up to next integer value.'''
  [[register.field]]
    name = "T_CKEHCMD"
    bits = "11:8"
    type = "rw"
    shortdesc = '''tCKEHCMD: Valid command requirement after CKE input HIGH.'''
    longdesc = '''Program this to (tCKEHCMD/2) and round it up to next integer value.'''
  [[register.field]]
    name = "T_MRD_PDA"
    bits = "4:0"
    type = "rw"
    shortdesc = '''tMRD_PDA: This is the Mode Register Set command cycle time in PDA mode.'''
    longdesc = '''Program this to (tMRD_PDA/2) and round it up to next integer value.'''
[[register]]
  name = "DRAMTMG13_SHADOW"
  type = "rw"
  width = 32
  description = "SDRAM Timing Shadow Register 13"
  default = "0x1C200004"
  offset = "0x00002134"
  [[register.field]]
    name = "ODTLOFF"
    bits = "30:24"
    type = "rw"
    shortdesc = '''LPDDR4: tODTLoff: This is the latency from CAS-2 command to tODToff reference.'''
    longdesc = '''Program this to (tODTLoff/2) and round it up to next integer value. Unit: Clocks.'''
  [[register.field]]
    name = "T_CCD_MW"
    bits = "21:16"
    type = "rw"
    shortdesc = '''LPDDR4: tCCDMW: This is the minimum time from write or masked write to masked write command for same bank.'''
    longdesc = '''Program this to (tCCDMW/2) and round it up to next integer value. Unit: Clocks.'''
  [[register.field]]
    name = "T_PPD"
    bits = "2:0"
    type = "rw"
    shortdesc = '''LPDDR4: tPPD: This is the minimum time from precharge to precharge command.'''
    longdesc = '''Program this to (tPPD/2) and round it up to next integer value. Unit: Clocks.'''
[[register]]
  name = "DRAMTMG14_SHADOW"
  type = "rw"
  width = 32
  description = "SDRAM Timing Shadow Register 14"
  default = "0x000000A0"
  offset = "0x00002138"
  [[register.field]]
    name = "T_XSR"
    bits = "11:0"
    type = "rw"
    shortdesc = '''tXSR: Exit Self Refresh to any command.'''
    longdesc = '''Program this to the above value divided by 2 and round up to next integer value. Note: Used only for LPDDR3/LPDDR4 mode.'''
[[register]]
  name = "ZQCTL0_SHADOW"
  type = "rw"
  width = 32
  description = "ZQ Control Shadow Register 0"
  default = "0x02000040"
  offset = "0x00002180"
  [[register.field]]
    name = "DIS_AUTO_ZQ"
    bits = "31"
    type = "rw"
    shortdesc = '''- 1 - Disable DDRC generation of ZQCS/MPC(ZQ calibration) command.'''
    longdesc = '''Register DBGCMD.zq_calib_short can be used instead to issue ZQ calibration request from APB module. - 0 - Internally generate ZQCS/MPC(ZQ calibration) commands based on ZQCTL1.t_zq_short_interval_x1024. Programming Mode: Dynamic'''
  [[register.field]]
    name = "DIS_SRX_ZQCL"
    bits = "30"
    type = "rw"
    shortdesc = '''- 1 - Disable issuing of ZQCL/MPC(ZQ calibration) command at Self-Refresh exit.'''
    longdesc = '''- 0 - Enable issuing of ZQCL/MPC(ZQ calibration) command at Self-Refresh exit. Programming Mode: Quasi-dynamic Group 2 and Group 4'''
  [[register.field]]
    name = "ZQ_RESISTOR_SHARED"
    bits = "29"
    type = "rw"
    shortdesc = '''- 1 - Denotes that ZQ resistor is shared between ranks.'''
    longdesc = '''Means ZQinit/ZQCL/ZQCS/MPC(ZQ calibration) commands are sent to one rank at a time with tZQinit/tZQCL/tZQCS/tZQCAL/tZQLAT timing met between commands so that commands to different ranks do not overlap. - 0 - ZQ resistor is not shared.'''
  [[register.field]]
    name = "DIS_MPSMX_ZQCL"
    bits = "28"
    type = "rw"
    shortdesc = '''- 1 - Disable issuing of ZQCL command at Maximum Power Saving Mode exit.'''
    longdesc = '''Only applicable when run in DDR4 mode. - 0 - Enable issuing of ZQCL command at Maximum Power Saving Mode exit. Only applicable when run in DDR4 mode.'''
  [[register.field]]
    name = "T_ZQ_LONG_NOP"
    bits = "26:16"
    type = "rw"
    shortdesc = '''tZQoper for DDR3/DDR4, tZQCL for LPDDR3, tZQCAL for LPDDR4: Number of cycles of NOP required after a ZQCL (ZQ calibration long)/MPC(ZQ Start) command is issued to SDRAM.'''
    longdesc = '''DDR3/DDR4: program this to tZQoper/2 and round it up to the next integer value. LPDDR3: program this to tZQCL/2 and round it up to the next integer value. LPDDR4: program this to tZQCAL/2 and round it up to the next integer value. Unit: Clock cycles.'''
  [[register.field]]
    name = "T_ZQ_SHORT_NOP"
    bits = "9:0"
    type = "rw"
    shortdesc = '''tZQCS for DDR3/DD4/LPDDR3, tZQLAT for LPDDR4: Number of cycles of NOP required after a ZQCS (ZQ calibration short)/MPC(ZQ Latch) command is issued to SDRAM.'''
    longdesc = '''Program this to tZQCS/2 and round it up to the next integer value. Unit: Clock cycles.'''
[[register]]
  name = "DFITMG0_SHADOW"
  type = "rw"
  width = 32
  description = "DFI Timing Shadow Register 0"
  default = "0x07020002"
  offset = "0x00002190"
  [[register.field]]
    name = "DFI_T_CTRL_DELAY"
    bits = "28:24"
    type = "rw"
    shortdesc = '''Specifies the number of DFI clock cycles after an assertion or de-assertion of the DFI control signals that the control signals at the PHY-DRAM interface reflect the assertion or de-assertion.'''
    longdesc = '''If the DFI clock and the memory clock are not phase-aligned, this timing parameter should be rounded up to the next integer value. Note that if using RDIMM, it is necessary to increment this parameter by RDIMM's extra cycle of latency in terms of DFI clock. Programming Mode: Quasi-dynamic Group 4'''
  [[register.field]]
    name = "DFI_RDDATA_USE_SDR"
    bits = "23"
    type = "rw"
    shortdesc = '''Defines whether dfi_rddata_en/dfi_rddata/dfi_rddata_valid is generated using HDR or SDR values Selects whether value in DFITMG0.'''
    longdesc = '''dfi_t_rddata_en is in terms of SDR or HDR clock cycles: - 0 in terms of HDR clock cycles - 1 in terms of SDR clock cycles This should be set to 1.'''
  [[register.field]]
    name = "DFI_T_RDDATA_EN"
    bits = "21:16"
    type = "rw"
    shortdesc = '''Time from the assertion of a read command on the DFI interface to the assertion of the dfi_rddata_en signal.'''
    longdesc = '''For DDR3 and DDR4, set to RL-4. For LPDDR3, set to RL+int(1.5/clock_period)-4. For LPDDR4 with speed bin >= 1600, set to RL+int(1.5/clock_period)-4. For LPDDR4 with speed bin < 1600, set to RL-3. This corresponds to the DFI parameter trddata_en. Unit: Clocks Programming Mode: Quasi-dynamic Group 1 and Group 4'''
  [[register.field]]
    name = "DFI_WRDATA_USE_SDR"
    bits = "15"
    type = "rw"
    shortdesc = '''Defines whether dfi_wrdata_en/dfi_wrdata/dfi_wrdata_mask is generated using HDR or SDR values Selects whether value in DFITMG0.'''
    longdesc = '''dfi_tphy_wrlat is in terms of SDR or HDR clock cycles Selects whether value in DFITMG0.dfi_tphy_wrdata is in terms of SDR or HDR clock cycles - 0 in terms of HDR clock cycles - 1 in terms of SDR clock cycles This should be set to 1.'''
  [[register.field]]
    name = "DFI_TPHY_WRDATA"
    bits = "13:8"
    type = "rw"
    shortdesc = '''Specifies the number of clock cycles between when dfi_wrdata_en is asserted to when the associated write data is driven on the dfi_wrdata signal.'''
    longdesc = '''This corresponds to the DFI timing parameter tphy_wrdata. This should be set to 2. Note, max supported value is 8. Unit: Clocks Programming Mode: Quasi-dynamic Group 4'''
  [[register.field]]
    name = "DFI_TPHY_WRLAT"
    bits = "5:0"
    type = "rw"
    shortdesc = '''Write latency Number of clocks from the write command to write data enable (dfi_wrdata_en).'''
    longdesc = '''This corresponds to the DFI timing parameter tphy_wrlat. This should be set to WL-3 for DDR3 and DDR4 component and SODIMM designs. It should be set to WL-2 for LPDDR3 and LPDDR4 designs as well as DDR3 and DDR4 RDIMM designs. Programming Mode: Quasi-dynamic Group 1 and Group 4'''
[[register]]
  name = "DFITMG1_SHADOW"
  type = "rw"
  width = 32
  description = "DFI Timing Shadow Register 1"
  default = "0x00000404"
  offset = "0x00002194"
  [[register.field]]
    name = "DFI_T_CMD_LAT"
    bits = "31:28"
    type = "rw"
    shortdesc = '''Specifies the number of DFI PHY clocks between when the dfi_cs signal is asserted and when the associated command is driven.'''
    longdesc = '''This field is used for CAL mode, should be set to '0' or the value which matches the CAL mode register setting in the DRAM. If the PHY can add the latency for CAL mode, this should be set to '0'. Valid Range: 0, 3, 4, 5, 6, and 8 Programming Mode: Quasi-dynamic Group 2 and Group 4'''
  [[register.field]]
    name = "DFI_T_PARIN_LAT"
    bits = "25:24"
    type = "rw"
  [[register.field]]
    name = "DFI_T_WRDATA_DELAY"
    bits = "20:16"
    type = "rw"
    shortdesc = '''Specifies the number of DFI clocks between when the dfi_wrdata_en signal is asserted and when the corresponding write data transfer is completed on the DRAM bus.'''
    longdesc = '''This corresponds to the DFI timing parameter twrdata_delay. Set to twrdata_delay, a new timing parameter introduced in DFI 3.0. Value to be programmed is in terms of DFI clocks, not PHY clocks. Divide PHY's value by 2 and round up to next integer. If using DFITMG0.dfi_wrdata_use_sdr=1, add 1 to the value. For DDR4 and LPDDR4, this should be set to 3. For DDR3 and LPDDR3, this should be set to 2. Unit: Clocks'''
  [[register.field]]
    name = "DFI_T_DRAM_CLK_DISABLE"
    bits = "11:8"
    type = "rw"
    shortdesc = '''Specifies the number of DFI clock cycles from the assertion of the dfi_dram_clk_disable signal on the DFI until the clock to the DRAM memory devices, at the PHY-DRAM boundary, maintains a low value.'''
    longdesc = '''If the DFI clock and the memory clock are not phase aligned, this timing parameter should be rounded up to the next integer value.'''
  [[register.field]]
    name = "DFI_T_DRAM_CLK_ENABLE"
    bits = "3:0"
    type = "rw"
    shortdesc = '''Specifies the number of DFI clock cycles from the de-assertion of the dfi_dram_clk_disable signal on the DFI until the first valid rising edge of the clock to the DRAM memory devices, at the PHY-DRAM boundary.'''
    longdesc = '''If the DFI clock and the memory clock are not phase aligned, this timing parameter should be rounded up to the next integer value.'''
[[register]]
  name = "DFITMG2_SHADOW"
  type = "rw"
  width = 32
  description = "DFI Timing Shadow Register 2"
  default = "0x00000202"
  offset = "0x000021B4"
  [[register.field]]
    name = "DFI_TPHY_RDCSLAT"
    bits = "13:8"
    type = "rw"
    shortdesc = '''>Number of clocks between when a read command is sent on the DFI control interface and when the associated dfi_rddata_cs signal is asserted.'''
    longdesc = '''This corresponds to the DFI timing parameter tphy_rdcslat. This should be set to dfi_t_rddata_en - 2.'''
  [[register.field]]
    name = "DFI_TPHY_WRCSLAT"
    bits = "5:0"
    type = "rw"
    shortdesc = '''Number of clocks between when a write command is sent on the DFI control interface and when the associated dfi_wrdata_cs signal is asserted.'''
    longdesc = '''This corresponds to the DFI timing parameter tphy_wrcslat. For non-RDIMM systems, this should be set to dfi_tphy_wrlat-5. For RDIMM systems, this should be set to 2.'''
[[register]]
  name = "ODTCFG_SHADOW"
  type = "rw"
  width = 32
  description = "ODT Configuration Shadow Register"
  default = "0x04000400"
  offset = "0x00002240"
  [[register.field]]
    name = "WR_ODT_HOLD"
    bits = "27:24"
    type = "rw"
    shortdesc = '''Cycles to hold ODT for a write command.'''
    longdesc = '''The minimum supported value is 2. Recommended values: DDR3: - BL8: 0x6 DDR4: - BL8: 5 + WR_PREAMBLE + CRC_MODE WR_PREAMBLE = 1 (1tCK write preamble), 2 (2tCK write preamble) CRC_MODE = 0 (not CRC mode), 1 (CRC mode) LPDDR3: - BL8: 7 + RU(tODTon(max)/tCK)'''
  [[register.field]]
    name = "WR_ODT_DELAY"
    bits = "20:16"
    type = "rw"
    shortdesc = '''The delay, in clock cycles, from issuing a write command to setting ODT values associated with that command.'''
    longdesc = '''ODT setting must remain constant for the entire time that DQS is driven by the DDRC. Recommended values: DDR3: - 0x0 DDR4: - DFITMG1.dfi_t_cmd_lat (to adjust for CAL mode) LPDDR3: - WL - 1 - RU(tODTon(max)/tCK))'''
  [[register.field]]
    name = "RD_ODT_HOLD"
    bits = "11:8"
    type = "rw"
    shortdesc = '''Cycles to hold ODT for a read command.'''
    longdesc = '''The minimum supported value is 2. Recommended values: DDR3: - BL8 - 0x6 DDR4: - BL8: 5 + RD_PREAMBLE RD_PREAMBLE = 1 (1tCK write preamble), 2 (2tCK write preamble) LPDDR3: - BL8: 5 + RU(tDQSCK(max)/tCK) - RD(tDQSCK(min)/tCK) + RU(tODTon(max)/tCK)'''
  [[register.field]]
    name = "RD_ODT_DELAY"
    bits = "6:2"
    type = "rw"
    shortdesc = '''The delay, in clock cycles, from issuing a read command to setting ODT values associated with that command.'''
    longdesc = '''ODT setting must remain constant for the entire time that DQS is driven by the DDRC. Recommended values: DDR3: - CL - CWL DDR4: - CL - CWL - RD_PREAMBLE + WR_PREAMBLE + DFITMG1.dfi_t_cmd_lat (to adjust for CAL mode) WR_PREAMBLE = 1 (1tCK write preamble), 2 (2tCK write preamble) RD_PREAMBLE = 1 (1tCK write preamble), 2 (2tCK write preamble) If (CL - CWL - RD_PREAMBLE + WR_PREAMBLE) < 0, DDRC does not support ODT for read operation. LPDDR3: - RL + RD(tDQSCK(min)/tCK) - 1 - RU(tODTon(max)/tCK)'''
