description = "Cortex-A53 built-in debug logic, A53 Debug Logic"
[[register]]
  name = "EDESR"
  type = "rw"
  width = 32
  description = "External Debug Event Status Register"
  default = "0x00000000"
  offset = "0x00000020"
  [[register.field]]
    name = "SS"
    bits = "2"
    type = "rw"
    shortdesc = '''Halting step debug event pending.'''
    longdesc = '''Possible values of this field are:'''
  [[register.field]]
    name = "RC"
    bits = "1"
    type = "rw"
    shortdesc = '''Reset catch debug event pending.'''
    longdesc = '''Possible values of this field are:'''
  [[register.field]]
    name = "OSUC"
    bits = "0"
    type = "rw"
    shortdesc = '''OS unlock debug event pending.'''
    longdesc = '''Possible values of this field are:'''
[[register]]
  name = "EDECR"
  type = "rw"
  width = 32
  description = "External Debug Execution Control Register"
  default = "0x00000000"
  offset = "0x00000024"
  [[register.field]]
    name = "SS"
    bits = "2"
    type = "rw"
    shortdesc = '''Halting step enable.'''
    longdesc = '''Possible values of this field are:If the value of EDECR.SS is changed when the processor is in Non-debug state, the resulting value of EDECR.SS is UNKNOWN.'''
  [[register.field]]
    name = "RCE"
    bits = "1"
    type = "rw"
    shortdesc = '''Reset catch enable.'''
    longdesc = '''Possible values of this field are:'''
  [[register.field]]
    name = "OSUCE"
    bits = "0"
    type = "rw"
    shortdesc = '''OS unlock catch enabled.'''
    longdesc = '''Possible values of this field are:'''
[[register]]
  name = "EDWAR_31TO0"
  type = "ro"
  width = 32
  description = "External Debug Watchpoint Address Register (low word)"
  default = "0x00000000"
  offset = "0x00000030"
  [[register.field]]
    name = "EDWAR_31TO0"
    bits = "31:0"
    type = "ro"
    shortdesc = '''Watchpoint address.'''
    longdesc = '''The virtual data address being accessed when a watchpoint debug event was triggered and caused entry to Debug state.UNKNOWN if the processor is not in Debug state, or if Debug state was entered other than for a watchpoint debug event.The address must be within a naturally-aligned block of memory of power-of-two size no larger than the DC ZVA block size.'''
[[register]]
  name = "EDWAR_63TO32"
  type = "ro"
  width = 32
  description = "External Debug Watchpoint Address Register (high word)"
  default = "0x00000000"
  offset = "0x00000034"
  [[register.field]]
    name = "EDWAR_63TO32"
    bits = "31:0"
    type = "ro"
    shortdesc = '''Watchpoint address.'''
    longdesc = '''The virtual data address being accessed when a watchpoint debug event was triggered and caused entry to Debug state.UNKNOWN if the processor is not in Debug state, or if Debug state was entered other than for a watchpoint debug event.The address must be within a naturally-aligned block of memory of power-of-two size no larger than the DC ZVA block size.'''
[[register]]
  name = "DBGDTRRX_EL0"
  type = "rw"
  width = 32
  description = "Debug Data Transfer Register Receive"
  default = "0x00000000"
  offset = "0x00000080"
  [[register.field]]
    name = "DBGDTRRX_EL0"
    bits = "31:0"
    type = "rw"
    shortdesc = '''Update DTRRX.'''
    longdesc = '''Writes to this register update the value in DTRRX and set RXfull to 1.Reads of this register return the last value written to DTRRX and do not change RXfull.'''
[[register]]
  name = "EDITR"
  type = "wo"
  width = 32
  description = "External Debug Instruction Transfer Register"
  default = "0x00000000"
  offset = "0x00000084"
  [[register.field]]
    name = "T32SECOND"
    bits = "31:16"
    type = "wo"
  [[register.field]]
    name = "EDITR"
    bits = "31:0"
    type = "wo"
  [[register.field]]
    name = "T32FIRST"
    bits = "15:0"
    type = "wo"
[[register]]
  name = "EDSCR"
  type = "rw"
  width = 32
  description = "External Debug Status and Control Register"
  default = "0x00000000"
  offset = "0x00000088"
  [[register.field]]
    name = "RXFULL"
    bits = "30"
    type = "rw"
    shortdesc = '''DTRRX full.'''
    longdesc = '''This bit is RO.'''
  [[register.field]]
    name = "TXFULL"
    bits = "29"
    type = "rw"
    shortdesc = '''DTRTX full.'''
    longdesc = '''This bit is RO.'''
  [[register.field]]
    name = "ITO"
    bits = "28"
    type = "rw"
    shortdesc = '''EDITR overrun.'''
    longdesc = '''This bit is RO.If the processor is not in Debug state, this bit is UNKNOWN. ITO is set to 0 on entry to Debug state.'''
  [[register.field]]
    name = "RXO"
    bits = "27"
    type = "rw"
    shortdesc = '''DTRRX overrun.'''
    longdesc = '''This bit is RO.'''
  [[register.field]]
    name = "TXU"
    bits = "26"
    type = "rw"
    shortdesc = '''DTRTX underrun.'''
    longdesc = '''This bit is RO.'''
  [[register.field]]
    name = "PIPEADV"
    bits = "25"
    type = "rw"
    shortdesc = '''Pipeline advance.'''
    longdesc = '''Read-only. Set to 1 every time the processor pipeline retires one or more instructions. Cleared to 0 by a write to EDRCR.CSPA.The architecture does not define precisely when this bit is set to 1. It requires only that this happen periodically in Non-debug state to indicate that software execution is progressing.'''
  [[register.field]]
    name = "ITE"
    bits = "24"
    type = "rw"
    shortdesc = '''ITR empty.'''
    longdesc = '''This bit is RO.If the processor is not in Debug state, this bit is UNKNOWN. It is always valid in Debug state.'''
  [[register.field]]
    name = "INTDIS"
    bits = "23:22"
    type = "rw"
    shortdesc = '''Interrupt disable.'''
    longdesc = '''Disables taking interrupts (including virtual interrupts and System Error interrupts) in Non-Debug state.If external invasive debug is disabled, the value of this field is ignored.If external invasive debug is enabled, the possible values of this field are:The value of INTdis does not affect whether an interrupt is a WFI wake-up event, but can mask an interrupt as a WFE wake-up event.If EL3 and EL2 are not implemented, INTdis[0] is RO and reads the same value as INTdis[1], meaning only the values 0b00 and 0b11 can be selected.'''
  [[register.field]]
    name = "TDA"
    bits = "21"
    type = "rw"
  [[register.field]]
    name = "MA"
    bits = "20"
    type = "rw"
    shortdesc = '''Memory access mode.'''
    longdesc = '''Controls use of memory-access mode for accessing EDITR and the DCC. This bit is ignored if in Non-debug state and set to zero on entry to Debug state.Possible values of this field are:'''
  [[register.field]]
    name = "NS"
    bits = "18"
    type = "rw"
    shortdesc = '''Non-secure status.'''
    longdesc = '''Read-only. When in Debug state, gives the current security state:In Non-debug state, this bit is UNKNOWN.'''
  [[register.field]]
    name = "SDD"
    bits = "16"
    type = "rw"
    shortdesc = '''Secure debug disabled.'''
    longdesc = '''This bit is RO.On entry to Debug state:If entering in Secure state, SDD is set to 0.If entering in Non-secure state, SDD is set to the inverse of ExternalSecureInvasiveDebugEnabled().In Debug state, the value of the SDD bit does not change, even if ExternalSecureInvasiveDebugEnabled() changes.In Non-debug state:SDD returns the inverse of ExternalSecureInvasiveDebugEnabled(). If the authentication signals that control ExternalSecureInvasiveDebugEnabled() change, a context synchronization operation is required to guarantee their effect.This bit is unaffected by the Security state of the processor.If EL3 is not implemented and the implementation is Non-secure, this bit is RES1.'''
  [[register.field]]
    name = "HDE"
    bits = "14"
    type = "rw"
    shortdesc = '''Halting debug mode enable.'''
    longdesc = '''Possible values of this bit are:'''
  [[register.field]]
    name = "RW"
    bits = "13:10"
    type = "rw"
    shortdesc = '''Exception level register-width status.'''
    longdesc = '''Read-only. In Debug state, each bit gives the current register width status of each EL:However:If not at EL0: RW[0] == RW[1].If EL2 is not implemented in the current security state: RW[2] == RW[1].If EL3 is not implemented: RW[3] == RW[2].In Non-debug state, this field is RAO.'''
  [[register.field]]
    name = "EL"
    bits = "9:8"
    type = "rw"
    shortdesc = '''Exception level.'''
    longdesc = '''Read-only. In Debug state, this gives the current EL of the processor.In Non-debug state, this field is RAZ.'''
  [[register.field]]
    name = "A"
    bits = "7"
    type = "rw"
    shortdesc = '''System Error interrupt pending.'''
    longdesc = '''Read-only. In Debug state, indicates whether a SError interrupt is pending:If HCR_EL2.{AMO, TGE} = {1, 0} and in Non-secure EL0 or EL1, a virtual SError interrupt.Otherwise, a physical SError interrupt.A debugger can read EDSCR to check whether a SError interrupt is pending without having to execute further instructions. A pending SError might indicate data from target memory is corrupted.UNKNOWN in Non-debug state.'''
  [[register.field]]
    name = "ERR"
    bits = "6"
    type = "rw"
    shortdesc = '''Cumulative error flag.'''
    longdesc = '''This field is RO. It is set to 1 following exceptions in Debug state and on any signaled overrun or underrun on the DTR or EDITR.'''
  [[register.field]]
    name = "STATUS"
    bits = "5:0"
    type = "rw"
    shortdesc = '''Debug status flags.'''
    longdesc = '''This field is RO.The possible values of this field are:All other values of STATUS are reserved.'''
[[register]]
  name = "DBGDTRTX_EL0"
  type = "rw"
  width = 32
  description = "Debug Data Transfer Register Transmit"
  default = "0x00000000"
  offset = "0x0000008C"
  [[register.field]]
    name = "DBGDTRTX_EL0"
    bits = "31:0"
    type = "rw"
    shortdesc = '''Return DTRTX.'''
    longdesc = '''Reads of this register return the value in DTRTX and clear TXfull to 0.Writes of this register update the value in DTRTX and do not change TXfull.'''
[[register]]
  name = "EDRCR"
  type = "wo"
  width = 32
  description = "External Debug Reserve Control Register"
  default = "0x00000000"
  offset = "0x00000090"
  [[register.field]]
    name = "CBRRQ"
    bits = "4"
    type = "wo"
    shortdesc = '''Allow imprecise entry to Debug state.'''
    longdesc = '''The actions on writing to this bit are:Setting this bit to 1 allows a debugger to request imprecise entry to Debug state. An External Debug Request debug event must be pending before the debugger sets this bit to 1.This feature is optional. If this feature is not implemented, writes to this bit are ignored.'''
  [[register.field]]
    name = "CSPA"
    bits = "3"
    type = "wo"
    shortdesc = '''Clear Sticky Pipeline Advance.'''
    longdesc = '''This bit is used to clear the EDSCR.PipeAdv bit to 0. The actions on writing to this bit are:'''
  [[register.field]]
    name = "CSE"
    bits = "2"
    type = "wo"
    shortdesc = '''Clear Sticky Error.'''
    longdesc = '''Used to clear the EDSCR cumulative error bits to 0. The actions on writing to this bit are:'''
[[register]]
  name = "EDECCR"
  type = "rw"
  width = 32
  description = "External Debug Exception Catch Control Register"
  default = "0x00000000"
  offset = "0x00000098"
  [[register.field]]
    name = "NSE"
    bits = "7:4"
    type = "rw"
    shortdesc = '''Coarse-grained Non-secure exception catch.'''
    longdesc = '''Possible values of this field are:All other values are reserved. Bits [7,4] are reserved, RES0.'''
  [[register.field]]
    name = "SE"
    bits = "3:0"
    type = "rw"
    shortdesc = '''Coarse-grained Secure exception catch.'''
    longdesc = '''Possible values of this field are:All other values are reserved. Bits [2,0] are reserved. RES0. Ignored if ExternalSecureInvasiveDebugEnabled() == FALSE.'''
[[register]]
  name = "EDPCSR_31TO0"
  type = "ro"
  width = 32
  description = "External Debug Program Counter Sample Register (low word)"
  default = "0x00000000"
  offset = "0x000000A0"
  [[register.field]]
    name = "EDPCSR_31TO0"
    bits = "31:0"
    type = "ro"
    shortdesc = '''PC Sample low word, EDPCSRlo.'''
    longdesc = '''Bits [31:0] of the sampled instruction address value. Reading EDPCSRlo has the side-effect of updating EDCIDSR, EDVIDSR, and EDPCSRhi. However:If the processor is in Debug state, or Sample-based profiling is prohibited, EDPCSRlo reads as 0xFFFFFFFF and EDCIDSR, EDVIDSR, and EDPCSRhi become UNKNOWN.If the processor is in Reset state, the sampled value is unknown and EDCIDSR, EDVIDSR and EDPCSRhi become UNKNOWN.If no instruction has been retired since the processor left Reset state, Debug state, or a state where Non-invasive debug is not permitted, the sampled value is UNKNOWN and EDCIDSR, EDVIDSR, and EDPCSRhi become UNKNOWN.For a read of EDPCSRlo from the memory-mapped interface, if EDLSR.SLK == 1, meaning the Software Lock is locked, then the access has no side-effects. That is, EDCIDSR, EDVIDSR, and EDPCSRhi are unchanged.'''
[[register]]
  name = "EDCIDSR"
  type = "ro"
  width = 32
  description = "External Debug Context ID Sample Register"
  default = "0x00000000"
  offset = "0x000000A4"
  [[register.field]]
    name = "CONTEXTIDR"
    bits = "31:0"
    type = "ro"
    shortdesc = '''The sampled value of CONTEXTIDR_EL1, captured on reading the low half of EDPCSR.'''
    longdesc = '''If EL3 is implemented and using AArch32 then CONTEXTIDR is a Banked register, and EDCIDSR samples the current Banked copy of CONTEXTIDR.'''
[[register]]
  name = "EDVIDSR"
  type = "ro"
  width = 32
  description = "External Debug Virtual Context Sample Register"
  default = "0x00000000"
  offset = "0x000000A8"
  [[register.field]]
    name = "NS"
    bits = "31"
    type = "ro"
    shortdesc = '''Non-secure state sample.'''
    longdesc = '''Indicates the security state associated with the most recent EDPCSR sample.'''
  [[register.field]]
    name = "E2"
    bits = "30"
    type = "ro"
    shortdesc = '''Exception level 2 status sample.'''
    longdesc = '''Indicates whether the most recent EDPCSR sample was associated with EL2. If EDVIDSR.NS == 0, this bit is 0.'''
  [[register.field]]
    name = "E3"
    bits = "29"
    type = "ro"
    shortdesc = '''Exception level 3 status sample.'''
    longdesc = '''Indicates whether the most recent EDPCSR sample was associated with AArch64 EL3. If EDVIDSR.NS == 1 or the processor was in AArch32 state when EDPCSR was read, this bit is 0.'''
  [[register.field]]
    name = "HV"
    bits = "28"
    type = "ro"
    shortdesc = '''EDPCSR high half valid.'''
    longdesc = '''Indicates whether bits [63:32] of the most recent EDPCSR sample are valid. If EDVIDSR.HV == 0, the value of EDPCSR[63:32] is RAZ.'''
  [[register.field]]
    name = "VMID"
    bits = "7:0"
    type = "ro"
    shortdesc = '''VMID sample.'''
    longdesc = '''The value of VTTBR_EL2.VMID associated with the most recent EDPCSR sample. If EDVIDSR.NS == 0 or EDVIDSR.E2 == 1, this field is RAZ.'''
[[register]]
  name = "EDPCSR_63TO32"
  type = "ro"
  width = 32
  description = "External Debug Program Counter Sample Register (high word)"
  default = "0x00000000"
  offset = "0x000000AC"
  [[register.field]]
    name = "EDPCSR_63TO32"
    bits = "31:0"
    type = "ro"
    shortdesc = '''PC Sample high word, EDPCSRhi.'''
    longdesc = '''If EDVIDSR.HV == 0 then this field is RAZ, otherwise bits [63:32] of the sampled PC.'''
[[register]]
  name = "OSLAR_EL1"
  type = "wo"
  width = 32
  description = "OS Lock Access Register"
  default = "0x00000000"
  offset = "0x00000300"
  [[register.field]]
    name = "OSLK"
    bits = "0"
    type = "wo"
    shortdesc = '''On writes to OSLAR_EL1, bit[0] is copied to the OS lock.'''
    longdesc = '''Use EDPRSR.OSLK to check the current status of the lock.'''
[[register]]
  name = "EDPRCR"
  type = "rw"
  width = 32
  description = "External Debug Power/Reset Control Register"
  default = "0x00000000"
  offset = "0x00000310"
  [[register.field]]
    name = "COREPURQ"
    bits = "3"
    type = "rw"
    shortdesc = '''Core powerup request.'''
    longdesc = '''Allows a debugger to request that the power controller power up the core, enabling access to the debug register in the Core power domain. The actions on writing to this bit are:In an implementation that includes the recommended external debug interface, this bit drives the DBGPWRUPREQ signal.This bit can be read and written when the Core power domain is powered off.The power controller must not allow the Core power domain to switch off while this bit is one.'''
  [[register.field]]
    name = "CWRR"
    bits = "1"
    type = "rw"
    shortdesc = '''Warm reset request.'''
    longdesc = '''Write only bit that reads as zero. The actions on writing to this bit are:The processor ignores writes to this bit if any of the following are the case:ExternalInvasiveDebugEnabled() == FALSE, EL3 is not implemented, and the processor is Non-secure.ExternalSecureInvasiveDebugEnabled() == FALSE and one of the following is true:EL3 is implemented.The processor is Secure.The Core power domain is either completely off or in a low-power state where the Core power domain registers cannot be accessed.DoubleLockStatus() == TRUE (OS Double Lock is set).OSLSR.OSLK == 1 (OS lock is locked).In an implementation that includes the recommended external debug interface, this bit drives the DBGRSTREQ signal.'''
  [[register.field]]
    name = "CORENPDRQ"
    bits = "0"
    type = "rw"
    shortdesc = '''Core no powerdown request.'''
    longdesc = '''Requests emulation of powerdown. Possible values of this bit are:'''
[[register]]
  name = "EDPRSR"
  type = "ro"
  width = 32
  description = "External Debug Processor Status Register"
  default = "0x00000002"
  offset = "0x00000314"
  [[register.field]]
    name = "SDR"
    bits = "11"
    type = "ro"
    shortdesc = '''Sticky debug restart.'''
    longdesc = '''Set to 1 when the processor exits Debug state and cleared to 0 following reads of EDPRSR.This bit is UNKNOWN on reads if either of EDPRSR.{DLK, R} is 1, or EDPRSR.PU is 0.This bit clears to 0 when following a read of EDPRSR.'''
  [[register.field]]
    name = "SPMAD"
    bits = "10"
    type = "ro"
    shortdesc = '''Sticky EPMAD error.'''
    longdesc = '''Set to 1 if an access returns an error because AllowExternalPMUAccess() == FALSE.This bit is UNKNOWN on reads if either of EDPRSR.{DLK, R} is 1, or EDPRSR.PU is 0.This bit clears to 0 when following a read of EDPRSR.'''
  [[register.field]]
    name = "EPMAD"
    bits = "9"
    type = "ro"
    shortdesc = '''External performance monitors access disable status.'''
    longdesc = '''If external performance monitors access is not implemented, EPMAD is RAO. This bit is UNKNOWN on reads if either of EDPRSR.{DLK, R} is 1, or EDPRSR.PU is 0.'''
  [[register.field]]
    name = "SDAD"
    bits = "8"
    type = "ro"
    shortdesc = '''Sticky EDAD error.'''
    longdesc = '''Set to 1 if an access returns an error because AllowExternalDebugAccess() == FALSE.This bit is UNKNOWN on reads if either of EDPRSR.{DLK, R} is 1, or EDPRSR.PU is 0.This bit clears to 0 following a read of EDPRSR.'''
  [[register.field]]
    name = "EDAD"
    bits = "7"
    type = "ro"
    shortdesc = '''External debug access disable status.'''
    longdesc = '''This bit is UNKNOWN on reads if either of EDPRSR.{DLK, R} is 1, or EDPRSR.PU is 0.'''
  [[register.field]]
    name = "DLK"
    bits = "6"
    type = "ro"
    shortdesc = '''OS Double Lock status bit.'''
    longdesc = '''This bit is UNKNOWN on reads if EDPRSR.PU is 0.'''
  [[register.field]]
    name = "OSLK"
    bits = "5"
    type = "ro"
    shortdesc = '''OS lock status bit.'''
    longdesc = '''A read of this bit returns the value of OSLSR_EL1.OSLK.This bit is UNKNOWN on reads if either of EDPRSR.{DLK, R} is 1 or EDPRSR.PU is 0.'''
  [[register.field]]
    name = "HALTED"
    bits = "4"
    type = "ro"
    shortdesc = '''Halted status bit.'''
    longdesc = '''Possible values are:This bit is UNKNOWN on reads if EDPRSR.PU is 0.'''
  [[register.field]]
    name = "SR"
    bits = "3"
    type = "ro"
    shortdesc = '''Sticky core reset status bit.'''
    longdesc = '''Possible values are:This bit is UNKNOWN on reads if EDPRSR.DLK is 1 or EDPRSR.PU is 0.This bit clears to 0 following a read of EDPRSR if the non-debug logic of the processor is not in reset state.'''
  [[register.field]]
    name = "R"
    bits = "2"
    type = "ro"
    shortdesc = '''Core reset status bit.'''
    longdesc = '''Possible values are:This bit is UNKNOWN on reads if either EDPRSR.DLK is 1 or EDPRSR.PU is 0.'''
  [[register.field]]
    name = "SPD"
    bits = "1"
    type = "ro"
    shortdesc = '''Sticky core power-down status bit.'''
    longdesc = '''This bit is set to 1 on Cold reset to indicate the state of the debug registers has been lost. Since a Cold reset is required on powering up the processor, this usually indicates the Core power domain has been completely powered off.Possible values are:This bit is UNKNOWN on reads if both EDPRSR.DLK and EDPRSR.PU are 1.This bit clears to 0 following a read of EDPRSR if the processor is not in the powered down state. There are two logical power off states for the Core power domain:RetentionThe states of the debug registers, including EDPRSR.SPD, in the Core power domain is preserved, and restored on leaving retention state.Power-downThe states of the debug registers in the Core power domain is lost, and a Cold reset is asserted on leaving power-down state.In these states, it is IMPLEMENTATION DEFINED whether:EDPRSR.SPD shows whether the state of the debug registers in the Core power domain has been lost since the last time EDPRSR was read when the Core power domain was on.EDPRSR.SPD reads-as-zero.EDPRSR.SPD is not cleared following a read of EDPRSR in these states.This means it is IMPLEMENTATION DEFINED whether a processor implements EDPRSR.SPD as:Fixed RAZ when in one or both of the retention and power-down states.Retaining its previous value when in the retention state.Fixed RAO in the power-down state.Note that this definition does not allow EDPRSR.SPD to be fixed RAO in the low-power retention state, as the state of the debug registers in the Core power domain is not lost by entering this state. However, the bit can be read as 1 in this state if the state of the registers was lost before entering this state (i.e. EDPRSR has not been read since the last Cold reset).ARM recommends that an implementation make EDPRSR.SPD fixed RAO when in the power-down state, particularly if it does not support a low-power retention state.'''
  [[register.field]]
    name = "PU"
    bits = "0"
    type = "ro"
    shortdesc = '''Core power-up status bit.'''
    longdesc = '''Indicates whether the Core power domain debug registers can be accessed:'''
[[register]]
  name = "DBGBVR0_EL1_31TO0"
  type = "rw"
  width = 32
  description = "Debug Breakpoint Value Registers. Holds a virtual address or a VMID and/or a context ID for use in breakpoint matching. Forms breakpoint n together with control register DBGBCR<n>_EL1 where n is 0 to 15. Multiple uses of this register refer to ARMv8"
  default = "0x00000000"
  offset = "0x00000400"
  [[register.field]]
    name = "VA"
    bits = "31:2"
    type = "rw"
    shortdesc = '''Bits[48:2] of the address value for comparison.'''
    longdesc = '''ARM deprecates setting DBGWVR<n>_EL1[2] == 1.'''
[[register]]
  name = "DBGBVR0_EL1_63TO32"
  type = "rw"
  width = 32
  description = "Debug Breakpoint Extended Value Registers. Holds a virtual address or a VMID and/or a context ID for use in breakpoint matching. Forms breakpoint n together with control register DBGBCR<n>_EL1 where n is 0 to 15. Multiple uses of this register refer to ARMv8"
  default = "0x00000000"
  offset = "0x00000404"
  [[register.field]]
    name = "RESS"
    bits = "31:17"
    type = "rw"
    shortdesc = '''Reserved, Sign extended.'''
    longdesc = '''Hardwired to the value of the sign bit, bit [48]. Hardware and software must treat this field as RES0 if bit[48] is 0, and as RES1 if bit[48] is 1.'''
  [[register.field]]
    name = "VA"
    bits = "16:0"
    type = "rw"
    shortdesc = '''Bits[48:2] of the address value for comparison.'''
    longdesc = '''ARM deprecates setting DBGWVR<n>_EL1[2] == 1.'''
[[register]]
  name = "DBGBCR0_EL1"
  type = "rw"
  width = 32
  description = "Debug Breakpoint Control Registers"
  default = "0x00000000"
  offset = "0x00000408"
  [[register.field]]
    name = "BT"
    bits = "23:20"
    type = "rw"
    shortdesc = '''Breakpoint Type.'''
    longdesc = '''Possible values are:The field breaks down as follows:BT[3:1]: Base type.000Match address. DBGBVR<n>_EL1 is the address of an instruction.010Mismatch address. Behaves as type 0b000 if in an AArch64 translation, or if halting debug-mode is enabled and halting is allowed. Otherwise, DBGBVR<n>_EL1 is the address of an instruction to be stepped.001Match context ID. DBGBVR<n>_EL1[31:0] is a context ID.100Match VMID. DBGBVR<n>_EL1[39:32] is a VMID.101Match VMID and context ID. DBGBVR<n>_EL1[31:0] is a context ID, and DBGBVR<n>_EL1[39:32] is a VMID.BT[0]: Enable linking.If the breakpoint is not context-aware, BT[3] and BT[1] are RES0. If EL2 is not implemented, BT[3] is RES0. If EL1 using AArch32 is not implemented, BT[2] is RES0.The values 011x and 11xx are reserved, but must behave as if the breakpoint is disabled. Software must not rely on this property as the behavior of reserved values might change in a future revision of the architecture.'''
  [[register.field]]
    name = "LBN"
    bits = "19:16"
    type = "rw"
    shortdesc = '''Linked breakpoint number.'''
    longdesc = '''For Linked address matching breakpoints, this specifies the index of the Context-matching breakpoint linked to.'''
  [[register.field]]
    name = "SSC"
    bits = "15:14"
    type = "rw"
    shortdesc = '''Security state control.'''
    longdesc = '''Determines the security states under which a breakpoint debug event for breakpoint n is generated. This field must be interpreted along with the HMC and PMC fields.'''
  [[register.field]]
    name = "HMC"
    bits = "13"
    type = "rw"
    shortdesc = '''Higher mode control.'''
    longdesc = '''Determines the debug perspective for deciding when a breakpoint debug event for breakpoint n is generated. This field must be interpreted along with the SSC and PMC fields.'''
  [[register.field]]
    name = "BAS"
    bits = "8:5"
    type = "rw"
    shortdesc = '''Byte address select.'''
    longdesc = '''Defines which half-words an address-matching breakpoint matches, regardless of the instruction set and execution state. In an AArch64-only implementation, this field is reserved, RES1. Otherwise:BAS[2] and BAS[0] are read/write.BAS[3] and BAS[1] are read-only copies of BAS[2] and BAS[0] respectively.The values 0b0011 and 0b1100 are only supported if AArch32 is supported at any exception level.The permitted values depend on the breakpoint type.For Address match breakpoints in either AArch32 or AArch64 state:BASMatch instruction atConstraint for debuggers0b0011DBGBVR<n>_EL1Use for T32 and T32EE instructions.0b1100DBGBVR<n>_EL1+2Use for T32 and T32EE instructions.0b1111DBGBVR<n>_EL1Use for A64 and A32 instructions.0b0000 is reserved and must behave as if the breakpoint is disabled or map to a permitted value.For Address mismatch breakpoints in an AArch32 stage 1 translation regime:BASStep instruction atConstraint for debuggers0b0000-Use for a match anywhere breakpoint.0b0011DBGBVR<n>_EL1Use for stepping T32 and T32EE instructions.0b1100DBGBVR<n>_EL1+2Use for stepping T32 and T32EE instructions.0b1111DBGBVR<n>_EL1Use for stepping A64 and A32 instructions.For Context matching breakpoints, this field is RES1 and ignored.'''
  [[register.field]]
    name = "PMC"
    bits = "2:1"
    type = "rw"
    shortdesc = '''Privilege mode control.'''
    longdesc = '''Determines the exception level or levels at which a breakpoint debug event for breakpoint n is generated. This field must be interpreted along with the SSC and HMC fields.'''
  [[register.field]]
    name = "E"
    bits = "0"
    type = "rw"
    shortdesc = '''Enable breakpoint DBGBVR<n>_EL1.'''
    longdesc = '''Possible values are:'''
[[register]]
  name = "DBGBVR1_EL1_31TO0"
  type = "rw"
  width = 32
  description = "Debug Breakpoint Value Registers. Holds a virtual address or a VMID and/or a context ID for use in breakpoint matching. Forms breakpoint n together with control register DBGBCR<n>_EL1 where n is 0 to 15. Multiple uses of this register refer to ARMv8"
  default = "0x00000000"
  offset = "0x00000410"
  [[register.field]]
    name = "VA"
    bits = "31:2"
    type = "rw"
    shortdesc = '''Bits[48:2] of the address value for comparison.'''
    longdesc = '''ARM deprecates setting DBGWVR<n>_EL1[2] == 1.'''
[[register]]
  name = "DBGBVR1_EL1_63TO32"
  type = "rw"
  width = 32
  description = "Debug Breakpoint Extended Value Registers. Holds a virtual address or a VMID and/or a context ID for use in breakpoint matching. Forms breakpoint n together with control register DBGBCR<n>_EL1 where n is 0 to 15. Multiple uses of this register refer to ARMv8"
  default = "0x00000000"
  offset = "0x00000414"
  [[register.field]]
    name = "RESS"
    bits = "31:17"
    type = "rw"
    shortdesc = '''Reserved, Sign extended.'''
    longdesc = '''Hardwired to the value of the sign bit, bit [48]. Hardware and software must treat this field as RES0 if bit[48] is 0, and as RES1 if bit[48] is 1.'''
  [[register.field]]
    name = "VA"
    bits = "16:0"
    type = "rw"
    shortdesc = '''Bits[48:2] of the address value for comparison.'''
    longdesc = '''ARM deprecates setting DBGWVR<n>_EL1[2] == 1.'''
[[register]]
  name = "DBGBCR1_EL1"
  type = "rw"
  width = 32
  description = "Debug Breakpoint Control Registers"
  default = "0x00000000"
  offset = "0x00000418"
  [[register.field]]
    name = "BT"
    bits = "23:20"
    type = "rw"
    shortdesc = '''Breakpoint Type.'''
    longdesc = '''Possible values are:The field breaks down as follows:BT[3:1]: Base type.000Match address. DBGBVR<n>_EL1 is the address of an instruction.010Mismatch address. Behaves as type 0b000 if in an AArch64 translation, or if halting debug-mode is enabled and halting is allowed. Otherwise, DBGBVR<n>_EL1 is the address of an instruction to be stepped.001Match context ID. DBGBVR<n>_EL1[31:0] is a context ID.100Match VMID. DBGBVR<n>_EL1[39:32] is a VMID.101Match VMID and context ID. DBGBVR<n>_EL1[31:0] is a context ID, and DBGBVR<n>_EL1[39:32] is a VMID.BT[0]: Enable linking.If the breakpoint is not context-aware, BT[3] and BT[1] are RES0. If EL2 is not implemented, BT[3] is RES0. If EL1 using AArch32 is not implemented, BT[2] is RES0.The values 011x and 11xx are reserved, but must behave as if the breakpoint is disabled. Software must not rely on this property as the behavior of reserved values might change in a future revision of the architecture.'''
  [[register.field]]
    name = "LBN"
    bits = "19:16"
    type = "rw"
    shortdesc = '''Linked breakpoint number.'''
    longdesc = '''For Linked address matching breakpoints, this specifies the index of the Context-matching breakpoint linked to.'''
  [[register.field]]
    name = "SSC"
    bits = "15:14"
    type = "rw"
    shortdesc = '''Security state control.'''
    longdesc = '''Determines the security states under which a breakpoint debug event for breakpoint n is generated. This field must be interpreted along with the HMC and PMC fields.'''
  [[register.field]]
    name = "HMC"
    bits = "13"
    type = "rw"
    shortdesc = '''Higher mode control.'''
    longdesc = '''Determines the debug perspective for deciding when a breakpoint debug event for breakpoint n is generated. This field must be interpreted along with the SSC and PMC fields.'''
  [[register.field]]
    name = "BAS"
    bits = "8:5"
    type = "rw"
    shortdesc = '''Byte address select.'''
    longdesc = '''Defines which half-words an address-matching breakpoint matches, regardless of the instruction set and execution state. In an AArch64-only implementation, this field is reserved, RES1. Otherwise:BAS[2] and BAS[0] are read/write.BAS[3] and BAS[1] are read-only copies of BAS[2] and BAS[0] respectively.The values 0b0011 and 0b1100 are only supported if AArch32 is supported at any exception level.The permitted values depend on the breakpoint type.For Address match breakpoints in either AArch32 or AArch64 state:BASMatch instruction atConstraint for debuggers0b0011DBGBVR<n>_EL1Use for T32 and T32EE instructions.0b1100DBGBVR<n>_EL1+2Use for T32 and T32EE instructions.0b1111DBGBVR<n>_EL1Use for A64 and A32 instructions.0b0000 is reserved and must behave as if the breakpoint is disabled or map to a permitted value.For Address mismatch breakpoints in an AArch32 stage 1 translation regime:BASStep instruction atConstraint for debuggers0b0000-Use for a match anywhere breakpoint.0b0011DBGBVR<n>_EL1Use for stepping T32 and T32EE instructions.0b1100DBGBVR<n>_EL1+2Use for stepping T32 and T32EE instructions.0b1111DBGBVR<n>_EL1Use for stepping A64 and A32 instructions.For Context matching breakpoints, this field is RES1 and ignored.'''
  [[register.field]]
    name = "PMC"
    bits = "2:1"
    type = "rw"
    shortdesc = '''Privilege mode control.'''
    longdesc = '''Determines the exception level or levels at which a breakpoint debug event for breakpoint n is generated. This field must be interpreted along with the SSC and HMC fields.'''
  [[register.field]]
    name = "E"
    bits = "0"
    type = "rw"
    shortdesc = '''Enable breakpoint DBGBVR<n>_EL1.'''
    longdesc = '''Possible values are:'''
[[register]]
  name = "DBGBVR2_EL1_31TO0"
  type = "rw"
  width = 32
  description = "Debug Breakpoint Value Registers. Holds a virtual address or a VMID and/or a context ID for use in breakpoint matching. Forms breakpoint n together with control register DBGBCR<n>_EL1 where n is 0 to 15. Multiple uses of this register refer to ARMv8"
  default = "0x00000000"
  offset = "0x00000420"
  [[register.field]]
    name = "VA"
    bits = "31:2"
    type = "rw"
    shortdesc = '''Bits[48:2] of the address value for comparison.'''
    longdesc = '''ARM deprecates setting DBGWVR<n>_EL1[2] == 1.'''
[[register]]
  name = "DBGBVR2_EL1_63TO32"
  type = "rw"
  width = 32
  description = "Debug Breakpoint Extended Value Registers. Holds a virtual address or a VMID and/or a context ID for use in breakpoint matching. Forms breakpoint n together with control register DBGBCR<n>_EL1 where n is 0 to 15. Multiple uses of this register refer to ARMv8"
  default = "0x00000000"
  offset = "0x00000424"
  [[register.field]]
    name = "RESS"
    bits = "31:17"
    type = "rw"
    shortdesc = '''Reserved, Sign extended.'''
    longdesc = '''Hardwired to the value of the sign bit, bit [48]. Hardware and software must treat this field as RES0 if bit[48] is 0, and as RES1 if bit[48] is 1.'''
  [[register.field]]
    name = "VA"
    bits = "16:0"
    type = "rw"
    shortdesc = '''Bits[48:2] of the address value for comparison.'''
    longdesc = '''ARM deprecates setting DBGWVR<n>_EL1[2] == 1.'''
[[register]]
  name = "DBGBCR2_EL1"
  type = "rw"
  width = 32
  description = "Debug Breakpoint Control Registers"
  default = "0x00000000"
  offset = "0x00000428"
  [[register.field]]
    name = "BT"
    bits = "23:20"
    type = "rw"
    shortdesc = '''Breakpoint Type.'''
    longdesc = '''Possible values are:The field breaks down as follows:BT[3:1]: Base type.000Match address. DBGBVR<n>_EL1 is the address of an instruction.010Mismatch address. Behaves as type 0b000 if in an AArch64 translation, or if halting debug-mode is enabled and halting is allowed. Otherwise, DBGBVR<n>_EL1 is the address of an instruction to be stepped.001Match context ID. DBGBVR<n>_EL1[31:0] is a context ID.100Match VMID. DBGBVR<n>_EL1[39:32] is a VMID.101Match VMID and context ID. DBGBVR<n>_EL1[31:0] is a context ID, and DBGBVR<n>_EL1[39:32] is a VMID.BT[0]: Enable linking.If the breakpoint is not context-aware, BT[3] and BT[1] are RES0. If EL2 is not implemented, BT[3] is RES0. If EL1 using AArch32 is not implemented, BT[2] is RES0.The values 011x and 11xx are reserved, but must behave as if the breakpoint is disabled. Software must not rely on this property as the behavior of reserved values might change in a future revision of the architecture.'''
  [[register.field]]
    name = "LBN"
    bits = "19:16"
    type = "rw"
    shortdesc = '''Linked breakpoint number.'''
    longdesc = '''For Linked address matching breakpoints, this specifies the index of the Context-matching breakpoint linked to.'''
  [[register.field]]
    name = "SSC"
    bits = "15:14"
    type = "rw"
    shortdesc = '''Security state control.'''
    longdesc = '''Determines the security states under which a breakpoint debug event for breakpoint n is generated. This field must be interpreted along with the HMC and PMC fields.'''
  [[register.field]]
    name = "HMC"
    bits = "13"
    type = "rw"
    shortdesc = '''Higher mode control.'''
    longdesc = '''Determines the debug perspective for deciding when a breakpoint debug event for breakpoint n is generated. This field must be interpreted along with the SSC and PMC fields.'''
  [[register.field]]
    name = "BAS"
    bits = "8:5"
    type = "rw"
    shortdesc = '''Byte address select.'''
    longdesc = '''Defines which half-words an address-matching breakpoint matches, regardless of the instruction set and execution state. In an AArch64-only implementation, this field is reserved, RES1. Otherwise:BAS[2] and BAS[0] are read/write.BAS[3] and BAS[1] are read-only copies of BAS[2] and BAS[0] respectively.The values 0b0011 and 0b1100 are only supported if AArch32 is supported at any exception level.The permitted values depend on the breakpoint type.For Address match breakpoints in either AArch32 or AArch64 state:BASMatch instruction atConstraint for debuggers0b0011DBGBVR<n>_EL1Use for T32 and T32EE instructions.0b1100DBGBVR<n>_EL1+2Use for T32 and T32EE instructions.0b1111DBGBVR<n>_EL1Use for A64 and A32 instructions.0b0000 is reserved and must behave as if the breakpoint is disabled or map to a permitted value.For Address mismatch breakpoints in an AArch32 stage 1 translation regime:BASStep instruction atConstraint for debuggers0b0000-Use for a match anywhere breakpoint.0b0011DBGBVR<n>_EL1Use for stepping T32 and T32EE instructions.0b1100DBGBVR<n>_EL1+2Use for stepping T32 and T32EE instructions.0b1111DBGBVR<n>_EL1Use for stepping A64 and A32 instructions.For Context matching breakpoints, this field is RES1 and ignored.'''
  [[register.field]]
    name = "PMC"
    bits = "2:1"
    type = "rw"
    shortdesc = '''Privilege mode control.'''
    longdesc = '''Determines the exception level or levels at which a breakpoint debug event for breakpoint n is generated. This field must be interpreted along with the SSC and HMC fields.'''
  [[register.field]]
    name = "E"
    bits = "0"
    type = "rw"
    shortdesc = '''Enable breakpoint DBGBVR<n>_EL1.'''
    longdesc = '''Possible values are:'''
[[register]]
  name = "DBGBVR3_EL1_31TO0"
  type = "rw"
  width = 32
  description = "Debug Breakpoint Value Registers. Holds a virtual address or a VMID and/or a context ID for use in breakpoint matching. Forms breakpoint n together with control register DBGBCR<n>_EL1 where n is 0 to 15. Multiple uses of this register refer to ARMv8"
  default = "0x00000000"
  offset = "0x00000430"
  [[register.field]]
    name = "VA"
    bits = "31:2"
    type = "rw"
    shortdesc = '''Bits[48:2] of the address value for comparison.'''
    longdesc = '''ARM deprecates setting DBGWVR<n>_EL1[2] == 1.'''
[[register]]
  name = "DBGBVR3_EL1_63TO32"
  type = "rw"
  width = 32
  description = "Debug Breakpoint Extended Value Registers. Holds a virtual address or a VMID and/or a context ID for use in breakpoint matching. Forms breakpoint n together with control register DBGBCR<n>_EL1 where n is 0 to 15. Multiple uses of this register refer to ARMv8"
  default = "0x00000000"
  offset = "0x00000434"
  [[register.field]]
    name = "RESS"
    bits = "31:17"
    type = "rw"
    shortdesc = '''Reserved, Sign extended.'''
    longdesc = '''Hardwired to the value of the sign bit, bit [48]. Hardware and software must treat this field as RES0 if bit[48] is 0, and as RES1 if bit[48] is 1.'''
  [[register.field]]
    name = "VA"
    bits = "16:0"
    type = "rw"
    shortdesc = '''Bits[48:2] of the address value for comparison.'''
    longdesc = '''ARM deprecates setting DBGWVR<n>_EL1[2] == 1.'''
[[register]]
  name = "DBGBCR3_EL1"
  type = "rw"
  width = 32
  description = "Debug Breakpoint Control Registers"
  default = "0x00000000"
  offset = "0x00000438"
  [[register.field]]
    name = "BT"
    bits = "23:20"
    type = "rw"
    shortdesc = '''Breakpoint Type.'''
    longdesc = '''Possible values are:The field breaks down as follows:BT[3:1]: Base type.000Match address. DBGBVR<n>_EL1 is the address of an instruction.010Mismatch address. Behaves as type 0b000 if in an AArch64 translation, or if halting debug-mode is enabled and halting is allowed. Otherwise, DBGBVR<n>_EL1 is the address of an instruction to be stepped.001Match context ID. DBGBVR<n>_EL1[31:0] is a context ID.100Match VMID. DBGBVR<n>_EL1[39:32] is a VMID.101Match VMID and context ID. DBGBVR<n>_EL1[31:0] is a context ID, and DBGBVR<n>_EL1[39:32] is a VMID.BT[0]: Enable linking.If the breakpoint is not context-aware, BT[3] and BT[1] are RES0. If EL2 is not implemented, BT[3] is RES0. If EL1 using AArch32 is not implemented, BT[2] is RES0.The values 011x and 11xx are reserved, but must behave as if the breakpoint is disabled. Software must not rely on this property as the behavior of reserved values might change in a future revision of the architecture.'''
  [[register.field]]
    name = "LBN"
    bits = "19:16"
    type = "rw"
    shortdesc = '''Linked breakpoint number.'''
    longdesc = '''For Linked address matching breakpoints, this specifies the index of the Context-matching breakpoint linked to.'''
  [[register.field]]
    name = "SSC"
    bits = "15:14"
    type = "rw"
    shortdesc = '''Security state control.'''
    longdesc = '''Determines the security states under which a breakpoint debug event for breakpoint n is generated. This field must be interpreted along with the HMC and PMC fields.'''
  [[register.field]]
    name = "HMC"
    bits = "13"
    type = "rw"
    shortdesc = '''Higher mode control.'''
    longdesc = '''Determines the debug perspective for deciding when a breakpoint debug event for breakpoint n is generated. This field must be interpreted along with the SSC and PMC fields.'''
  [[register.field]]
    name = "BAS"
    bits = "8:5"
    type = "rw"
    shortdesc = '''Byte address select.'''
    longdesc = '''Defines which half-words an address-matching breakpoint matches, regardless of the instruction set and execution state. In an AArch64-only implementation, this field is reserved, RES1. Otherwise:BAS[2] and BAS[0] are read/write.BAS[3] and BAS[1] are read-only copies of BAS[2] and BAS[0] respectively.The values 0b0011 and 0b1100 are only supported if AArch32 is supported at any exception level.The permitted values depend on the breakpoint type.For Address match breakpoints in either AArch32 or AArch64 state:BASMatch instruction atConstraint for debuggers0b0011DBGBVR<n>_EL1Use for T32 and T32EE instructions.0b1100DBGBVR<n>_EL1+2Use for T32 and T32EE instructions.0b1111DBGBVR<n>_EL1Use for A64 and A32 instructions.0b0000 is reserved and must behave as if the breakpoint is disabled or map to a permitted value.For Address mismatch breakpoints in an AArch32 stage 1 translation regime:BASStep instruction atConstraint for debuggers0b0000-Use for a match anywhere breakpoint.0b0011DBGBVR<n>_EL1Use for stepping T32 and T32EE instructions.0b1100DBGBVR<n>_EL1+2Use for stepping T32 and T32EE instructions.0b1111DBGBVR<n>_EL1Use for stepping A64 and A32 instructions.For Context matching breakpoints, this field is RES1 and ignored.'''
  [[register.field]]
    name = "PMC"
    bits = "2:1"
    type = "rw"
    shortdesc = '''Privilege mode control.'''
    longdesc = '''Determines the exception level or levels at which a breakpoint debug event for breakpoint n is generated. This field must be interpreted along with the SSC and HMC fields.'''
  [[register.field]]
    name = "E"
    bits = "0"
    type = "rw"
    shortdesc = '''Enable breakpoint DBGBVR<n>_EL1.'''
    longdesc = '''Possible values are:'''
[[register]]
  name = "DBGBVR4_EL1_31TO0"
  type = "rw"
  width = 32
  description = "Debug Breakpoint Value Registers. Holds a virtual address or a VMID and/or a context ID for use in breakpoint matching. Forms breakpoint n together with control register DBGBCR<n>_EL1 where n is 0 to 15. Multiple uses of this register refer to ARMv8"
  default = "0x00000000"
  offset = "0x00000440"
  [[register.field]]
    name = "VA"
    bits = "31:2"
    type = "rw"
    shortdesc = '''Bits[48:2] of the address value for comparison.'''
    longdesc = '''ARM deprecates setting DBGWVR<n>_EL1[2] == 1.'''
[[register]]
  name = "DBGBVR4_EL1_63TO32"
  type = "rw"
  width = 32
  description = "Debug Breakpoint Extended Value Registers. Holds a virtual address or a VMID and/or a context ID for use in breakpoint matching. Forms breakpoint n together with control register DBGBCR<n>_EL1 where n is 0 to 15. Multiple uses of this register refer to ARMv8"
  default = "0x00000000"
  offset = "0x00000444"
  [[register.field]]
    name = "RESS"
    bits = "31:17"
    type = "rw"
    shortdesc = '''Reserved, Sign extended.'''
    longdesc = '''Hardwired to the value of the sign bit, bit [48]. Hardware and software must treat this field as RES0 if bit[48] is 0, and as RES1 if bit[48] is 1.'''
  [[register.field]]
    name = "VA"
    bits = "16:0"
    type = "rw"
    shortdesc = '''Bits[48:2] of the address value for comparison.'''
    longdesc = '''ARM deprecates setting DBGWVR<n>_EL1[2] == 1.'''
[[register]]
  name = "DBGBCR4_EL1"
  type = "rw"
  width = 32
  description = "Debug Breakpoint Control Registers"
  default = "0x00000000"
  offset = "0x00000448"
  [[register.field]]
    name = "BT"
    bits = "23:20"
    type = "rw"
    shortdesc = '''Breakpoint Type.'''
    longdesc = '''Possible values are:The field breaks down as follows:BT[3:1]: Base type.000Match address. DBGBVR<n>_EL1 is the address of an instruction.010Mismatch address. Behaves as type 0b000 if in an AArch64 translation, or if halting debug-mode is enabled and halting is allowed. Otherwise, DBGBVR<n>_EL1 is the address of an instruction to be stepped.001Match context ID. DBGBVR<n>_EL1[31:0] is a context ID.100Match VMID. DBGBVR<n>_EL1[39:32] is a VMID.101Match VMID and context ID. DBGBVR<n>_EL1[31:0] is a context ID, and DBGBVR<n>_EL1[39:32] is a VMID.BT[0]: Enable linking.If the breakpoint is not context-aware, BT[3] and BT[1] are RES0. If EL2 is not implemented, BT[3] is RES0. If EL1 using AArch32 is not implemented, BT[2] is RES0.The values 011x and 11xx are reserved, but must behave as if the breakpoint is disabled. Software must not rely on this property as the behavior of reserved values might change in a future revision of the architecture.'''
  [[register.field]]
    name = "LBN"
    bits = "19:16"
    type = "rw"
    shortdesc = '''Linked breakpoint number.'''
    longdesc = '''For Linked address matching breakpoints, this specifies the index of the Context-matching breakpoint linked to.'''
  [[register.field]]
    name = "SSC"
    bits = "15:14"
    type = "rw"
    shortdesc = '''Security state control.'''
    longdesc = '''Determines the security states under which a breakpoint debug event for breakpoint n is generated. This field must be interpreted along with the HMC and PMC fields.'''
  [[register.field]]
    name = "HMC"
    bits = "13"
    type = "rw"
    shortdesc = '''Higher mode control.'''
    longdesc = '''Determines the debug perspective for deciding when a breakpoint debug event for breakpoint n is generated. This field must be interpreted along with the SSC and PMC fields.'''
  [[register.field]]
    name = "BAS"
    bits = "8:5"
    type = "rw"
    shortdesc = '''Byte address select.'''
    longdesc = '''Defines which half-words an address-matching breakpoint matches, regardless of the instruction set and execution state. In an AArch64-only implementation, this field is reserved, RES1. Otherwise:BAS[2] and BAS[0] are read/write.BAS[3] and BAS[1] are read-only copies of BAS[2] and BAS[0] respectively.The values 0b0011 and 0b1100 are only supported if AArch32 is supported at any exception level.The permitted values depend on the breakpoint type.For Address match breakpoints in either AArch32 or AArch64 state:BASMatch instruction atConstraint for debuggers0b0011DBGBVR<n>_EL1Use for T32 and T32EE instructions.0b1100DBGBVR<n>_EL1+2Use for T32 and T32EE instructions.0b1111DBGBVR<n>_EL1Use for A64 and A32 instructions.0b0000 is reserved and must behave as if the breakpoint is disabled or map to a permitted value.For Address mismatch breakpoints in an AArch32 stage 1 translation regime:BASStep instruction atConstraint for debuggers0b0000-Use for a match anywhere breakpoint.0b0011DBGBVR<n>_EL1Use for stepping T32 and T32EE instructions.0b1100DBGBVR<n>_EL1+2Use for stepping T32 and T32EE instructions.0b1111DBGBVR<n>_EL1Use for stepping A64 and A32 instructions.For Context matching breakpoints, this field is RES1 and ignored.'''
  [[register.field]]
    name = "PMC"
    bits = "2:1"
    type = "rw"
    shortdesc = '''Privilege mode control.'''
    longdesc = '''Determines the exception level or levels at which a breakpoint debug event for breakpoint n is generated. This field must be interpreted along with the SSC and HMC fields.'''
  [[register.field]]
    name = "E"
    bits = "0"
    type = "rw"
    shortdesc = '''Enable breakpoint DBGBVR<n>_EL1.'''
    longdesc = '''Possible values are:'''
[[register]]
  name = "DBGBVR5_EL1_31TO0"
  type = "rw"
  width = 32
  description = "Debug Breakpoint Value Registers. Holds a virtual address or a VMID and/or a context ID for use in breakpoint matching. Forms breakpoint n together with control register DBGBCR<n>_EL1 where n is 0 to 15. Multiple uses of this register refer to ARMv8"
  default = "0x00000000"
  offset = "0x00000450"
  [[register.field]]
    name = "VA"
    bits = "31:2"
    type = "rw"
    shortdesc = '''Bits[48:2] of the address value for comparison.'''
    longdesc = '''ARM deprecates setting DBGWVR<n>_EL1[2] == 1.'''
[[register]]
  name = "DBGBVR5_EL1_63TO32"
  type = "rw"
  width = 32
  description = "Debug Breakpoint Extended Value Registers. Holds a virtual address or a VMID and/or a context ID for use in breakpoint matching. Forms breakpoint n together with control register DBGBCR<n>_EL1 where n is 0 to 15. Multiple uses of this register refer to ARMv8"
  default = "0x00000000"
  offset = "0x00000454"
  [[register.field]]
    name = "RESS"
    bits = "31:17"
    type = "rw"
    shortdesc = '''Reserved, Sign extended.'''
    longdesc = '''Hardwired to the value of the sign bit, bit [48]. Hardware and software must treat this field as RES0 if bit[48] is 0, and as RES1 if bit[48] is 1.'''
  [[register.field]]
    name = "VA"
    bits = "16:0"
    type = "rw"
    shortdesc = '''Bits[48:2] of the address value for comparison.'''
    longdesc = '''ARM deprecates setting DBGWVR<n>_EL1[2] == 1.'''
[[register]]
  name = "DBGBCR5_EL1"
  type = "rw"
  width = 32
  description = "Debug Breakpoint Control Registers"
  default = "0x00000000"
  offset = "0x00000458"
  [[register.field]]
    name = "BT"
    bits = "23:20"
    type = "rw"
    shortdesc = '''Breakpoint Type.'''
    longdesc = '''Possible values are:The field breaks down as follows:BT[3:1]: Base type.000Match address. DBGBVR<n>_EL1 is the address of an instruction.010Mismatch address. Behaves as type 0b000 if in an AArch64 translation, or if halting debug-mode is enabled and halting is allowed. Otherwise, DBGBVR<n>_EL1 is the address of an instruction to be stepped.001Match context ID. DBGBVR<n>_EL1[31:0] is a context ID.100Match VMID. DBGBVR<n>_EL1[39:32] is a VMID.101Match VMID and context ID. DBGBVR<n>_EL1[31:0] is a context ID, and DBGBVR<n>_EL1[39:32] is a VMID.BT[0]: Enable linking.If the breakpoint is not context-aware, BT[3] and BT[1] are RES0. If EL2 is not implemented, BT[3] is RES0. If EL1 using AArch32 is not implemented, BT[2] is RES0.The values 011x and 11xx are reserved, but must behave as if the breakpoint is disabled. Software must not rely on this property as the behavior of reserved values might change in a future revision of the architecture.'''
  [[register.field]]
    name = "LBN"
    bits = "19:16"
    type = "rw"
    shortdesc = '''Linked breakpoint number.'''
    longdesc = '''For Linked address matching breakpoints, this specifies the index of the Context-matching breakpoint linked to.'''
  [[register.field]]
    name = "SSC"
    bits = "15:14"
    type = "rw"
    shortdesc = '''Security state control.'''
    longdesc = '''Determines the security states under which a breakpoint debug event for breakpoint n is generated. This field must be interpreted along with the HMC and PMC fields.'''
  [[register.field]]
    name = "HMC"
    bits = "13"
    type = "rw"
    shortdesc = '''Higher mode control.'''
    longdesc = '''Determines the debug perspective for deciding when a breakpoint debug event for breakpoint n is generated. This field must be interpreted along with the SSC and PMC fields.'''
  [[register.field]]
    name = "BAS"
    bits = "8:5"
    type = "rw"
    shortdesc = '''Byte address select.'''
    longdesc = '''Defines which half-words an address-matching breakpoint matches, regardless of the instruction set and execution state. In an AArch64-only implementation, this field is reserved, RES1. Otherwise:BAS[2] and BAS[0] are read/write.BAS[3] and BAS[1] are read-only copies of BAS[2] and BAS[0] respectively.The values 0b0011 and 0b1100 are only supported if AArch32 is supported at any exception level.The permitted values depend on the breakpoint type.For Address match breakpoints in either AArch32 or AArch64 state:BASMatch instruction atConstraint for debuggers0b0011DBGBVR<n>_EL1Use for T32 and T32EE instructions.0b1100DBGBVR<n>_EL1+2Use for T32 and T32EE instructions.0b1111DBGBVR<n>_EL1Use for A64 and A32 instructions.0b0000 is reserved and must behave as if the breakpoint is disabled or map to a permitted value.For Address mismatch breakpoints in an AArch32 stage 1 translation regime:BASStep instruction atConstraint for debuggers0b0000-Use for a match anywhere breakpoint.0b0011DBGBVR<n>_EL1Use for stepping T32 and T32EE instructions.0b1100DBGBVR<n>_EL1+2Use for stepping T32 and T32EE instructions.0b1111DBGBVR<n>_EL1Use for stepping A64 and A32 instructions.For Context matching breakpoints, this field is RES1 and ignored.'''
  [[register.field]]
    name = "PMC"
    bits = "2:1"
    type = "rw"
    shortdesc = '''Privilege mode control.'''
    longdesc = '''Determines the exception level or levels at which a breakpoint debug event for breakpoint n is generated. This field must be interpreted along with the SSC and HMC fields.'''
  [[register.field]]
    name = "E"
    bits = "0"
    type = "rw"
    shortdesc = '''Enable breakpoint DBGBVR<n>_EL1.'''
    longdesc = '''Possible values are:'''
[[register]]
  name = "DBGWVR0_EL1_31TO0"
  type = "rw"
  width = 32
  description = "Debug Watchpoint Value Registers"
  default = "0x00000000"
  offset = "0x00000800"
  [[register.field]]
    name = "VA"
    bits = "31:2"
    type = "rw"
    shortdesc = '''Bits[48:2] of the address value for comparison.'''
    longdesc = '''ARM deprecates setting DBGWVR<n>_EL1[2] == 1.'''
[[register]]
  name = "DBGWVR0_EL1_63TO32"
  type = "rw"
  width = 32
  description = "Debug Watchpoint Extended Value Registers"
  default = "0x00000000"
  offset = "0x00000804"
  [[register.field]]
    name = "RESS"
    bits = "31:17"
    type = "rw"
    shortdesc = '''Reserved, Sign extended.'''
    longdesc = '''Hardwired to the value of the sign bit, bit [48]. Hardware and software must treat this field as RES0 if bit[48] is 0, and as RES1 if bit[48] is 1.'''
  [[register.field]]
    name = "VA"
    bits = "16:0"
    type = "rw"
    shortdesc = '''Bits[48:2] of the address value for comparison.'''
    longdesc = '''ARM deprecates setting DBGWVR<n>_EL1[2] == 1.'''
[[register]]
  name = "DBGWCR0_EL1"
  type = "rw"
  width = 32
  description = "Debug Watchpoint Control Registers"
  default = "0x00000000"
  offset = "0x00000808"
  [[register.field]]
    name = "MASK"
    bits = "28:24"
    type = "rw"
    shortdesc = '''Address mask.'''
    longdesc = '''Only objects up to 2GB can be watched using a single mask.Other values mask the corresponding number of address bits, from 0b00011 masking 3 address bits (0x00000007 mask for address) to 0b11111 masking 31 address bits (0x7FFFFFFF mask for address).'''
  [[register.field]]
    name = "WT"
    bits = "20"
    type = "rw"
    shortdesc = '''Watchpoint type.'''
    longdesc = '''Possible values are:'''
  [[register.field]]
    name = "LBN"
    bits = "19:16"
    type = "rw"
    shortdesc = '''Linked breakpoint number.'''
    longdesc = '''For Linked data address watchpoints, this specifies the index of the Context-matching breakpoint linked to.'''
  [[register.field]]
    name = "SSC"
    bits = "15:14"
    type = "rw"
    shortdesc = '''Security state control.'''
    longdesc = '''Determines the security states under which a watchpoint debug event for watchpoint n is generated. This field must be interpreted along with the HMC and PAC fields.'''
  [[register.field]]
    name = "HMC"
    bits = "13"
    type = "rw"
    shortdesc = '''Higher mode control.'''
    longdesc = '''Determines the debug perspective for deciding when a watchpoint debug event for watchpoint n is generated. This field must be interpreted along with the SSC and PAC fields.'''
  [[register.field]]
    name = "BAS"
    bits = "12:5"
    type = "rw"
    shortdesc = '''Byte address select.'''
    longdesc = '''Each bit of this field selects whether a byte from within the word or double-word addressed by DBGWVR<n>_EL1 is being watched.BASDescriptionxxxxxxx1Match byte at DBGWVR<n>_EL1xxxxxx1xMatch byte at DBGWVR<n>_EL1+1xxxxx1xxMatch byte at DBGWVR<n>_EL1+2xxxx1xxxMatch byte at DBGWVR<n>_EL1+3In cases where DBGWVR<n>_EL1 addresses a double-word:BASDescription, if DBGWVR<n>_EL1[2] == 0xxx1xxxxMatch byte at DBGWVR<n>_EL1+4xx1xxxxxMatch byte at DBGWVR<n>_EL1+5x1xxxxxxMatch byte at DBGWVR<n>_EL1+61xxxxxxxMatch byte at DBGWVR<n>_EL1+7If DBGWVR<n>_EL1[2] == 1, only BAS[3:0] is used. ARM deprecates setting DBGWVR<n>_EL1 == 1.The valid values for BAS are 0b0000000, or a binary number all of whose set bits are contiguous. All other values are reserved and must not be used by software.If BAS is zero, no bytes are watched by this watchpoint.Ignored if E is 0.'''
  [[register.field]]
    name = "LSC"
    bits = "4:3"
    type = "rw"
    shortdesc = '''Load/store control.'''
    longdesc = '''This field enables watchpoint matching on the type of access being made. Possible values of this field are:All other values are reserved, but must behave as if the watchpoint is disabled. Software must not rely on this property as the behavior of reserved values might change in a future revision of the architecture.Ignored if E is 0.'''
  [[register.field]]
    name = "PAC"
    bits = "2:1"
    type = "rw"
    shortdesc = '''Privilege of access control.'''
    longdesc = '''Determines the exception level or levels at which a watchpoint debug event for watchpoint n is generated. This field must be interpreted along with the SSC and HMC fields.'''
  [[register.field]]
    name = "E"
    bits = "0"
    type = "rw"
    shortdesc = '''Enable watchpoint n.'''
    longdesc = '''Possible values are:'''
[[register]]
  name = "DBGWVR1_EL1_31TO0"
  type = "rw"
  width = 32
  description = "Debug Watchpoint Value Registers"
  default = "0x00000000"
  offset = "0x00000810"
  [[register.field]]
    name = "VA"
    bits = "31:2"
    type = "rw"
    shortdesc = '''Bits[48:2] of the address value for comparison.'''
    longdesc = '''ARM deprecates setting DBGWVR<n>_EL1[2] == 1.'''
[[register]]
  name = "DBGWVR1_EL1_63TO32"
  type = "rw"
  width = 32
  description = "Debug Watchpoint Extended Value Registers"
  default = "0x00000000"
  offset = "0x00000814"
  [[register.field]]
    name = "RESS"
    bits = "31:17"
    type = "rw"
    shortdesc = '''Reserved, Sign extended.'''
    longdesc = '''Hardwired to the value of the sign bit, bit [48]. Hardware and software must treat this field as RES0 if bit[48] is 0, and as RES1 if bit[48] is 1.'''
  [[register.field]]
    name = "VA"
    bits = "16:0"
    type = "rw"
    shortdesc = '''Bits[48:2] of the address value for comparison.'''
    longdesc = '''ARM deprecates setting DBGWVR<n>_EL1[2] == 1.'''
[[register]]
  name = "DBGWCR1_EL1"
  type = "rw"
  width = 32
  description = "Debug Watchpoint Control Registers"
  default = "0x00000000"
  offset = "0x00000818"
  [[register.field]]
    name = "MASK"
    bits = "28:24"
    type = "rw"
    shortdesc = '''Address mask.'''
    longdesc = '''Only objects up to 2GB can be watched using a single mask.Other values mask the corresponding number of address bits, from 0b00011 masking 3 address bits (0x00000007 mask for address) to 0b11111 masking 31 address bits (0x7FFFFFFF mask for address).'''
  [[register.field]]
    name = "WT"
    bits = "20"
    type = "rw"
    shortdesc = '''Watchpoint type.'''
    longdesc = '''Possible values are:'''
  [[register.field]]
    name = "LBN"
    bits = "19:16"
    type = "rw"
    shortdesc = '''Linked breakpoint number.'''
    longdesc = '''For Linked data address watchpoints, this specifies the index of the Context-matching breakpoint linked to.'''
  [[register.field]]
    name = "SSC"
    bits = "15:14"
    type = "rw"
    shortdesc = '''Security state control.'''
    longdesc = '''Determines the security states under which a watchpoint debug event for watchpoint n is generated. This field must be interpreted along with the HMC and PAC fields.'''
  [[register.field]]
    name = "HMC"
    bits = "13"
    type = "rw"
    shortdesc = '''Higher mode control.'''
    longdesc = '''Determines the debug perspective for deciding when a watchpoint debug event for watchpoint n is generated. This field must be interpreted along with the SSC and PAC fields.'''
  [[register.field]]
    name = "BAS"
    bits = "12:5"
    type = "rw"
    shortdesc = '''Byte address select.'''
    longdesc = '''Each bit of this field selects whether a byte from within the word or double-word addressed by DBGWVR<n>_EL1 is being watched.BASDescriptionxxxxxxx1Match byte at DBGWVR<n>_EL1xxxxxx1xMatch byte at DBGWVR<n>_EL1+1xxxxx1xxMatch byte at DBGWVR<n>_EL1+2xxxx1xxxMatch byte at DBGWVR<n>_EL1+3In cases where DBGWVR<n>_EL1 addresses a double-word:BASDescription, if DBGWVR<n>_EL1[2] == 0xxx1xxxxMatch byte at DBGWVR<n>_EL1+4xx1xxxxxMatch byte at DBGWVR<n>_EL1+5x1xxxxxxMatch byte at DBGWVR<n>_EL1+61xxxxxxxMatch byte at DBGWVR<n>_EL1+7If DBGWVR<n>_EL1[2] == 1, only BAS[3:0] is used. ARM deprecates setting DBGWVR<n>_EL1 == 1.The valid values for BAS are 0b0000000, or a binary number all of whose set bits are contiguous. All other values are reserved and must not be used by software.If BAS is zero, no bytes are watched by this watchpoint.Ignored if E is 0.'''
  [[register.field]]
    name = "LSC"
    bits = "4:3"
    type = "rw"
    shortdesc = '''Load/store control.'''
    longdesc = '''This field enables watchpoint matching on the type of access being made. Possible values of this field are:All other values are reserved, but must behave as if the watchpoint is disabled. Software must not rely on this property as the behavior of reserved values might change in a future revision of the architecture.Ignored if E is 0.'''
  [[register.field]]
    name = "PAC"
    bits = "2:1"
    type = "rw"
    shortdesc = '''Privilege of access control.'''
    longdesc = '''Determines the exception level or levels at which a watchpoint debug event for watchpoint n is generated. This field must be interpreted along with the SSC and HMC fields.'''
  [[register.field]]
    name = "E"
    bits = "0"
    type = "rw"
    shortdesc = '''Enable watchpoint n.'''
    longdesc = '''Possible values are:'''
[[register]]
  name = "DBGWVR2_EL1_31TO0"
  type = "rw"
  width = 32
  description = "Debug Watchpoint Value Registers"
  default = "0x00000000"
  offset = "0x00000820"
  [[register.field]]
    name = "VA"
    bits = "31:2"
    type = "rw"
    shortdesc = '''Bits[48:2] of the address value for comparison.'''
    longdesc = '''ARM deprecates setting DBGWVR<n>_EL1[2] == 1.'''
[[register]]
  name = "DBGWVR2_EL1_63TO32"
  type = "rw"
  width = 32
  description = "Debug Watchpoint Extended Value Registers"
  default = "0x00000000"
  offset = "0x00000824"
  [[register.field]]
    name = "RESS"
    bits = "31:17"
    type = "rw"
    shortdesc = '''Reserved, Sign extended.'''
    longdesc = '''Hardwired to the value of the sign bit, bit [48]. Hardware and software must treat this field as RES0 if bit[48] is 0, and as RES1 if bit[48] is 1.'''
  [[register.field]]
    name = "VA"
    bits = "16:0"
    type = "rw"
    shortdesc = '''Bits[48:2] of the address value for comparison.'''
    longdesc = '''ARM deprecates setting DBGWVR<n>_EL1[2] == 1.'''
[[register]]
  name = "DBGWCR2_EL1"
  type = "rw"
  width = 32
  description = "Debug Watchpoint Control Registers"
  default = "0x00000000"
  offset = "0x00000828"
  [[register.field]]
    name = "MASK"
    bits = "28:24"
    type = "rw"
    shortdesc = '''Address mask.'''
    longdesc = '''Only objects up to 2GB can be watched using a single mask.Other values mask the corresponding number of address bits, from 0b00011 masking 3 address bits (0x00000007 mask for address) to 0b11111 masking 31 address bits (0x7FFFFFFF mask for address).'''
  [[register.field]]
    name = "WT"
    bits = "20"
    type = "rw"
    shortdesc = '''Watchpoint type.'''
    longdesc = '''Possible values are:'''
  [[register.field]]
    name = "LBN"
    bits = "19:16"
    type = "rw"
    shortdesc = '''Linked breakpoint number.'''
    longdesc = '''For Linked data address watchpoints, this specifies the index of the Context-matching breakpoint linked to.'''
  [[register.field]]
    name = "SSC"
    bits = "15:14"
    type = "rw"
    shortdesc = '''Security state control.'''
    longdesc = '''Determines the security states under which a watchpoint debug event for watchpoint n is generated. This field must be interpreted along with the HMC and PAC fields.'''
  [[register.field]]
    name = "HMC"
    bits = "13"
    type = "rw"
    shortdesc = '''Higher mode control.'''
    longdesc = '''Determines the debug perspective for deciding when a watchpoint debug event for watchpoint n is generated. This field must be interpreted along with the SSC and PAC fields.'''
  [[register.field]]
    name = "BAS"
    bits = "12:5"
    type = "rw"
    shortdesc = '''Byte address select.'''
    longdesc = '''Each bit of this field selects whether a byte from within the word or double-word addressed by DBGWVR<n>_EL1 is being watched.BASDescriptionxxxxxxx1Match byte at DBGWVR<n>_EL1xxxxxx1xMatch byte at DBGWVR<n>_EL1+1xxxxx1xxMatch byte at DBGWVR<n>_EL1+2xxxx1xxxMatch byte at DBGWVR<n>_EL1+3In cases where DBGWVR<n>_EL1 addresses a double-word:BASDescription, if DBGWVR<n>_EL1[2] == 0xxx1xxxxMatch byte at DBGWVR<n>_EL1+4xx1xxxxxMatch byte at DBGWVR<n>_EL1+5x1xxxxxxMatch byte at DBGWVR<n>_EL1+61xxxxxxxMatch byte at DBGWVR<n>_EL1+7If DBGWVR<n>_EL1[2] == 1, only BAS[3:0] is used. ARM deprecates setting DBGWVR<n>_EL1 == 1.The valid values for BAS are 0b0000000, or a binary number all of whose set bits are contiguous. All other values are reserved and must not be used by software.If BAS is zero, no bytes are watched by this watchpoint.Ignored if E is 0.'''
  [[register.field]]
    name = "LSC"
    bits = "4:3"
    type = "rw"
    shortdesc = '''Load/store control.'''
    longdesc = '''This field enables watchpoint matching on the type of access being made. Possible values of this field are:All other values are reserved, but must behave as if the watchpoint is disabled. Software must not rely on this property as the behavior of reserved values might change in a future revision of the architecture.Ignored if E is 0.'''
  [[register.field]]
    name = "PAC"
    bits = "2:1"
    type = "rw"
    shortdesc = '''Privilege of access control.'''
    longdesc = '''Determines the exception level or levels at which a watchpoint debug event for watchpoint n is generated. This field must be interpreted along with the SSC and HMC fields.'''
  [[register.field]]
    name = "E"
    bits = "0"
    type = "rw"
    shortdesc = '''Enable watchpoint n.'''
    longdesc = '''Possible values are:'''
[[register]]
  name = "DBGWVR3_EL1_31TO0"
  type = "rw"
  width = 32
  description = "Debug Watchpoint Value Registers"
  default = "0x00000000"
  offset = "0x00000830"
  [[register.field]]
    name = "VA"
    bits = "31:2"
    type = "rw"
    shortdesc = '''Bits[48:2] of the address value for comparison.'''
    longdesc = '''ARM deprecates setting DBGWVR<n>_EL1[2] == 1.'''
[[register]]
  name = "DBGWVR3_EL1_63TO32"
  type = "rw"
  width = 32
  description = "Debug Watchpoint Extended Value Registers"
  default = "0x00000000"
  offset = "0x00000834"
  [[register.field]]
    name = "RESS"
    bits = "31:17"
    type = "rw"
    shortdesc = '''Reserved, Sign extended.'''
    longdesc = '''Hardwired to the value of the sign bit, bit [48]. Hardware and software must treat this field as RES0 if bit[48] is 0, and as RES1 if bit[48] is 1.'''
  [[register.field]]
    name = "VA"
    bits = "16:0"
    type = "rw"
    shortdesc = '''Bits[48:2] of the address value for comparison.'''
    longdesc = '''ARM deprecates setting DBGWVR<n>_EL1[2] == 1.'''
[[register]]
  name = "DBGWCR3_EL1"
  type = "rw"
  width = 32
  description = "Debug Watchpoint Control Registers"
  default = "0x00000000"
  offset = "0x00000838"
  [[register.field]]
    name = "MASK"
    bits = "28:24"
    type = "rw"
    shortdesc = '''Address mask.'''
    longdesc = '''Only objects up to 2GB can be watched using a single mask.Other values mask the corresponding number of address bits, from 0b00011 masking 3 address bits (0x00000007 mask for address) to 0b11111 masking 31 address bits (0x7FFFFFFF mask for address).'''
  [[register.field]]
    name = "WT"
    bits = "20"
    type = "rw"
    shortdesc = '''Watchpoint type.'''
    longdesc = '''Possible values are:'''
  [[register.field]]
    name = "LBN"
    bits = "19:16"
    type = "rw"
    shortdesc = '''Linked breakpoint number.'''
    longdesc = '''For Linked data address watchpoints, this specifies the index of the Context-matching breakpoint linked to.'''
  [[register.field]]
    name = "SSC"
    bits = "15:14"
    type = "rw"
    shortdesc = '''Security state control.'''
    longdesc = '''Determines the security states under which a watchpoint debug event for watchpoint n is generated. This field must be interpreted along with the HMC and PAC fields.'''
  [[register.field]]
    name = "HMC"
    bits = "13"
    type = "rw"
    shortdesc = '''Higher mode control.'''
    longdesc = '''Determines the debug perspective for deciding when a watchpoint debug event for watchpoint n is generated. This field must be interpreted along with the SSC and PAC fields.'''
  [[register.field]]
    name = "BAS"
    bits = "12:5"
    type = "rw"
    shortdesc = '''Byte address select.'''
    longdesc = '''Each bit of this field selects whether a byte from within the word or double-word addressed by DBGWVR<n>_EL1 is being watched.BASDescriptionxxxxxxx1Match byte at DBGWVR<n>_EL1xxxxxx1xMatch byte at DBGWVR<n>_EL1+1xxxxx1xxMatch byte at DBGWVR<n>_EL1+2xxxx1xxxMatch byte at DBGWVR<n>_EL1+3In cases where DBGWVR<n>_EL1 addresses a double-word:BASDescription, if DBGWVR<n>_EL1[2] == 0xxx1xxxxMatch byte at DBGWVR<n>_EL1+4xx1xxxxxMatch byte at DBGWVR<n>_EL1+5x1xxxxxxMatch byte at DBGWVR<n>_EL1+61xxxxxxxMatch byte at DBGWVR<n>_EL1+7If DBGWVR<n>_EL1[2] == 1, only BAS[3:0] is used. ARM deprecates setting DBGWVR<n>_EL1 == 1.The valid values for BAS are 0b0000000, or a binary number all of whose set bits are contiguous. All other values are reserved and must not be used by software.If BAS is zero, no bytes are watched by this watchpoint.Ignored if E is 0.'''
  [[register.field]]
    name = "LSC"
    bits = "4:3"
    type = "rw"
    shortdesc = '''Load/store control.'''
    longdesc = '''This field enables watchpoint matching on the type of access being made. Possible values of this field are:All other values are reserved, but must behave as if the watchpoint is disabled. Software must not rely on this property as the behavior of reserved values might change in a future revision of the architecture.Ignored if E is 0.'''
  [[register.field]]
    name = "PAC"
    bits = "2:1"
    type = "rw"
    shortdesc = '''Privilege of access control.'''
    longdesc = '''Determines the exception level or levels at which a watchpoint debug event for watchpoint n is generated. This field must be interpreted along with the SSC and HMC fields.'''
  [[register.field]]
    name = "E"
    bits = "0"
    type = "rw"
    shortdesc = '''Enable watchpoint n.'''
    longdesc = '''Possible values are:'''
[[register]]
  name = "DBGWVR4_EL1_31TO0"
  type = "rw"
  width = 32
  description = "Debug Watchpoint Value Registers"
  default = "0x00000000"
  offset = "0x00000840"
  [[register.field]]
    name = "VA"
    bits = "31:2"
    type = "rw"
    shortdesc = '''Bits[48:2] of the address value for comparison.'''
    longdesc = '''ARM deprecates setting DBGWVR<n>_EL1[2] == 1.'''
[[register]]
  name = "DBGWVR4_EL1_63TO32"
  type = "rw"
  width = 32
  description = "Debug Watchpoint Extended Value Registers"
  default = "0x00000000"
  offset = "0x00000844"
  [[register.field]]
    name = "RESS"
    bits = "31:17"
    type = "rw"
    shortdesc = '''Reserved, Sign extended.'''
    longdesc = '''Hardwired to the value of the sign bit, bit [48]. Hardware and software must treat this field as RES0 if bit[48] is 0, and as RES1 if bit[48] is 1.'''
  [[register.field]]
    name = "VA"
    bits = "16:0"
    type = "rw"
    shortdesc = '''Bits[48:2] of the address value for comparison.'''
    longdesc = '''ARM deprecates setting DBGWVR<n>_EL1[2] == 1.'''
[[register]]
  name = "DBGWCR4_EL1"
  type = "rw"
  width = 32
  description = "Debug Watchpoint Control Registers"
  default = "0x00000000"
  offset = "0x00000848"
  [[register.field]]
    name = "MASK"
    bits = "28:24"
    type = "rw"
    shortdesc = '''Address mask.'''
    longdesc = '''Only objects up to 2GB can be watched using a single mask.Other values mask the corresponding number of address bits, from 0b00011 masking 3 address bits (0x00000007 mask for address) to 0b11111 masking 31 address bits (0x7FFFFFFF mask for address).'''
  [[register.field]]
    name = "WT"
    bits = "20"
    type = "rw"
    shortdesc = '''Watchpoint type.'''
    longdesc = '''Possible values are:'''
  [[register.field]]
    name = "LBN"
    bits = "19:16"
    type = "rw"
    shortdesc = '''Linked breakpoint number.'''
    longdesc = '''For Linked data address watchpoints, this specifies the index of the Context-matching breakpoint linked to.'''
  [[register.field]]
    name = "SSC"
    bits = "15:14"
    type = "rw"
    shortdesc = '''Security state control.'''
    longdesc = '''Determines the security states under which a watchpoint debug event for watchpoint n is generated. This field must be interpreted along with the HMC and PAC fields.'''
  [[register.field]]
    name = "HMC"
    bits = "13"
    type = "rw"
    shortdesc = '''Higher mode control.'''
    longdesc = '''Determines the debug perspective for deciding when a watchpoint debug event for watchpoint n is generated. This field must be interpreted along with the SSC and PAC fields.'''
  [[register.field]]
    name = "BAS"
    bits = "12:5"
    type = "rw"
    shortdesc = '''Byte address select.'''
    longdesc = '''Each bit of this field selects whether a byte from within the word or double-word addressed by DBGWVR<n>_EL1 is being watched.BASDescriptionxxxxxxx1Match byte at DBGWVR<n>_EL1xxxxxx1xMatch byte at DBGWVR<n>_EL1+1xxxxx1xxMatch byte at DBGWVR<n>_EL1+2xxxx1xxxMatch byte at DBGWVR<n>_EL1+3In cases where DBGWVR<n>_EL1 addresses a double-word:BASDescription, if DBGWVR<n>_EL1[2] == 0xxx1xxxxMatch byte at DBGWVR<n>_EL1+4xx1xxxxxMatch byte at DBGWVR<n>_EL1+5x1xxxxxxMatch byte at DBGWVR<n>_EL1+61xxxxxxxMatch byte at DBGWVR<n>_EL1+7If DBGWVR<n>_EL1[2] == 1, only BAS[3:0] is used. ARM deprecates setting DBGWVR<n>_EL1 == 1.The valid values for BAS are 0b0000000, or a binary number all of whose set bits are contiguous. All other values are reserved and must not be used by software.If BAS is zero, no bytes are watched by this watchpoint.Ignored if E is 0.'''
  [[register.field]]
    name = "LSC"
    bits = "4:3"
    type = "rw"
    shortdesc = '''Load/store control.'''
    longdesc = '''This field enables watchpoint matching on the type of access being made. Possible values of this field are:All other values are reserved, but must behave as if the watchpoint is disabled. Software must not rely on this property as the behavior of reserved values might change in a future revision of the architecture.Ignored if E is 0.'''
  [[register.field]]
    name = "PAC"
    bits = "2:1"
    type = "rw"
    shortdesc = '''Privilege of access control.'''
    longdesc = '''Determines the exception level or levels at which a watchpoint debug event for watchpoint n is generated. This field must be interpreted along with the SSC and HMC fields.'''
  [[register.field]]
    name = "E"
    bits = "0"
    type = "rw"
    shortdesc = '''Enable watchpoint n.'''
    longdesc = '''Possible values are:'''
[[register]]
  name = "DBGWVR5_EL1_31TO0"
  type = "rw"
  width = 32
  description = "Debug Watchpoint Value Registers"
  default = "0x00000000"
  offset = "0x00000850"
  [[register.field]]
    name = "VA"
    bits = "31:2"
    type = "rw"
    shortdesc = '''Bits[48:2] of the address value for comparison.'''
    longdesc = '''ARM deprecates setting DBGWVR<n>_EL1[2] == 1.'''
[[register]]
  name = "DBGWVR5_EL1_63TO32"
  type = "rw"
  width = 32
  description = "Debug Watchpoint Extended Value Registers"
  default = "0x00000000"
  offset = "0x00000854"
  [[register.field]]
    name = "RESS"
    bits = "31:17"
    type = "rw"
    shortdesc = '''Reserved, Sign extended.'''
    longdesc = '''Hardwired to the value of the sign bit, bit [48]. Hardware and software must treat this field as RES0 if bit[48] is 0, and as RES1 if bit[48] is 1.'''
  [[register.field]]
    name = "VA"
    bits = "16:0"
    type = "rw"
    shortdesc = '''Bits[48:2] of the address value for comparison.'''
    longdesc = '''ARM deprecates setting DBGWVR<n>_EL1[2] == 1.'''
[[register]]
  name = "DBGWCR5_EL1"
  type = "rw"
  width = 32
  description = "Debug Watchpoint Control Registers"
  default = "0x00000000"
  offset = "0x00000858"
  [[register.field]]
    name = "MASK"
    bits = "28:24"
    type = "rw"
    shortdesc = '''Address mask.'''
    longdesc = '''Only objects up to 2GB can be watched using a single mask.Other values mask the corresponding number of address bits, from 0b00011 masking 3 address bits (0x00000007 mask for address) to 0b11111 masking 31 address bits (0x7FFFFFFF mask for address).'''
  [[register.field]]
    name = "WT"
    bits = "20"
    type = "rw"
    shortdesc = '''Watchpoint type.'''
    longdesc = '''Possible values are:'''
  [[register.field]]
    name = "LBN"
    bits = "19:16"
    type = "rw"
    shortdesc = '''Linked breakpoint number.'''
    longdesc = '''For Linked data address watchpoints, this specifies the index of the Context-matching breakpoint linked to.'''
  [[register.field]]
    name = "SSC"
    bits = "15:14"
    type = "rw"
    shortdesc = '''Security state control.'''
    longdesc = '''Determines the security states under which a watchpoint debug event for watchpoint n is generated. This field must be interpreted along with the HMC and PAC fields.'''
  [[register.field]]
    name = "HMC"
    bits = "13"
    type = "rw"
    shortdesc = '''Higher mode control.'''
    longdesc = '''Determines the debug perspective for deciding when a watchpoint debug event for watchpoint n is generated. This field must be interpreted along with the SSC and PAC fields.'''
  [[register.field]]
    name = "BAS"
    bits = "12:5"
    type = "rw"
    shortdesc = '''Byte address select.'''
    longdesc = '''Each bit of this field selects whether a byte from within the word or double-word addressed by DBGWVR<n>_EL1 is being watched.BASDescriptionxxxxxxx1Match byte at DBGWVR<n>_EL1xxxxxx1xMatch byte at DBGWVR<n>_EL1+1xxxxx1xxMatch byte at DBGWVR<n>_EL1+2xxxx1xxxMatch byte at DBGWVR<n>_EL1+3In cases where DBGWVR<n>_EL1 addresses a double-word:BASDescription, if DBGWVR<n>_EL1[2] == 0xxx1xxxxMatch byte at DBGWVR<n>_EL1+4xx1xxxxxMatch byte at DBGWVR<n>_EL1+5x1xxxxxxMatch byte at DBGWVR<n>_EL1+61xxxxxxxMatch byte at DBGWVR<n>_EL1+7If DBGWVR<n>_EL1[2] == 1, only BAS[3:0] is used. ARM deprecates setting DBGWVR<n>_EL1 == 1.The valid values for BAS are 0b0000000, or a binary number all of whose set bits are contiguous. All other values are reserved and must not be used by software.If BAS is zero, no bytes are watched by this watchpoint.Ignored if E is 0.'''
  [[register.field]]
    name = "LSC"
    bits = "4:3"
    type = "rw"
    shortdesc = '''Load/store control.'''
    longdesc = '''This field enables watchpoint matching on the type of access being made. Possible values of this field are:All other values are reserved, but must behave as if the watchpoint is disabled. Software must not rely on this property as the behavior of reserved values might change in a future revision of the architecture.Ignored if E is 0.'''
  [[register.field]]
    name = "PAC"
    bits = "2:1"
    type = "rw"
    shortdesc = '''Privilege of access control.'''
    longdesc = '''Determines the exception level or levels at which a watchpoint debug event for watchpoint n is generated. This field must be interpreted along with the SSC and HMC fields.'''
  [[register.field]]
    name = "E"
    bits = "0"
    type = "rw"
    shortdesc = '''Enable watchpoint n.'''
    longdesc = '''Possible values are:'''
[[register]]
  name = "MIDR_EL1"
  type = "ro"
  width = 32
  description = "Main ID Register"
  default = "0x410FD032"
  offset = "0x00000D00"
  [[register.field]]
    name = "IMPLEMENTER"
    bits = "31:24"
    type = "ro"
    shortdesc = '''The Implementer code.'''
    longdesc = '''This field must hold an implementer code that has been assigned by ARM. Assigned codes include the following:Hex representationASCII representationImplementer0x41AARM Limited0x42BBroadcom Corporation0x43CCavium Inc.0x44DDigital Equipment Corporation0x49IInfineon Technologies AG0x4DMMotorola or Freescale Semiconductor Inc.0x4ENNVIDIA Corporation0x50PApplied Micro Circuits Corporation0x51QQualcomm Inc.0x56VMarvell International Ltd.0x69iIntel CorporationARM can assign codes that are not published in this manual. All values not assigned by ARM are reserved and must not be used.'''
  [[register.field]]
    name = "VARIANT"
    bits = "23:20"
    type = "ro"
    shortdesc = '''An IMPLEMENTATION DEFINED variant number.'''
    longdesc = '''Typically, this field is used to distinguish between different product variants, or major revisions of a product.'''
  [[register.field]]
    name = "ARCHITECTURE"
    bits = "19:16"
    type = "ro"
  [[register.field]]
    name = "PARTNUM"
    bits = "15:4"
    type = "ro"
    shortdesc = '''An IMPLEMENTATION DEFINED primary part number for the device.'''
    longdesc = '''On processors implemented by ARM, if the top four bits of the primary part number are 0x0 or 0x7, the variant and architecture are encoded differently.'''
  [[register.field]]
    name = "REVISION"
    bits = "3:0"
    type = "ro"
[[register]]
  name = "ID_AA64PFR0_EL1_31TO0"
  type = "ro"
  width = 32
  description = "Processor Feature Register 0 (low word)"
  default = "0x00002222"
  offset = "0x00000D20"
  [[register.field]]
    name = "GIC"
    bits = "27:24"
    type = "ro"
    shortdesc = '''GIC system register interface.'''
    longdesc = '''Permitted values are:All other values are reserved.'''
  [[register.field]]
    name = "ADVSIMD"
    bits = "23:20"
    type = "ro"
    shortdesc = '''Advanced SIMD.'''
    longdesc = '''Permitted values are:All other values are reserved.'''
  [[register.field]]
    name = "FP"
    bits = "19:16"
    type = "ro"
    shortdesc = '''Floating-point.'''
    longdesc = '''Permitted values are:All other values are reserved.'''
  [[register.field]]
    name = "EL3"
    bits = "15:12"
    type = "ro"
    shortdesc = '''EL3 exception level handling.'''
    longdesc = '''Permitted values are:All other values are reserved.'''
  [[register.field]]
    name = "EL2"
    bits = "11:8"
    type = "ro"
    shortdesc = '''EL2 exception level handling.'''
    longdesc = '''Permitted values are:All other values are reserved.'''
  [[register.field]]
    name = "EL1"
    bits = "7:4"
    type = "ro"
    shortdesc = '''EL1 exception level handling.'''
    longdesc = '''Permitted values are:All other values are reserved.'''
  [[register.field]]
    name = "EL0"
    bits = "3:0"
    type = "ro"
    shortdesc = '''EL0 exception level handling.'''
    longdesc = '''Permitted values are:All other values are reserved.'''
[[register]]
  name = "ID_AA64PFR0_EL1_63TO32"
  type = "ro"
  width = 32
  description = "Processor Feature Register 0 (high word)"
  default = "0x00000000"
  offset = "0x00000D24"
  [[register.field]]
    name = "RESERVED"
    bits = "31:0"
    type = "ro"
[[register]]
  name = "ID_AA64DFR0_EL1_31TO0"
  type = "ro"
  width = 32
  description = "Debug Feature Register 0 (low word)"
  default = "0x10305106"
  offset = "0x00000D28"
  [[register.field]]
    name = "CTX_CMPS"
    bits = "31:28"
    type = "ro"
    shortdesc = '''Number of breakpoints that are context-aware, minus 1.'''
    longdesc = '''These are the highest numbered breakpoints.'''
  [[register.field]]
    name = "WRPS"
    bits = "23:20"
    type = "ro"
    shortdesc = '''Number of watchpoints, minus 1.'''
    longdesc = '''The value of 0b0000 is reserved.'''
  [[register.field]]
    name = "BRPS"
    bits = "15:12"
    type = "ro"
    shortdesc = '''Number of breakpoints, minus 1.'''
    longdesc = '''The value of 0b0000 is reserved.'''
  [[register.field]]
    name = "PMUVER"
    bits = "11:8"
    type = "ro"
    shortdesc = '''Performance Monitors extension version.'''
    longdesc = '''Indicates whether system register interface to Performance Monitors extension is implemented. Permitted values are:All other values are reserved.'''
  [[register.field]]
    name = "TRACEVER"
    bits = "7:4"
    type = "ro"
    shortdesc = '''Trace extension.'''
    longdesc = '''Indicates whether system register interface to Trace extension is implemented. Permitted values are:All other values are reserved.A value of 0b0000 only indicates that no system register interface to the trace extension is implemented. A trace extension may nevertheless be implemented without a system register interface.'''
  [[register.field]]
    name = "DEBUGVER"
    bits = "3:0"
    type = "ro"
    shortdesc = '''Debug architecture version.'''
    longdesc = '''Indicates presence of v8-A debug architecture.All other values are reserved.'''
[[register]]
  name = "ID_AA64DFR0_EL1_63TO32"
  type = "ro"
  width = 32
  description = "Debug Feature Register 0 (high word)"
  default = "0x00000000"
  offset = "0x00000D2C"
  [[register.field]]
    name = "RESERVED"
    bits = "31:0"
    type = "ro"
[[register]]
  name = "ID_AA64ISAR0_EL1_31TO0"
  type = "ro"
  width = 32
  description = "Instruction Set Attribute Register 0 (low word)"
  default = "0x00011120"
  offset = "0x00000D30"
  [[register.field]]
    name = "CRC32"
    bits = "19:16"
    type = "ro"
    shortdesc = '''CRC32 instructions in AArch64.'''
    longdesc = '''Possible values of this field are:All other values are reserved.This field must have the same value as ID_ISAR5.CRC32. The architecture requires that if CRC32 is supported in one Execution state, it must be supported in both Execution states.'''
  [[register.field]]
    name = "SHA2"
    bits = "15:12"
    type = "ro"
    shortdesc = '''SHA2 instructions in AArch64.'''
    longdesc = '''Possible values of this field are:All other values are reserved.'''
  [[register.field]]
    name = "SHA1"
    bits = "11:8"
    type = "ro"
    shortdesc = '''SHA1 instructions in AArch64.'''
    longdesc = '''Possible values of this field are:All other values are reserved.'''
  [[register.field]]
    name = "AES"
    bits = "7:4"
    type = "ro"
    shortdesc = '''AES instructions in AArch64.'''
    longdesc = '''Possible values of this field are:'''
[[register]]
  name = "ID_AA64ISAR0_EL1_63TO32"
  type = "ro"
  width = 32
  description = "Instruction Set Attribute Register 0 (high word)"
  default = "0x00000000"
  offset = "0x00000D34"
  [[register.field]]
    name = "RESERVED"
    bits = "31:0"
    type = "ro"
[[register]]
  name = "ID_AA64MMFR0_EL1_31TO0"
  type = "ro"
  width = 32
  description = "Memory Model Feature Register 0 (low word)"
  default = "0x00001122"
  offset = "0x00000D38"
  [[register.field]]
    name = "TGRAN4"
    bits = "31:28"
    type = "ro"
    shortdesc = '''Support for 4 Kbyte memory translation granule size.'''
    longdesc = '''Permitted values are:All other values are reserved.'''
  [[register.field]]
    name = "TGRAN64"
    bits = "27:24"
    type = "ro"
    shortdesc = '''Support for 64 Kbyte memory translation granule size.'''
    longdesc = '''Permitted values are:All other values are reserved.'''
  [[register.field]]
    name = "TGRAN16"
    bits = "23:20"
    type = "ro"
    shortdesc = '''Support for 16 Kbyte memory translation granule size.'''
    longdesc = '''Permitted values are:All other values are reserved.'''
  [[register.field]]
    name = "BIGENDEL0"
    bits = "19:16"
    type = "ro"
    shortdesc = '''Mixed-endian support at EL0 only.'''
    longdesc = '''Permitted values are:All other values are reserved.This field is invalid and is RES0 if the BigEnd field, bits [11:8], is not 0b0000.'''
  [[register.field]]
    name = "SNSMEM"
    bits = "15:12"
    type = "ro"
    shortdesc = '''Secure versus Non-secure Memory distinction.'''
    longdesc = '''Permitted values are:All other values are reserved.'''
  [[register.field]]
    name = "BIGEND"
    bits = "11:8"
    type = "ro"
    shortdesc = '''Mixed-endian configuration support.'''
    longdesc = '''Permitted values are:All other values are reserved.'''
  [[register.field]]
    name = "ASIDBITS"
    bits = "7:4"
    type = "ro"
    shortdesc = '''Number of ASID bits.'''
    longdesc = '''Permitted values are:All other values are reserved.'''
  [[register.field]]
    name = "PARANGE"
    bits = "3:0"
    type = "ro"
    shortdesc = '''Physical Address range supported.'''
    longdesc = '''Permitted values are:All other values are reserved.'''
[[register]]
  name = "ID_AA64MMFR0_EL1_63TO32"
  type = "ro"
  width = 32
  description = "Memory Model Feature Register 0 (high word)"
  default = "0x00000000"
  offset = "0x00000D3C"
  [[register.field]]
    name = "RESERVED"
    bits = "31:0"
    type = "ro"
[[register]]
  name = "ID_AA64PFR1_EL1_31TO0"
  type = "ro"
  width = 32
  description = "Processor Feature Register 1 (low word)"
  default = "0x00000000"
  offset = "0x00000D40"
  [[register.field]]
    name = "RESERVED"
    bits = "31:0"
    type = "ro"
[[register]]
  name = "ID_AA64PFR1_EL1_63TO32"
  type = "ro"
  width = 32
  description = "Processor Feature Register 1 (high word)"
  default = "0x00000000"
  offset = "0x00000D44"
  [[register.field]]
    name = "RESERVED"
    bits = "31:0"
    type = "ro"
[[register]]
  name = "ID_AA64DFR1_EL1_31TO0"
  type = "ro"
  width = 32
  description = "Auxiliary Feature Register 1 (low word)"
  default = "0x00000000"
  offset = "0x00000D48"
  [[register.field]]
    name = "RESERVED"
    bits = "31:0"
    type = "ro"
[[register]]
  name = "ID_AA64DFR1_EL1_63TO32"
  type = "ro"
  width = 32
  description = "Auxiliary Feature Register 1 (high word)"
  default = "0x00000000"
  offset = "0x00000D4C"
  [[register.field]]
    name = "RESERVED"
    bits = "31:0"
    type = "ro"
[[register]]
  name = "ID_AA64ISAR1_EL1_31TO0"
  type = "ro"
  width = 32
  description = "Instruction Set Attribute Register 1 (low word)"
  default = "0x00000000"
  offset = "0x00000D50"
  [[register.field]]
    name = "RESERVED"
    bits = "31:0"
    type = "ro"
[[register]]
  name = "ID_AA64ISAR1_EL1_63TO32"
  type = "ro"
  width = 32
  description = "Instruction Set Attribute Register 1 (high word)"
  default = "0x00000000"
  offset = "0x00000D54"
  [[register.field]]
    name = "RESERVED"
    bits = "31:0"
    type = "ro"
[[register]]
  name = "ID_AA64MMFR1_EL1_31TO0"
  type = "ro"
  width = 32
  description = "Memory Model Feature Register 1 (low word)"
  default = "0x00000000"
  offset = "0x00000D58"
  [[register.field]]
    name = "RESERVED"
    bits = "31:0"
    type = "ro"
[[register]]
  name = "ID_AA64MMFR1_EL1_63TO32"
  type = "ro"
  width = 32
  description = "Memory Model Feature Register 1 (high word)"
  default = "0x00000000"
  offset = "0x00000D5C"
  [[register.field]]
    name = "RESERVED"
    bits = "31:0"
    type = "ro"
[[register]]
  name = "ITCTRL"
  type = "rw"
  width = 32
  description = "External Debug Integration mode Control Register"
  default = "0x00000000"
  offset = "0x00000F00"
  [[register.field]]
    name = "IME"
    bits = "0"
    type = "rw"
    shortdesc = '''Integration mode enable.'''
    longdesc = '''When IME == 1, the device reverts to an integration mode to enable integration testing or topology detection. The integration mode behavior is IMPLEMENTATION DEFINED.'''
[[register]]
  name = "CLAIMSET"
  type = "rw"
  width = 32
  description = "Debug Claim Tag Set Register"
  default = "0x00000000"
  offset = "0x00000FA0"
  [[register.field]]
    name = "CLAIM"
    bits = "7:0"
    type = "rw"
    shortdesc = '''Claim set bits.'''
    longdesc = '''RAO.Writing a 1 to one of these bits sets the corresponding CLAIM bit to 1. This is an indirect write to the CLAIM bits.A single write operation can set multiple bits to 1. Writing 0 to one of these bits has no effect.'''
[[register]]
  name = "CLAIMCLR"
  type = "rw"
  width = 32
  description = "Debug Claim Tag Clear Register"
  default = "0x00000000"
  offset = "0x00000FA4"
  [[register.field]]
    name = "CLAIM"
    bits = "7:0"
    type = "rw"
    shortdesc = '''Claim clear bits.'''
    longdesc = '''Reading this field returns the current value of the CLAIM bits.Writing a 1 to one of these bits clears the corresponding CLAIM bit to 0. This is an indirect write to the CLAIM bits.A single write operation can clear multiple bits to 0. Writing 0 to one of these bits has no effect.'''
[[register]]
  name = "DEVAFF0"
  type = "ro"
  width = 32
  description = "External Debug Device Affinity Register 0"
  default = "0x80000000"
  offset = "0x00000FA8"
  [[register.field]]
    name = "EDDEVAFF0"
    bits = "31:0"
    type = "ro"
    shortdesc = '''MPIDR_EL1 low half.'''
    longdesc = '''Read-only copy of the low half of MPIDR_EL1, as seen from the highest implemented exception level.'''
[[register]]
  name = "DEVAFF1"
  type = "ro"
  width = 32
  description = "External Debug Device Affinity Register 1"
  default = "0x00000000"
  offset = "0x00000FAC"
  [[register.field]]
    name = "EDDEVAFF1"
    bits = "31:0"
    type = "ro"
    shortdesc = '''MPIDR_EL1 high half.'''
    longdesc = '''Read-only copy of the high half of MPIDR_EL1, as seen from the highest implemented exception level.'''
[[register]]
  name = "LAR"
  type = "wo"
  width = 32
  description = "External Debug Lock Access Register"
  default = "0x00000000"
  offset = "0x00000FB0"
  [[register.field]]
    name = "KEY"
    bits = "31:0"
    type = "wo"
    shortdesc = '''Lock Access control.'''
    longdesc = '''Writing the key value 0xC5ACCE55 to this field unlocks the lock, enabling write accesses to this component's registers through a memory-mapped interface.Writing any other value to this register locks the lock, disabling write accesses to this component's registers through a memory mapped interface.'''
[[register]]
  name = "LSR"
  type = "ro"
  width = 32
  description = "External Debug Lock Status Register"
  default = "0x00000000"
  offset = "0x00000FB4"
  [[register.field]]
    name = "NTT"
    bits = "2"
    type = "ro"
    shortdesc = '''Not thirty-two bit access required.'''
    longdesc = '''RAZ.'''
  [[register.field]]
    name = "SLK"
    bits = "1"
    type = "ro"
    shortdesc = '''Software lock status for this component.'''
    longdesc = '''For an access to LSR that is not a memory-mapped access, or when the software lock is not implemented, this field is RES0.For memory-mapped accesses when the software lock is implemented, possible values of this field are:'''
  [[register.field]]
    name = "SLI"
    bits = "0"
    type = "ro"
    shortdesc = '''Software lock implemented.'''
    longdesc = '''For an access to LSR that is not a memory-mapped access, this field is RAZ. For memory-mapped accesses, the value of this field is IMPLEMENTATION DEFINED. Permitted values are:'''
[[register]]
  name = "AUTHSTATUS"
  type = "ro"
  width = 32
  description = "Debug Authentication Status register"
  default = "0x000000AA"
  offset = "0x00000FB8"
  [[register.field]]
    name = "SNID"
    bits = "7:6"
    type = "ro"
    shortdesc = '''Secure non-invasive debug.'''
    longdesc = '''Possible values of this field are:Other values are reserved.'''
  [[register.field]]
    name = "SID"
    bits = "5:4"
    type = "ro"
    shortdesc = '''Secure invasive debug.'''
    longdesc = '''Possible values of this field are:Other values are reserved.'''
  [[register.field]]
    name = "NSNID"
    bits = "3:2"
    type = "ro"
    shortdesc = '''Non-secure non-invasive debug.'''
    longdesc = '''Possible values of this field are:Other values are reserved.'''
  [[register.field]]
    name = "NSID"
    bits = "1:0"
    type = "ro"
    shortdesc = '''Non-secure invasive debug.'''
    longdesc = '''Possible values of this field are:Other values are reserved.'''
[[register]]
  name = "DEVARCH"
  type = "ro"
  width = 32
  description = "External Debug Device Architecture Register"
  default = "0x47706A15"
  offset = "0x00000FBC"
  [[register.field]]
    name = "ARCHITECT"
    bits = "31:21"
    type = "ro"
    shortdesc = '''Defines the architecture of the component.'''
    longdesc = '''For debug, this is ARM Limited.Bits [31:28] are the JEP 106 continuation code, 0x4.Bits [27:21] are the JEP 106 ID code, 0x3B.'''
  [[register.field]]
    name = "PRESENT"
    bits = "20"
    type = "ro"
    shortdesc = '''When set to 1, indicates that the DEVARCH is present.'''
    longdesc = '''This field is 1 in v8-A.'''
  [[register.field]]
    name = "REVISION"
    bits = "19:16"
    type = "ro"
    shortdesc = '''Defines the architecture revision.'''
    longdesc = '''For architectures defined by ARM this is the minor revision.For debug, the revision defined by v8-A is 0x0.All other values are reserved.'''
  [[register.field]]
    name = "ARCHID"
    bits = "15:0"
    type = "ro"
    shortdesc = '''Defines this part to be a v8-A debug component.'''
    longdesc = '''For architectures defined by ARM this is further subdivided.For debug:Bits [15:12] are the architecture version, 0x6.Bits [11:0] are the architecture part number, 0xA15.This corresponds to debug architecture version v8-A.'''
[[register]]
  name = "DEVID2"
  type = "ro"
  width = 32
  description = "External Debug Device ID Register 2"
  default = "0x00000000"
  offset = "0x00000FC0"
  [[register.field]]
    name = "RESERVED"
    bits = "31:0"
    type = "ro"
[[register]]
  name = "DEVID1"
  type = "ro"
  width = 32
  description = "External Debug Device ID Register 1"
  default = "0x00000002"
  offset = "0x00000FC4"
  [[register.field]]
    name = "PCSROFFSET"
    bits = "3:0"
    type = "ro"
    shortdesc = '''This field indicates the offset applied to PC samples returned by reads of EDPCSR.'''
    longdesc = '''Permitted values of this field in v8-A are:'''
[[register]]
  name = "DEVID"
  type = "ro"
  width = 32
  description = "External Debug Device ID Register 0"
  default = "0x00000003"
  offset = "0x00000FC8"
  [[register.field]]
    name = "AUXREGS"
    bits = "27:24"
    type = "ro"
    shortdesc = '''Indicates support for Auxiliary registers.'''
    longdesc = '''Permitted values for this field are:All other values are reserved.'''
  [[register.field]]
    name = "PCSAMPLE"
    bits = "3:0"
    type = "ro"
    shortdesc = '''Indicates the level of Sample-based profiling support using external debug registers 40 through 43.'''
    longdesc = '''Permitted values of this field in v8-A are:All other values are reserved.'''
[[register]]
  name = "DEVTYPE"
  type = "ro"
  width = 32
  description = "External Debug Device Type Register"
  default = "0x00000015"
  offset = "0x00000FCC"
  [[register.field]]
    name = "SUB"
    bits = "7:4"
    type = "ro"
    shortdesc = '''Subtype.'''
    longdesc = '''Must read as 0x1 to indicate this is a processor component.'''
  [[register.field]]
    name = "MAJOR"
    bits = "3:0"
    type = "ro"
    shortdesc = '''Major type.'''
    longdesc = '''Must read as 0x5 to indicate this is a debug logic component.'''
[[register]]
  name = "PIDR4"
  type = "ro"
  width = 32
  description = "External Debug Peripheral Identification Register 4"
  default = "0x00000004"
  offset = "0x00000FD0"
  [[register.field]]
    name = "SIZE"
    bits = "7:4"
    type = "ro"
    shortdesc = '''Size of the component.'''
    longdesc = '''RAZ. Log2 of the number of 4KB pages from the start of the component to the end of the component ID registers.'''
  [[register.field]]
    name = "DES_2"
    bits = "3:0"
    type = "ro"
    shortdesc = '''Designer, JEP106 continuation code, least significant nibble.'''
    longdesc = '''For ARM Limited, this field is 0b0100.'''
[[register]]
  name = "PIDR5"
  type = "ro"
  width = 32
  description = "CTI Peripheral Identification Register 5"
  default = "0x00000000"
  offset = "0x00000FD4"
  [[register.field]]
    name = "RESERVED"
    bits = "31:0"
    type = "ro"
[[register]]
  name = "PIDR6"
  type = "ro"
  width = 32
  description = "CTI Peripheral Identification Register 6"
  default = "0x00000000"
  offset = "0x00000FD8"
  [[register.field]]
    name = "RESERVED"
    bits = "31:0"
    type = "ro"
[[register]]
  name = "PIDR7"
  type = "ro"
  width = 32
  description = "CTI Peripheral Identification Register 7"
  default = "0x00000000"
  offset = "0x00000FDC"
  [[register.field]]
    name = "RESERVED"
    bits = "31:0"
    type = "ro"
[[register]]
  name = "PIDR0"
  type = "ro"
  width = 32
  description = "External Debug Peripheral Identification Register 0"
  default = "0x00000003"
  offset = "0x00000FE0"
  [[register.field]]
    name = "PART_0"
    bits = "7:0"
    type = "ro"
[[register]]
  name = "PIDR1"
  type = "ro"
  width = 32
  description = "External Debug Peripheral Identification Register 1"
  default = "0x000000BD"
  offset = "0x00000FE4"
  [[register.field]]
    name = "DES_0"
    bits = "7:4"
    type = "ro"
    shortdesc = '''Designer, least significant nibble of JEP106 ID code.'''
    longdesc = '''For ARM Limited, this field is 0b1011.'''
  [[register.field]]
    name = "PART_1"
    bits = "3:0"
    type = "ro"
[[register]]
  name = "PIDR2"
  type = "ro"
  width = 32
  description = "External Debug Peripheral Identification Register 2"
  default = "0x0000004B"
  offset = "0x00000FE8"
  [[register.field]]
    name = "REVISION"
    bits = "7:4"
    type = "ro"
    shortdesc = '''Part major revision.'''
    longdesc = '''Parts can also use this field to extend Part number to 16-bits.'''
  [[register.field]]
    name = "JEDEC"
    bits = "3"
    type = "ro"
    shortdesc = '''RAO.'''
    longdesc = '''Indicates a JEP106 identity code is used.'''
  [[register.field]]
    name = "DES_1"
    bits = "2:0"
    type = "ro"
    shortdesc = '''Designer, most significant bits of JEP106 ID code.'''
    longdesc = '''For ARM Limited, this field is 0b011.'''
[[register]]
  name = "PIDR3"
  type = "ro"
  width = 32
  description = "External Debug Peripheral Identification Register 3"
  default = "0x00000000"
  offset = "0x00000FEC"
  [[register.field]]
    name = "REVAND"
    bits = "7:4"
    type = "ro"
    shortdesc = '''Part minor revision.'''
    longdesc = '''Parts using EDPIDR2.REVISION as an extension to the Part number must use this field as a major revision number.'''
  [[register.field]]
    name = "CMOD"
    bits = "3:0"
    type = "ro"
    shortdesc = '''Customer modified.'''
    longdesc = '''Indicates someone other than the Designer has modified the component.'''
[[register]]
  name = "CIDR0"
  type = "ro"
  width = 32
  description = "External Debug Component Identification Register 0"
  default = "0x0000000D"
  offset = "0x00000FF0"
  [[register.field]]
    name = "PRMBL_0"
    bits = "7:0"
    type = "ro"
    shortdesc = '''Preamble.'''
    longdesc = '''Must read as 0x0D.'''
[[register]]
  name = "CIDR1"
  type = "ro"
  width = 32
  description = "External Debug Component Identification Register 1"
  default = "0x00000090"
  offset = "0x00000FF4"
  [[register.field]]
    name = "CLASS"
    bits = "7:4"
    type = "ro"
    shortdesc = '''Component class.'''
    longdesc = '''Reads as 0x9, debug component.'''
  [[register.field]]
    name = "PRMBL_1"
    bits = "3:0"
    type = "ro"
    shortdesc = '''Preamble.'''
    longdesc = '''RAZ.'''
[[register]]
  name = "CIDR2"
  type = "ro"
  width = 32
  description = "External Debug Component Identification Register 2"
  default = "0x00000005"
  offset = "0x00000FF8"
  [[register.field]]
    name = "PRMBL_2"
    bits = "7:0"
    type = "ro"
    shortdesc = '''Preamble.'''
    longdesc = '''Must read as 0x05.'''
[[register]]
  name = "CIDR3"
  type = "ro"
  width = 32
  description = "External Debug Component Identification Register 3"
  default = "0x000000B1"
  offset = "0x00000FFC"
  [[register.field]]
    name = "PRMBL_3"
    bits = "7:0"
    type = "ro"
    shortdesc = '''Preamble.'''
    longdesc = '''Must read as 0xB1.'''
