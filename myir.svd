<device schemaVersion="1.3" xs:noNamespaceSchemaLocation="etc/CMSIS-SVD.xsd" xmlns:xs="http://www.w3.org/2001/XMLSchema-instance">
  <vendor>overlord</vendor>
  <vendorID>OVER</vendorID>
  <name>myir</name>
  <version>0.0.0</version>
  <description>myir</description>
  <licenseText>// SPDX-License-Identifier: MIT\n</licenseText>
  <cpu>
    <name>CA53</name>
    <revision>r0p0</revision>
    <endian>little</endian>
    <mpuPresent>false</mpuPresent>
    <fpuPresent>true</fpuPresent>
    <icachePresent>true</icachePresent>
    <dcachePresent>true</dcachePresent>
    <itcmPresent>false</itcmPresent>
    <dtcmPresent>false</dtcmPresent>
    <vtorPresent>false</vtorPresent>
    <nvicPrioBits>0</nvicPrioBits>
    <vendorSystickConfig>false</vendorSystickConfig>
  </cpu>
  <addressUnitBits>8</addressUnitBits>
  <width>32</width>
  <size>32</size>
  <access>read-write</access>
  <resetValue>0x00000000</resetValue>
  <resetMask>0xFFFFFFFF</resetMask>
  <peripherals>
    <peripheral>
      <name>SD0</name>
      <version>1.0</version>
      <description>SDIO 0 Controller</description>
      <baseAddress>0xff160000</baseAddress>
      <addressBlock>
        <offset>0x0</offset>
        <size>0x000000FE</size>
        <usage>registers</usage>
        <protection>s</protection>
      </addressBlock>
      <registers>
        <register>
          <name>REG_SDMASYSADDRLO</name>
          <description>Dual purpose: low SDMA address, Auto CMD23 arg.</description>
          <addressOffset>0x00000000</addressOffset>
          <size>16</size>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>SDMA_SYSADDRESS</name>
              <description> </description>
              <lsb>0</lsb>
              <msb>15</msb>
            </field>
          </fields>
        </register>
        <register>
          <name>REG_SDMASYSADDRHI</name>
          <description>Dual purpose: high SDMA address, Auto CMD23 arg.</description>
          <addressOffset>0x00000002</addressOffset>
          <size>16</size>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>SDMA_SYSADDRESS</name>
              <description> </description>
              <lsb>0</lsb>
              <msb>15</msb>
            </field>
          </fields>
        </register>
        <register>
          <name>REG_BLOCKSIZE</name>
          <description>Configure the Number of Bytes in a Data Block.</description>
          <addressOffset>0x00000004</addressOffset>
          <size>16</size>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>SDMA_BUFBOUNDARY</name>
              <description> The System Address register is updated at every system boundary during the DMA transfer The DMA transfer waits at the every boundary specified by these fields and the SDIO controller generates the DMA interrupt to request the controller to update the System Address register. This function is active when the [DMA Enable] bit in the Transfer Mode register is set = 1. 000b: 4KB 001b: 8KB 010b: 16KB 011b: 32KB 100b: 64KB 101b: 128KB 110b: 256KB 111b: 512KB </description>
              <lsb>12</lsb>
              <msb>14</msb>
            </field>
            <field>
              <name>XFER_BLOCKSIZE</name>
              <description> Read-only. Valid if no transaction is executing (i.e after a transaction has stopped). 0000h: No data transfer. 0001h: 1 byte 0002h: 2 bytes 0003h: 3 bytes .. 0200h: 512 bytes .. 0800h: 2048 bytes (maximum block size) </description>
              <lsb>0</lsb>
              <msb>11</msb>
            </field>
          </fields>
        </register>
        <register>
          <name>REG_BLOCKCOUNT</name>
          <description>Configure the number of data blocks</description>
          <addressOffset>0x00000006</addressOffset>
          <size>16</size>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>XFER_BLOCKCOUNT</name>
              <description> The controller decrements the block count after each block transfer and stops transfers when the count reaches zero. 0000h: 0 blocks, transfers stop. 0001h: 1 block. 0002h: 2 blocks. .. FFFFh: 65535 blocks. This register is enabled when Block Count Enable in the Transfer Mode register is set to 1 and is valid only for multi-block transfers. Accessed the register when no transactions are executing (i.e., after a transaction has stopped). During a transfer, reads return an invalid value and writes are ignored. When saving transfer context as a result of Suspend command, the number of blocks yet to be transferred can be determined by reading this register. When restoring transfer context prior to issuing a Resume command, the Host Driver shall restore the previously save block count. </description>
              <lsb>0</lsb>
              <msb>15</msb>
            </field>
          </fields>
        </register>
        <register>
          <name>REG_ARGUMENT1LO</name>
          <description>Lower bits of SD Command Argument</description>
          <addressOffset>0x00000008</addressOffset>
          <size>16</size>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>COMMAND_ARGUMENT1</name>
              <description> </description>
              <lsb>0</lsb>
              <msb>15</msb>
            </field>
          </fields>
        </register>
        <register>
          <name>REG_ARGUMENT1HI</name>
          <description>Upper bits of SD Command Argument</description>
          <addressOffset>0x0000000A</addressOffset>
          <size>16</size>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>COMMAND_ARGUMENT1</name>
              <description> </description>
              <lsb>0</lsb>
              <msb>15</msb>
            </field>
          </fields>
        </register>
        <register>
          <name>REG_TRANSFERMODE</name>
          <description>Control the Data Transfer Operations.</description>
          <addressOffset>0x0000000C</addressOffset>
          <size>16</size>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>XFERMODE_MULTIBLKSEL</name>
              <description> '0' Single Block.'1' Multiple Block. </description>
              <lsb>5</lsb>
              <msb>5</msb>
            </field>
            <field>
              <name>XFERMODE_DATAXFERDIR</name>
              <description> 0: Write from Host to Card. 1: Read from Card to Host. </description>
              <lsb>4</lsb>
              <msb>4</msb>
            </field>
            <field>
              <name>XFERMODE_AUTOCMDENA</name>
              <description> 00: Auto Command Disabled. 01: Auto CMD12 Enabled. 10: Auto CMD23 Enabled. 11: reserved. There are two methods to stop multiple-block read and write operation. (1) Auto CMD12 Enable: Multiple-block read and write commands for memory require CMD12 to stop the operation. The controller issues CMD12 automatically when the last block transfer is completed. Auto CMD12 error is indicated in the Auto CMD Error Status register. The driver shall not set this bit if the command does not require Auto CMD12. (2) Auto CMD23 Enable: The controller issues an Auto CMD23 before issuing a command specified in the Command Register. The following conditions are required to use the Auto CMD23. * Auto CMD23 Supported (Host Controller Version is 3.00 or later). * A memory card that supports CMD23 (SCR[33]=1). * If DMA is used, it shall be ADMA. * Only when CMD18 or CMD25 is issued. By writing the Command register, the controller issues a CMD23 first and then issues a command specified by the Command Index in Command register 32-bit block count value for CMD23 is set to SDMA System Address / Argument 2 register. </description>
              <lsb>2</lsb>
              <msb>3</msb>
            </field>
            <field>
              <name>XFERMODE_BLKCNTENA</name>
              <description> 0: disable (setting is also useful for executing an infinite transfer). 1: enable. Applicable to multiple block transfers. </description>
              <lsb>1</lsb>
              <msb>1</msb>
            </field>
            <field>
              <name>XFERMODE_DMAENABLE</name>
              <description> If this bit is set to 1, a DMA operation shall begin when the Host Driver writes to the upper byte of Command register (00Fh). 0: disable DMA. 1: enable DMA. </description>
              <lsb>0</lsb>
              <msb>0</msb>
            </field>
          </fields>
        </register>
        <register>
          <name>REG_COMMAND</name>
          <description>Controller Commands.</description>
          <addressOffset>0x0000000E</addressOffset>
          <size>16</size>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>COMMAND_CMDINDEX</name>
              <description> * ACMD [0:63]. </description>
              <lsb>8</lsb>
              <msb>13</msb>
            </field>
            <field>
              <name>COMMAND_CMDTYPE</name>
              <description> Suspend Command: If the Suspend command succeeds, the controller assumes the SD I/O has been released and that it is possible to issue the next command using the SD_DAT signals. The controller de-asserts Read Wait for read transactions and stops checking busy for write transactions. The Interrupt cycle starts in 4-bit mode. If the Suspend command fails, the controller maintain its current state. and the controller shall restart the transfer by setting Continue Request in the Block Gap Control Register. Resume Command: The SDIO controller re-starts the data transfer by restoring the registers in the range of 000-00Dh. The controller checks for busy before starting write transfers. Abort Command: * If this command is set when executing a read transfer, the controller stops adding content to the receive buffer. * If this command is set when executing a write transfer, the controller stops driving the SD_DAT signals. After issuing the Abort command, the controller should issue a software reset. 00: Normal 01: Suspend 10: Resume 11: Abort </description>
              <lsb>6</lsb>
              <msb>7</msb>
            </field>
            <field>
              <name>COMMAND_DATAPRESENT</name>
              <description> If is set to 0 for the following: 1. Commands using only CMD line (ex. CMD52). 2. Commands with no data transferbut using busy signal on DAT[0]line (R1b or R5b ex. CMD38). 3. Resume Command.'0' Data not Present'1' Data present </description>
              <lsb>5</lsb>
              <msb>5</msb>
            </field>
            <field>
              <name>COMMAND_INDEXCHKENA</name>
              <description> If it is not, it is reported as a Command Index Error. If this bit is set to 0, the Index field is not checked.'0' Disable'1' Enable </description>
              <lsb>4</lsb>
              <msb>4</msb>
            </field>
            <field>
              <name>COMMAND_CRCCHKENA</name>
              <description> If an error is detected, it is reported as a Command CRC Error. If this bit is set to 0, the CRC field is not checked.'0' Disable'1' Enable </description>
              <lsb>3</lsb>
              <msb>3</msb>
            </field>
            <field>
              <name>COMMAND_RESPONSETYPE</name>
              <description> '00' No Response'01' Response Length 136'10' Response Length 48'11' Response Length 48 check busy after response </description>
              <lsb>0</lsb>
              <msb>1</msb>
            </field>
          </fields>
        </register>
        <register>
          <name>REG_RESPONSE0</name>
          <description>Response 0 from SD Card.</description>
          <addressOffset>0x00000010</addressOffset>
          <size>16</size>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>COMMAND_RESPONSE</name>
              <description> </description>
              <lsb>0</lsb>
              <msb>15</msb>
            </field>
          </fields>
        </register>
        <register>
          <name>REG_RESPONSE1</name>
          <description>This register is used to store responses from SD Cards</description>
          <addressOffset>0x00000012</addressOffset>
          <size>16</size>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>COMMAND_RESPONSE</name>
              <description> </description>
              <lsb>0</lsb>
              <msb>15</msb>
            </field>
          </fields>
        </register>
        <register>
          <name>REG_RESPONSE2</name>
          <description>This register is used to store responses from SD Cards</description>
          <addressOffset>0x00000014</addressOffset>
          <size>16</size>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>COMMAND_RESPONSE</name>
              <description> </description>
              <lsb>0</lsb>
              <msb>15</msb>
            </field>
          </fields>
        </register>
        <register>
          <name>REG_RESPONSE3</name>
          <description>This register is used to store responses from SD Cards</description>
          <addressOffset>0x00000016</addressOffset>
          <size>16</size>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>COMMAND_RESPONSE</name>
              <description> </description>
              <lsb>0</lsb>
              <msb>15</msb>
            </field>
          </fields>
        </register>
        <register>
          <name>REG_RESPONSE4</name>
          <description>This register is used to store responses from SD Cards</description>
          <addressOffset>0x00000018</addressOffset>
          <size>16</size>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>COMMAND_RESPONSE</name>
              <description> </description>
              <lsb>0</lsb>
              <msb>15</msb>
            </field>
          </fields>
        </register>
        <register>
          <name>REG_RESPONSE5</name>
          <description>This register is used to store responses from SD Cards</description>
          <addressOffset>0x0000001A</addressOffset>
          <size>16</size>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>COMMAND_RESPONSE</name>
              <description> </description>
              <lsb>0</lsb>
              <msb>15</msb>
            </field>
          </fields>
        </register>
        <register>
          <name>REG_RESPONSE6</name>
          <description>This register is used to store responses from SD Cards</description>
          <addressOffset>0x0000001C</addressOffset>
          <size>16</size>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>COMMAND_RESPONSE</name>
              <description> </description>
              <lsb>0</lsb>
              <msb>15</msb>
            </field>
          </fields>
        </register>
        <register>
          <name>REG_RESPONSE7</name>
          <description>This register is used to store responses from SD Cards</description>
          <addressOffset>0x0000001E</addressOffset>
          <size>16</size>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>COMMAND_RESPONSE</name>
              <description> </description>
              <lsb>0</lsb>
              <msb>15</msb>
            </field>
          </fields>
        </register>
        <register>
          <name>REG_DATAPORT</name>
          <description>Read/write internal buffer.</description>
          <addressOffset>0x00000020</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>SDHCDMACTRL_PIOBUFRDDATA</name>
              <description> </description>
              <lsb>0</lsb>
              <msb>31</msb>
            </field>
          </fields>
        </register>
        <register>
          <name>REG_PRESENTSTATE</name>
          <description>SDIO Controller Status, read-only.</description>
          <addressOffset>0x00000024</addressOffset>
          <size>32</size>
          <resetValue>0x00080000</resetValue>
          <fields>
            <field>
              <name>SDIF_DAT7IN_DSYNC</name>
              <description> </description>
              <lsb>28</lsb>
              <msb>28</msb>
            </field>
            <field>
              <name>SDIF_DAT6IN_DSYNC</name>
              <description> </description>
              <lsb>27</lsb>
              <msb>27</msb>
            </field>
            <field>
              <name>SDIF_DAT5IN_DSYNC</name>
              <description> </description>
              <lsb>26</lsb>
              <msb>26</msb>
            </field>
            <field>
              <name>SDIF_DAT4IN_DSYNC</name>
              <description> </description>
              <lsb>25</lsb>
              <msb>25</msb>
            </field>
            <field>
              <name>SDIF_CMDIN_DSYNC</name>
              <description> </description>
              <lsb>24</lsb>
              <msb>24</msb>
            </field>
            <field>
              <name>SDIF_DAT3IN_DSYNC</name>
              <description> This is especially useful in detecting the busy signal level from DAT[0]. </description>
              <lsb>23</lsb>
              <msb>23</msb>
            </field>
            <field>
              <name>SDIF_DAT2IN_DSYNC</name>
              <description> This is especially useful in detecting the busy signal level from DAT[0]. </description>
              <lsb>22</lsb>
              <msb>22</msb>
            </field>
            <field>
              <name>SDIF_DAT1IN_DSYNC</name>
              <description> This is especially useful in detecting the busy signal level from DAT[0]. </description>
              <lsb>21</lsb>
              <msb>21</msb>
            </field>
            <field>
              <name>SDIF_DAT0IN_DSYNC</name>
              <description> This is especially useful in detecting the busy signal level from DAT[0]. </description>
              <lsb>20</lsb>
              <msb>20</msb>
            </field>
            <field>
              <name>SDIF_WP_DSYNC</name>
              <description> This bit reflects the inversion of the SDx_WP pin. 0: Write protected, SDx_WP pin = High. 1: Write enabled, SDx_WP pin = Low. </description>
              <lsb>19</lsb>
              <msb>19</msb>
            </field>
            <field>
              <name>SDIF_CD_N_DSYNC</name>
              <description> 0: No Card present, SDx_CDn pin = High. 1: Card present, SDx_CDn pin = Low. </description>
              <lsb>18</lsb>
              <msb>18</msb>
            </field>
            <field>
              <name>SDHCCARDDET_STATESTABLE_DSYNC</name>
              <description> If it is 0, the Card Detect Pin Level is not stable. If this bit is set to 1,it means the Card Detect Pin Level is stable. The Software Reset For All in the Software Reset Register shall not affect this bit.'0' Reset of Debouncing'1' No Card or Inserted </description>
              <lsb>17</lsb>
              <msb>17</msb>
            </field>
            <field>
              <name>SDHCCARDDET_INSERTED_DSYNC</name>
              <description> Read-only. Changing from 0 to 1 generates a Card Insertion interrupt in the Normal Interrupt Status register. Changing from 1 to 0 generates a Card Removal interrupt in the Normal Interrupt Status register. The Software Reset For All in the Software Reset register does not affect this bit. If a Card is removed while its power is on and its clock is oscillating, the controller clears SD Bus Power in the Power Control register and SD Clock Enable in the Clock control register. In addition the Host Driver should clear the controller using the Software Reset For All in Software register. The card detect is active regardless of the SD Bus Power. 0: Reset or Debouncing or No Card. 1: Card Inserted. </description>
              <lsb>16</lsb>
              <msb>16</msb>
            </field>
            <field>
              <name>SDHCDMACTRL_PIOBUFRDENA</name>
              <description> This read only flag indicates that valid data exists in the host side buffer status. If this bit is 1, readable data exists in the buffer. A change of this bit from 1 to 0 occurs when all the block data is read from the buffer. A change of this bit from 0 to 1 occurs when all the block data is ready in the buffer and generates the Buffer Read Ready Interrupt.'0' Read Disable'1' Read Enable </description>
              <lsb>11</lsb>
              <msb>11</msb>
            </field>
            <field>
              <name>SDHCDMACTRL_PIOBUFWRENA</name>
              <description> Read-only. This flag indicates if space is available for writing data. 0: do not write to the register port. 1: data can be written to the buffer via the register port. A change from 1 to 0 indicates the buffer is full. A change from 0 to 1 occurs when top of block data can be written to the buffer and generates the Buffer Write Ready Interrupt. </description>
              <lsb>10</lsb>
              <msb>10</msb>
            </field>
            <field>
              <name>SDHCDMACTRL_RDXFERACTIVE</name>
              <description> Read-only. This bit is set to 1 for either of the following conditions: * After the end bit of the read command, or * When writing a 1 to continue Request in the Block Gap Control register to restart a read transfer. This bit is cleared to 0 for either of the following conditions: * When the last data block as specified by block length is transferred to the system, or * When all valid data blocks have been transferred to the system and no current block transfers are being sent as a result of the Stop At Block Gap Request set to 1. A transfer complete interrupt is generated when this bit changes to 0. 0: No valid data 1: Transferring data </description>
              <lsb>9</lsb>
              <msb>9</msb>
            </field>
            <field>
              <name>SDHCDMACTRL_WRXFERACTIVE</name>
              <description> If this bit is 0, it means no valid write data exists in the HC. This bit is set in either of the following cases: * After the end bit of the write command. * When writing a 1 to Continue Request in the Block Gap Control register to restart a write transfer. This bit is cleared in either of the following cases: * After getting the CRC status of the last data block as specified by the transfer count (Single or Multiple) * After getting a CRC status of any block where data transmission is about to be stopped by a Stop At Block Gap Request. During a write transaction, a Block Gap Event interrupt is generated when this bit is changed to 0, as a result of the Stop At Block Gap Request being set. This status is useful for the HD in determining when to issue commands during write busy.'0' No valid data'1' Transferring data </description>
              <lsb>8</lsb>
              <msb>8</msb>
            </field>
            <field>
              <name>SDHCSDCTRL_RETUNINGREQ_DSYNC</name>
              <description> Re-tune the I/O timing when the data window is shifted by temperature changes or to improve timing margins to receive correct data. 0: Sampling clock is okay (it's fixed timing or well tuned). 1: Re-tune the sampling clock. This bit is set = 0 when a command is issued by setting the Execute Tuning bit in the Host Control 2 register. When software writes this bit from a 0 to 1 and [Sampling Clock Select] = 1 (not fixed sampling), the controller triggers the re-tune event. Refer to Normal Interrupt registers for more detail. </description>
              <lsb>3</lsb>
              <msb>3</msb>
            </field>
            <field>
              <name>SDHCDMACTRL_DATALINEACTIVE</name>
              <description> 1: active. </description>
              <lsb>2</lsb>
              <msb>2</msb>
            </field>
            <field>
              <name>PRESENTSTATE_INHIBITDAT</name>
              <description> [ ] 0: controller can issue the next SD command. Commands with busy signal belong to Command Inhibit (DAT) (ex. R1b, R5b type). When the status indicator changes from a 0 to 1, the Transfer Complete interrupt asserts. Note: The SD Host Driver can save registers in the range of 000-00Dh; for a suspend transaction this bit changes from 1 to 0.'0' Can issue command which uses the DAT line'1' Cannot issue command which uses the DATline </description>
              <lsb>1</lsb>
              <msb>1</msb>
            </field>
            <field>
              <name>PRESENTSTATE_INHIBITCMD</name>
              <description> 0: The CMD line is not in use and the controller can issue a SD command using the CMD line. This bit is set immediately after the Command register (00Fh) is written. This bit is cleared when the command response is received. Even if the Command Inhibit (DAT) is set to 1, Commands using only the CMD line can be issued if this bit is 0. Changing from 1 to 0 generates a Command complete interrupt in the Normal Interrupt Status register. If the controller cannot issue the command because of a command conflict error or because of Command Not Issued By Auto CMD12 Error, this bit remains a 1 and the Command Complete interrupt is not set. Status issuing Auto CMD12 is not read from this bit. Auto CMD12 and Auto CMD23 consist of two responses. In this case, this bit is not cleared by the response of CMD12 or CMD23 but cleared by the response of a read/write command. Status issuing Auto CMD12 is not read from this bit. So if a command is issued during Auto CMD12 operation, controller issues two commands: CMD12 and a command set by Command register. </description>
              <lsb>0</lsb>
              <msb>0</msb>
            </field>
          </fields>
        </register>
        <register>
          <name>REG_HOSTCONTROL1</name>
          <description>Controller Configuration.</description>
          <addressOffset>0x00000028</addressOffset>
          <size>8</size>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>HOSTCTRL1_CDSIGSELECT</name>
              <description> 0: SD_CDn is selected (for normal use) 1: The card detect test level is selected </description>
              <lsb>7</lsb>
              <msb>7</msb>
            </field>
            <field>
              <name>HOSTCTRL1_CDTESTLEVEL</name>
              <description> Generates (card ins or card removal) interrupt when the normal int sts enable bit is set.'0' No Card'1' Card Inserted </description>
              <lsb>6</lsb>
              <msb>6</msb>
            </field>
            <field>
              <name>HOSTCTRL1_EXTDATAWIDTH</name>
              <description> Support of this function is indicated in 8-bit Support for Embedded Device in the Capabilities register. If a device supports 8-bit bus mode, this bit may be set to 1. If this bit is 0, bus width is controlled by Data Transfer Width in the Host Control 1 register.This bit is not effective when multiple devices are installed on a bus slot (Slot Type is set to 10b in the Capabilities register). In this case, each device bus width is controlled by Bus Width Preset field in the Shared Bus register.'0' Bus width is selected by data transfer width'1' 8-bit bus width </description>
              <lsb>5</lsb>
              <msb>5</msb>
            </field>
            <field>
              <name>HOSTCTRL1_DMASELECT</name>
              <description> The host driver shall check support of DMA modes by referring the Capabilities register.'00' SDMA'01' 32 bit ADMA1 address'10' 32 bit ADMA2 address'11' 64 bit ADMA2 Address Note: Switching between 32-bit and 64-bit operation will require a reset. Write the [swreset_for_cmd] bit of SDHC register reg_software to reset. </description>
              <lsb>3</lsb>
              <msb>4</msb>
            </field>
            <field>
              <name>HOSTCTRL1_HIGHSPEEDENA</name>
              <description> Before setting this bit, the driver shall check the High Speed Support in the capabilities register. If this bit is set to 0 (default), the HC outputs CMD line and DAT lines at the falling edge of the SD clock (up to 25 MHz/20MHz for MMC). If this bit is set to 1,the HC outputs CMD line and DAT lines at the rising edge of the SD clock (up to 50 MHz for SD/52MHz for MMC)/208Mhz (for SD3.0). If Preset Value Enable in the Host Control 2 register is set to 1, Host Driver needs to reset SD Clock Enable before changing this field to avoid generating clock glitches. After setting this field, the Host Driver sets SD Clock Enable again. 0: Normal Speed Mode. 1: High Speed Mode. </description>
              <lsb>2</lsb>
              <msb>2</msb>
            </field>
            <field>
              <name>HOSTCTRL1_DATAWIDTH</name>
              <description> The driver shall select it to match the data width of the SD card. 0: 1-bit mode 1: 4-bit mode </description>
              <lsb>1</lsb>
              <msb>1</msb>
            </field>
            <field>
              <name>HOSTCTRL1_LEDCONTROL</name>
              <description> If the software is going to issue multiple SD commands, this bit can be set during all transactions. It is not necessary to change for each transaction.'0' LED Off'1' LED On </description>
              <lsb>0</lsb>
              <msb>0</msb>
            </field>
          </fields>
        </register>
        <register>
          <name>REG_POWERCONTROL</name>
          <description>SD Bus Power and Voltage Level.</description>
          <addressOffset>0x00000029</addressOffset>
          <size>8</size>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>EMMC_HWRESET</name>
              <description> </description>
              <lsb>4</lsb>
              <msb>4</msb>
            </field>
            <field>
              <name>PWRCTRL_SDBUSVOLTAGE</name>
              <description> Before setting this register, the HD shall check the voltage support bits in the capabilities register. If an unsupported voltage is selected, the Host System shall not supply SD bus voltage.'000'- '100' Reserved'101' 1.8V(Typ.)'110' 3.0V(Typ.)'111' 3.3V(Flattop.) </description>
              <lsb>1</lsb>
              <msb>3</msb>
            </field>
            <field>
              <name>PWRCTRL_SDBUSPOWER</name>
              <description> If the HC detects the No Card State, this bit shall be cleared.'0' Power Off'1' Power On </description>
              <lsb>0</lsb>
              <msb>0</msb>
            </field>
          </fields>
        </register>
        <register>
          <name>REG_BLOCKGAPCONTROL</name>
          <description>This register is used to program the block gap request, read wait control and interrupt at block gap</description>
          <addressOffset>0x0000002A</addressOffset>
          <size>8</size>
          <resetValue>0x00000080</resetValue>
          <fields>
            <field>
              <name>BLKGAPCTRL_BOOTACKENA</name>
              <description> '0' Will not wait for boot ack from eMMC card,'1' Wait for boot ack from eMMC card </description>
              <lsb>7</lsb>
              <msb>7</msb>
            </field>
            <field>
              <name>BLKGAPCTRL_ALTBOOTMODE</name>
              <description> '0' To stop alternative boot mode access,'1' To start alternative boot mode access </description>
              <lsb>6</lsb>
              <msb>6</msb>
            </field>
            <field>
              <name>BLKGAPCTRL_BOOTENABLE</name>
              <description> '0' To stop boot code access,'1' To start boot code access </description>
              <lsb>5</lsb>
              <msb>5</msb>
            </field>
            <field>
              <name>BLKGAPCTRL_SPIMODE</name>
              <description> '0' SD Mode, '1' SPI Mode </description>
              <lsb>4</lsb>
              <msb>4</msb>
            </field>
            <field>
              <name>BLKGAPCTRL_INTERRUPT</name>
              <description> Setting to 1 enables interrupt detection at the block gap for a multiple block transfer. If the SD card cannot signal an interrupt during a multiple block transfer, this bit should be set to 0. When the HD detects an SD card insertion, it shall set this bit according to the CCCR of the SDIO card. </description>
              <lsb>3</lsb>
              <msb>3</msb>
            </field>
            <field>
              <name>BLKGAPCTRL_RDWAITCTRL</name>
              <description> If the card supports read wait, set this bit to enable use of the read wait protocol to stop read data using DAT[2] line. Otherwise the HC has to stop the SD clock to hold read data, which restricts commands generation. When the HD detects an SD card insertion, it shall set this bit according to the CCCR of the SDIO card. If the card does not support read wait, this bit shall never be set to 1 otherwise DAT line conflict may occur. If this bit is set to 0, Suspend / Resume cannot be supported.'0' Disable Read-Wait Control'1' Enable Read-Wait Control </description>
              <lsb>2</lsb>
              <msb>2</msb>
            </field>
            <field>
              <name>BLKGAPCTRL_CONTINUE</name>
              <description> To cancel stop at the block gap, set Stop At block Gap Request to 0 and set this bit to restart the transfer. The HC automatically clears this bit in either of the following cases: 1) In the case of a read transaction, the DAT Line Active changes from 0 to 1 as a read transaction restarts. 2) In the case of a write transaction, the Write transfer active changes from 0 to 1 as the write transaction restarts. Therefore it is not necessary for Host driver to set this bit to 0. If Stop At Block Gap Request is set to 1, any write to this bit is ignored.'0' Ignore'1' Restart </description>
              <lsb>1</lsb>
              <msb>1</msb>
            </field>
            <field>
              <name>BLKGAPCTRL_STOPATBLKGAP</name>
              <description> Applicable for non-DMA, SDMA, and ADMA transfers. Until the transfer complete is set to 1, indicating a transfer completion the Host Driver shall leave this bit set to 1. Clearing both the Stop At Block Gap Request and Continue Request shall not cause the transaction to restart. Read Wait is used to stop the read transaction at the block gap. The controller shall honour Stop At Block Gap Request for write transfers, but for read transfers it requires that the SD card support Read Wait. Therefore the Host Driver shall not set this bit during read transfers unless the SD card supports Read Wait and has set Read Wait Control to 1. In case of write transfers in which the HD writes data to the Buffer Data Port register, the HD shall set this bit after all block data is written. If this bit is set to 1, the HD shall not write data to Buffer data port register. This bit affects Read Transfer Active, Write Transfer Active, DAT line active and Command Inhibit (DAT) in the Present State register.'0' Transfer'1' Stop </description>
              <lsb>0</lsb>
              <msb>0</msb>
            </field>
          </fields>
        </register>
        <register>
          <name>REG_WAKEUPCONTROL</name>
          <description>Wakeup Functionality Control.</description>
          <addressOffset>0x0000002B</addressOffset>
          <size>8</size>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>WKUPCTRL_CARDREMOVAL</name>
              <description> FN_WUS (Wake up Support) in CIS does not affect this bit.'0' Disable'1' Enable </description>
              <lsb>2</lsb>
              <msb>2</msb>
            </field>
            <field>
              <name>WKUPCTRL_CARDINSERTION</name>
              <description> FN_WUS (Wake up Support) in CIS does not affect this bit.'0' Disable'1' Enable </description>
              <lsb>1</lsb>
              <msb>1</msb>
            </field>
            <field>
              <name>WKUPCTRL_CARDINTERRUPT</name>
              <description> This bit can be set to 1 if FN_WUS (Wake Up Support) in CIS is set to 1.'0' Disable'1' Enable </description>
              <lsb>0</lsb>
              <msb>0</msb>
            </field>
          </fields>
        </register>
        <register>
          <name>REG_CLOCKCONTROL</name>
          <description>Clock Frequency Control and State.</description>
          <addressOffset>0x0000002C</addressOffset>
          <size>16</size>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>CLKCTRL_SDCLKFREQSEL</name>
              <description> The frequency is not programmed directly; rather this register holds the divisor of the Base Clock Frequency For SD clock in the capabilities register. Only the following settings are allowed. (1) 8-bit Divided Clock Mode 80h - base clock divided by 256 40h - base clock divided by 128 20h - base clock divided by 64 10h - base clock divided by 32 08h - base clock divided by 16 04h - base clock divided by 8 02h - base clock divided by 4 01h - base clock divided by 2 00h - base clock(10MHz-63MHz) Setting 00h specifies the highest frequency of the SD Clock. When setting multiple bits, the most significant bit is used as the divisor. But multiple bits should not be set. The two default divider values can be calculated by the frequency that is defined by the Base Clock Frequency For SD Clock in the Capabilities register. 1) 25 MHz divider value. 2) 400 KHz divider value. The frequency of the SDCLK is set by the following formula: Clock Frequency = (Baseclock) / divisor. Thus choose the smallest possible divisor which results in a clock frequency that is less than or equal to the target frequency. Maximum Frequency for SD = 50Mhz (base clock) Maximum Frequency for MMC = 52Mhz (base clock) Minimum Frequency = 195.3125Khz (50Mhz / 256), same calculation for MMC also. (2) 10-bit Divided Clock Mode Host Controller Version 3.00 supports this mandatory mode instead of the 8-bit Divided Clock Mode. The length of divider is extended to10 bits and all divider values shall be supported. 3FFh --1/2046 Divided Clock N -------1/2N Divided Clock (Duty 50%) 002h -- 1/4 Divided Clock 001h ---1/2 Divided Clock 000h --- Base Clock (10MHz-254MHz) </description>
              <lsb>8</lsb>
              <msb>15</msb>
            </field>
            <field>
              <name>CLKCTRL_SDCLKFREQSEL_UPPERBITS</name>
              <description> </description>
              <lsb>6</lsb>
              <msb>7</msb>
            </field>
            <field>
              <name>CLKCTRL_CLKGENSEL</name>
              <description> If the Programmable Clock Mode is supported (non-zero value is set to Clock Multiplier in the Capabilities register), this bit attribute is RW, and if not supported, this bit attribute is RO and zero is read. This bit depends on the setting of Preset Value Enable in the Host Control 2 register. If the Preset Value Enable = 0, this bit is set by Host Driver. If the Preset Value Enable = 1, this bit is automatically set to a value specified in one of Preset Value registers.'0' Divided Clock Mode'1' Programmable Clock Mode </description>
              <lsb>5</lsb>
              <msb>5</msb>
            </field>
            <field>
              <name>CLKCTRL_SDCLKENA</name>
              <description> SDCLK frequency Select can be changed when this bit is 0. Then, the HC shall maintain the same clock frequency until SDCLK is stopped (Stop at SDCLK = 0). If the HC detects the No Card state, this bit shall be cleared.'0' Disable,'1' Enable </description>
              <lsb>2</lsb>
              <msb>2</msb>
            </field>
            <field>
              <name>SDHCCLKGEN_INTCLKSTABLE_DSYNC</name>
              <description> The SD Host Driver shall wait to set SD Clock Enable until this bit is set to 1. Note: This is useful when using PLL for a clock oscillator that requires setup time.'0' Not Ready,'1' Ready </description>
              <lsb>1</lsb>
              <msb>1</msb>
            </field>
            <field>
              <name>CLKCTRL_INTCLKENA</name>
              <description> The HC should stop its internal clock to go very low power state. Still, registers shall be able to be read and written. Clock starts to oscillate when this bit is set to 1. When clock oscillation is stable, the HC shall set Internal Clock Stable in this register to 1. This bit shall not affect card detection.'0' Stop,'1' Oscillate </description>
              <lsb>0</lsb>
              <msb>0</msb>
            </field>
          </fields>
        </register>
        <register>
          <name>REG_TIMEOUTCONTROL</name>
          <description>Set the Data Timeout Counter Value.</description>
          <addressOffset>0x0000002E</addressOffset>
          <size>8</size>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>TIMEOUT_CTRVALUE</name>
              <description> Refer to the Data Time-out Error in the Error Interrupt Status register for information on factors that dictate time-out generation. Time-out clock frequency will be generated by dividing the sdclockTMCLK by this value. When setting this register, prevent inadvertent time-out events by clearing the Data Time-out Error Status Enable (in the Error Interrupt Status Enable register). 1111 - Reserved 1110 - TMCLK * 2^27 -------------------- -------------------- 0001 - TMCLK * 2^14 0000 - TMCLK * 2^13 </description>
              <lsb>0</lsb>
              <msb>3</msb>
            </field>
          </fields>
        </register>
        <register>
          <name>REG_SOFTWARERESET</name>
          <description>Software reset for data, command and all.</description>
          <addressOffset>0x0000002F</addressOffset>
          <size>8</size>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>SWRESET_FOR_DAT</name>
              <description> The following registers and bits are cleared by this bit: Buffer Data Port Register: Buffer is cleared and Initialized. Present State register: Buffer read Enable, Buffer write Enable, Read Transfer Active, Write Transfer Active, DAT Line Active, Command Inhibit (DAT). Block Gap Control register: Continue Request, Stop At Block Gap Request. Normal Interrupt Status register: Buffer Read Ready, Buffer Write Ready, Block Gap Event, Transfer Complete. 0: Operational. 1: Held in reset. </description>
              <lsb>2</lsb>
              <msb>2</msb>
            </field>
            <field>
              <name>SWRESET_FOR_CMD</name>
              <description> The following registers and bits are cleared by this bit: Present State register- Command Inhibit (CMD). Normal Interrupt Status register- Command Complete. 0: Operational. 1: Held in reset. </description>
              <lsb>1</lsb>
              <msb>1</msb>
            </field>
            <field>
              <name>SWRESET_FOR_ALL</name>
              <description> Register bits of type ROC, RW, RW1C, RWAC are cleared to 0. During its initialization, the HD shall set this bit to 1 to reset the HC. The HC shall reset this bit to 0 when capabilities registers are valid and the HD can read them. Additional use of Software Reset For All may not affect the value of the Capabilities registers. If this bit is set to 1, the SD card shall reset itself and must be re initialized by the HD. 0: Operational. 1: Held in reset. </description>
              <lsb>0</lsb>
              <msb>0</msb>
            </field>
          </fields>
        </register>
        <register>
          <name>REG_NORMALINTRSTS</name>
          <description>Status of all Interrupts</description>
          <addressOffset>0x00000030</addressOffset>
          <size>16</size>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>REG_ERRORINTRSTS</name>
              <description> '0' No error'1' Error </description>
              <lsb>15</lsb>
              <msb>15</msb>
            </field>
            <field>
              <name>NORMALINTRSTS_BOOTCOMPLETE</name>
              <description> '0' Boot operation is not terminated'1' Boot operation is terminated </description>
              <lsb>14</lsb>
              <msb>14</msb>
            </field>
            <field>
              <name>NORMALINTRSTS_RCVBOOTACK</name>
              <description> '0' Boot ack not recieved'1' Boot ack is recieved </description>
              <lsb>13</lsb>
              <msb>13</msb>
            </field>
            <field>
              <name>NORMALINTRSTS_RETUNINGEVENT</name>
              <description> Host Controller requests Host Driver to perform re-tuning for next data transfer. Current data transfer (not large block count) can be completed without re-tuning.'0' Re-tuning not required'1' Re-tuning should be performed </description>
              <lsb>12</lsb>
              <msb>12</msb>
            </field>
            <field>
              <name>NORMALINTRSTS_INTC</name>
              <description> Writing this bit to 1 does not clear this bit. It is cleared by resetting the INT_C interrupt factor. </description>
              <lsb>11</lsb>
              <msb>11</msb>
            </field>
            <field>
              <name>NORMALINTRSTS_INTB</name>
              <description> Writing this bit to 1 does not clear this bit. It is cleared by resetting the INT_B interrupt factor. </description>
              <lsb>10</lsb>
              <msb>10</msb>
            </field>
            <field>
              <name>NORMALINTRSTS_INTA</name>
              <description> Writing this bit to 1 does not clear this bit. It is cleared by resetting the INT_A interrupt factor. NOTE: INT_A, INT_B, and INT_C are to be implemented based on the Application Requirements. By default these are not implemented as there is no specific requirement from Customers. </description>
              <lsb>9</lsb>
              <msb>9</msb>
            </field>
            <field>
              <name>NORMALINTRSTS_CARDINTSTS</name>
              <description> It is cleared by resetting the SD card interrupt factor. In 1-bit mode, the HC shall detect the Card Interrupt without SD Clock to support wakeup. In 4-bit mode, the card interrupt signal is sampled during the interrupt cycle, so there are some sample delays between the interrupt signal from the card and the interrupt to theHost system. when this status has been set and the HD needs to start this interrupt service, Card Interrupt Status Enable in the Normal Interrupt Status register shall be set to 0 in order to clear the card interrupt statuses latched in the HC and stop driving the Host System. After completion of the card interrupt service (the reset factor in the SD card and the interrupt signal may not be asserted), set Card Interrupt Status Enable to 1 and start sampling the interrupt signal again. Interrupt detected by DAT[1] is supported when there is a card per slot. In case of shared bus, interrupt pins are used to detect interrupts. If 000b is set to Interrupt Pin Select in the Shared Bus Control register, this status is effective. Non-zero value is set to Interrupt Pin Select, INT_A, INT_B or INT_C is then used to device interrupts. Card Interrupt: 0: inactive. 1: active. </description>
              <lsb>8</lsb>
              <msb>8</msb>
            </field>
            <field>
              <name>NORMALINTRSTS_CARDREMSTS</name>
              <description> When the HD writes this bit to 1 to clear this status the status of the Card Inserted in the Present State register should be confirmed. Because the card detect may possibly be changed when the HD clear this bit an Interrupt event may not be generated.'0' Card State Stable or Debouncing'1' Card Removed </description>
              <lsb>7</lsb>
              <msb>7</msb>
            </field>
            <field>
              <name>NORMALINTRSTS_CARDINSSTS</name>
              <description> When the HD writes this bit to 1 to clear this status the status of the Card Inserted in the Present State register should be confirmed. Because the card detect may possibly be changed when the HD clear this bit an Interrupt event may not be generated.'0' Card State Stable or Debouncing'1' Card Inserted </description>
              <lsb>6</lsb>
              <msb>6</msb>
            </field>
            <field>
              <name>NORMALINTRSTS_BUFRDREADY</name>
              <description> '0' Not ready to read buffer,'1' Ready to read buffer </description>
              <lsb>5</lsb>
              <msb>5</msb>
            </field>
            <field>
              <name>NORMALINTRSTS_BUFWRREADY</name>
              <description> '0' Not ready to write to buffer, '1' Ready to write to buffer </description>
              <lsb>4</lsb>
              <msb>4</msb>
            </field>
            <field>
              <name>NORMALINTRSTS_DMAINTERRUPT</name>
              <description> '0' No DMA Interrupt'1' DMA Interrupt is generated </description>
              <lsb>3</lsb>
              <msb>3</msb>
            </field>
            <field>
              <name>NORMALINTRSTS_BLKGAPEVENT</name>
              <description> Read Transaction: This bit is set at the falling edge of the DAT Line Active Status (When the transaction is stopped at SD Bus timing. The Read Wait must be supported inorder to use this function). Write Transaction: This bit is set at the falling edge of Write Transfer Active Status (After getting CRC status at SD Bus timing).'0' No Block Gap Event'1' Transaction stopped at Block Gap </description>
              <lsb>2</lsb>
              <msb>2</msb>
            </field>
            <field>
              <name>NORMALINTRSTS_XFERCOMPLETE</name>
              <description> Read Transaction: This bit is set at the falling edge of Read Transfer Active Status. There are two cases in which the Interrupt is generated. The first is when a data transfer is completed as specified by data length (After the last data has been read to the Host Sys- tem). The second is when data has stopped at the block gap and completed the data transfer by setting the Stop At Block Gap Request in the Block Gap Control Register (After valid data has been read to the Host System). Write Transaction: This bit is set at the falling edge of the DAT Line Active Status. There are two cases in which the Interrupt is generated. The first is when the last data is written to the card as specified by data length and Busy signal is released. The second is when data transfers are stopped at the block gap by setting Stop At Block Gap Request in the Block Gap Control Register and data transfers completed. (After valid data is written to the SD card and the busy signal is released). Note: Transfer Complete has higher priority than Data Time-out Error. If both bits are set to 1, the data transfer can be considered complete. Note: While performing tuning procedure (Execute Tuning is set to 1), Transfer Complete is not set to 1'0' No Data Transfer Complete,'1' Data Transfer Complete </description>
              <lsb>1</lsb>
              <msb>1</msb>
            </field>
            <field>
              <name>NORMALINTRSTS_CMDCOMPLETE</name>
              <description> If both are set to 1, it can be considered that the response was not received correctly.'0' No Command Complete,'1' Command Complete </description>
              <lsb>0</lsb>
              <msb>0</msb>
            </field>
          </fields>
        </register>
        <register>
          <name>REG_ERRORINTRSTS</name>
          <description>Error Interrupts Status</description>
          <addressOffset>0x00000032</addressOffset>
          <size>16</size>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>ERRORINTRSTS_HOSTERROR</name>
              <description> </description>
              <lsb>12</lsb>
              <msb>12</msb>
            </field>
            <field>
              <name>ERRORINTRSTS_ADMAERROR</name>
              <description> The state of the ADMA at an error occurrence is saved in the ADMA Error Status Register.'0' No error'1' Error </description>
              <lsb>9</lsb>
              <msb>9</msb>
            </field>
            <field>
              <name>ERRORINTRSTS_AUTOCMDERROR</name>
              <description> This bit is set when detecting that one of the bits D00-D04 in Auto CMD Error Status register has changed from 0 to 1. In case of Auto CMD12, this bit is set to 1, not only when the errors in Auto CMD12 occur but also when Auto CMD12 is not executed due to the previous command error.'0' No error'1' Error </description>
              <lsb>8</lsb>
              <msb>8</msb>
            </field>
            <field>
              <name>ERRORINTRSTS_CURRLIMITERROR</name>
              <description> If the HC supports the Current Limit Function, it can be protected from an Illegal card by stopping power supply to the card in which case this bit indicates a failure status. Reading 1 means the HC is not supplying power to SD card due to some failure. Reading 0 means that the HC is supplying power and no error has occurred. This bit shall always set to be 0, if the HC does not support this function.'0' No error'1' Power Fail Note: The current_Limit_Error is to be implemented if customer application requires it. By default it is not implemented as there is no specific requirement from Customers. </description>
              <lsb>7</lsb>
              <msb>7</msb>
            </field>
            <field>
              <name>ERRORINTRSTS_DATAENDBITERROR</name>
              <description> </description>
              <lsb>6</lsb>
              <msb>6</msb>
            </field>
            <field>
              <name>ERRORINTRSTS_DATACRCERROR</name>
              <description> '0' No error'1' Error </description>
              <lsb>5</lsb>
              <msb>5</msb>
            </field>
            <field>
              <name>ERRORINTRSTS_DATATIMEOUTERROR</name>
              <description> Busy Timeout for R1b, R5b type. 2. Busy Timeout after Write CRC status 3. Write CRC status Timeout 4. Read Data Timeout.'0' No Error'1' Timeout </description>
              <lsb>4</lsb>
              <msb>4</msb>
            </field>
            <field>
              <name>ERRORINTRSTS_CMDINDEXERROR</name>
              <description> '0' No Error'1' Error </description>
              <lsb>3</lsb>
              <msb>3</msb>
            </field>
            <field>
              <name>ERRORINTRSTS_CMDENDBITERROR</name>
              <description> '0' No Error, '1' End bit error generated </description>
              <lsb>2</lsb>
              <msb>2</msb>
            </field>
            <field>
              <name>ERRORINTRSTS_CMDCRCERROR</name>
              <description> 1. If a response is returned and the Command Time-out Error is set to 0, this bit is set to 1 when detecting a CRT error in the command response 2. The HC detects a CMD line conflict by monitoring the CMD line when a command is issued. If the HC drives the CMD line to 1 level, but detects 0 level on the CMD line at the next SDCLK edge, then the HC shall abort the command (Stop driving CMD line) and set this bit to 1. The Command Timeout Error shall also be set to 1 to distinguish CMD line conflict.'0' No Error,'1' CRC Error </description>
              <lsb>1</lsb>
              <msb>1</msb>
            </field>
            <field>
              <name>ERRORINTRSTS_CMDTIMEOUTERROR</name>
              <description> If the HC detects a CMD line conflict, in which case Command CRC Error shall also be set. This bit shall be set without waiting for 64 SDCLK cycles because the command will be aborted by the HC.'0' Error'1' Timeout </description>
              <lsb>0</lsb>
              <msb>0</msb>
            </field>
          </fields>
        </register>
        <register>
          <name>REG_NORMALINTRSTSENA</name>
          <description>Normal-type Interrupts Status Enables.</description>
          <addressOffset>0x00000034</addressOffset>
          <size>16</size>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>NORMALINTRSTS_ENABLEREGBIT15</name>
              <description> </description>
              <lsb>15</lsb>
              <msb>15</msb>
            </field>
            <field>
              <name>NORMALINTRSTS_ENABLEREGBIT14</name>
              <description> </description>
              <lsb>14</lsb>
              <msb>14</msb>
            </field>
            <field>
              <name>NORMALINTRSTS_ENABLEREGBIT13</name>
              <description> </description>
              <lsb>13</lsb>
              <msb>13</msb>
            </field>
            <field>
              <name>NORMALINTRSTS_ENABLEREGBIT12</name>
              <description> </description>
              <lsb>12</lsb>
              <msb>12</msb>
            </field>
            <field>
              <name>NORMALINTRSTS_ENABLEREGBIT11</name>
              <description> The Host Driver may clear this bit before servicing the INT_C and may set this bit again after all interrupt requests to INT_C pin are cleared to prevent inadvertent interrupts. </description>
              <lsb>11</lsb>
              <msb>11</msb>
            </field>
            <field>
              <name>NORMALINTRSTS_ENABLEREGBIT10</name>
              <description> The Host Driver may clear this bit before servicing the INT_B and may set this bit again after all interrupt requests to INT_B pin are cleared to prevent inadvertent interrupts. </description>
              <lsb>10</lsb>
              <msb>10</msb>
            </field>
            <field>
              <name>NORMALINTRSTS_ENABLEREGBIT9</name>
              <description> The Host Driver may clear this bit before servicing the INT_A and may set this bit again after all interrupt requests to INT_A pin are cleared to prevent inadvertent interrupts. </description>
              <lsb>9</lsb>
              <msb>9</msb>
            </field>
            <field>
              <name>SDHCREGSET_CARDINTSTSENA</name>
              <description> The Card Interruptdetection is stopped when this bit is cleared and restarted when this bit is set to 1. The HD may clear the Card Interrupt Status Enable before servicing the Card Interrupt and may set this bit again after all Interrupt requests from the card are cleared to prevent inadvertent Interrupts. </description>
              <lsb>8</lsb>
              <msb>8</msb>
            </field>
            <field>
              <name>SDHCREGSET_CARDREMSTSENA</name>
              <description> </description>
              <lsb>7</lsb>
              <msb>7</msb>
            </field>
            <field>
              <name>SDHCREGSET_CARDINSSTSENA</name>
              <description> </description>
              <lsb>6</lsb>
              <msb>6</msb>
            </field>
            <field>
              <name>NORMALINTRSTS_ENABLEREGBIT5</name>
              <description> </description>
              <lsb>5</lsb>
              <msb>5</msb>
            </field>
            <field>
              <name>NORMALINTRSTS_ENABLEREGBIT4</name>
              <description> </description>
              <lsb>4</lsb>
              <msb>4</msb>
            </field>
            <field>
              <name>NORMALINTRSTS_ENABLEREGBIT3</name>
              <description> </description>
              <lsb>3</lsb>
              <msb>3</msb>
            </field>
            <field>
              <name>NORMALINTRSTS_ENABLEREGBIT2</name>
              <description> </description>
              <lsb>2</lsb>
              <msb>2</msb>
            </field>
            <field>
              <name>NORMALINTRSTS_ENABLEREGBIT1</name>
              <description> </description>
              <lsb>1</lsb>
              <msb>1</msb>
            </field>
            <field>
              <name>NORMALINTRSTS_ENABLEREGBIT0</name>
              <description> </description>
              <lsb>0</lsb>
              <msb>0</msb>
            </field>
          </fields>
        </register>
        <register>
          <name>REG_ERRORINTRSTSENA</name>
          <description>Error-type Interrupts Status Enables.</description>
          <addressOffset>0x00000036</addressOffset>
          <size>16</size>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>ERRORINTRSTS_ENABLEREGBIT12</name>
              <description> </description>
              <lsb>12</lsb>
              <msb>12</msb>
            </field>
            <field>
              <name>ERRORINTRSTS_ENABLEREGBIT10</name>
              <description> </description>
              <lsb>10</lsb>
              <msb>10</msb>
            </field>
            <field>
              <name>ERRORINTRSTS_ENABLEREGBIT9</name>
              <description> </description>
              <lsb>9</lsb>
              <msb>9</msb>
            </field>
            <field>
              <name>ERRORINTRSTS_ENABLEREGBIT8</name>
              <description> </description>
              <lsb>8</lsb>
              <msb>8</msb>
            </field>
            <field>
              <name>ERRORINTRSTS_ENABLEREGBIT7</name>
              <description> </description>
              <lsb>7</lsb>
              <msb>7</msb>
            </field>
            <field>
              <name>ERRORINTRSTS_ENABLEREGBIT6</name>
              <description> </description>
              <lsb>6</lsb>
              <msb>6</msb>
            </field>
            <field>
              <name>ERRORINTRSTS_ENABLEREGBIT5</name>
              <description> </description>
              <lsb>5</lsb>
              <msb>5</msb>
            </field>
            <field>
              <name>ERRORINTRSTS_ENABLEREGBIT4</name>
              <description> </description>
              <lsb>4</lsb>
              <msb>4</msb>
            </field>
            <field>
              <name>ERRORINTRSTS_ENABLEREGBIT3</name>
              <description> </description>
              <lsb>3</lsb>
              <msb>3</msb>
            </field>
            <field>
              <name>ERRORINTRSTS_ENABLEREGBIT2</name>
              <description> </description>
              <lsb>2</lsb>
              <msb>2</msb>
            </field>
            <field>
              <name>ERRORINTRSTS_ENABLEREGBIT1</name>
              <description> </description>
              <lsb>1</lsb>
              <msb>1</msb>
            </field>
            <field>
              <name>ERRORINTRSTS_ENABLEREGBIT0</name>
              <description> </description>
              <lsb>0</lsb>
              <msb>0</msb>
            </field>
          </fields>
        </register>
        <register>
          <name>REG_NORMALINTRSIGENA</name>
          <description>Normal-type Interrupts Signal Enables.</description>
          <addressOffset>0x00000038</addressOffset>
          <size>16</size>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>NORMALINTRSIG_ENABLEREGBIT15</name>
              <description> </description>
              <lsb>15</lsb>
              <msb>15</msb>
            </field>
            <field>
              <name>NORMALINTRSIG_ENABLEREGBIT14</name>
              <description> </description>
              <lsb>14</lsb>
              <msb>14</msb>
            </field>
            <field>
              <name>NORMALINTRSIG_ENABLEREGBIT13</name>
              <description> </description>
              <lsb>13</lsb>
              <msb>13</msb>
            </field>
            <field>
              <name>NORMALINTRSIG_ENABLEREGBIT12</name>
              <description> </description>
              <lsb>12</lsb>
              <msb>12</msb>
            </field>
            <field>
              <name>NORMALINTRSIG_ENABLEREGBIT11</name>
              <description> </description>
              <lsb>11</lsb>
              <msb>11</msb>
            </field>
            <field>
              <name>NORMALINTRSIG_ENABLEREGBIT10</name>
              <description> </description>
              <lsb>10</lsb>
              <msb>10</msb>
            </field>
            <field>
              <name>NORMALINTRSIG_ENABLEREGBIT9</name>
              <description> </description>
              <lsb>9</lsb>
              <msb>9</msb>
            </field>
            <field>
              <name>NORMALINTRSIG_ENABLEREGBIT8</name>
              <description> </description>
              <lsb>8</lsb>
              <msb>8</msb>
            </field>
            <field>
              <name>NORMALINTRSIG_ENABLEREGBIT7</name>
              <description> </description>
              <lsb>7</lsb>
              <msb>7</msb>
            </field>
            <field>
              <name>NORMALINTRSIG_ENABLEREGBIT6</name>
              <description> </description>
              <lsb>6</lsb>
              <msb>6</msb>
            </field>
            <field>
              <name>NORMALINTRSIG_ENABLEREGBIT5</name>
              <description> </description>
              <lsb>5</lsb>
              <msb>5</msb>
            </field>
            <field>
              <name>NORMALINTRSIG_ENABLEREGBIT4</name>
              <description> </description>
              <lsb>4</lsb>
              <msb>4</msb>
            </field>
            <field>
              <name>NORMALINTRSIG_ENABLEREGBIT3</name>
              <description> </description>
              <lsb>3</lsb>
              <msb>3</msb>
            </field>
            <field>
              <name>NORMALINTRSIG_ENABLEREGBIT2</name>
              <description> </description>
              <lsb>2</lsb>
              <msb>2</msb>
            </field>
            <field>
              <name>NORMALINTRSIG_ENABLEREGBIT1</name>
              <description> </description>
              <lsb>1</lsb>
              <msb>1</msb>
            </field>
            <field>
              <name>NORMALINTRSIG_ENABLEREGBIT0</name>
              <description> </description>
              <lsb>0</lsb>
              <msb>0</msb>
            </field>
          </fields>
        </register>
        <register>
          <name>REG_ERRORINTRSIGENA</name>
          <description>Error-type Interrupts Signal Enables.</description>
          <addressOffset>0x0000003A</addressOffset>
          <size>16</size>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>ERRORINTRSIG_ENABLEREGBIT12</name>
              <description> </description>
              <lsb>12</lsb>
              <msb>12</msb>
            </field>
            <field>
              <name>ERRORINTRSIG_ENABLEREGBIT10</name>
              <description> </description>
              <lsb>10</lsb>
              <msb>10</msb>
            </field>
            <field>
              <name>ERRORINTRSIG_ENABLEREGBIT9</name>
              <description> </description>
              <lsb>9</lsb>
              <msb>9</msb>
            </field>
            <field>
              <name>ERRORINTRSIG_ENABLEREGBIT8</name>
              <description> </description>
              <lsb>8</lsb>
              <msb>8</msb>
            </field>
            <field>
              <name>ERRORINTRSIG_ENABLEREGBIT7</name>
              <description> </description>
              <lsb>7</lsb>
              <msb>7</msb>
            </field>
            <field>
              <name>ERRORINTRSIG_ENABLEREGBIT6</name>
              <description> </description>
              <lsb>6</lsb>
              <msb>6</msb>
            </field>
            <field>
              <name>ERRORINTRSIG_ENABLEREGBIT5</name>
              <description> </description>
              <lsb>5</lsb>
              <msb>5</msb>
            </field>
            <field>
              <name>ERRORINTRSIG_ENABLEREGBIT4</name>
              <description> </description>
              <lsb>4</lsb>
              <msb>4</msb>
            </field>
            <field>
              <name>ERRORINTRSIG_ENABLEREGBIT3</name>
              <description> </description>
              <lsb>3</lsb>
              <msb>3</msb>
            </field>
            <field>
              <name>ERRORINTRSIG_ENABLEREGBIT2</name>
              <description> </description>
              <lsb>2</lsb>
              <msb>2</msb>
            </field>
            <field>
              <name>ERRORINTRSIG_ENABLEREGBIT1</name>
              <description> </description>
              <lsb>1</lsb>
              <msb>1</msb>
            </field>
            <field>
              <name>ERRORINTRSIG_ENABLEREGBIT0</name>
              <description> </description>
              <lsb>0</lsb>
              <msb>0</msb>
            </field>
          </fields>
        </register>
        <register>
          <name>REG_AUTOCMDERRSTS</name>
          <description>CMD12 response error of Auto CMD12 and CMD23.</description>
          <addressOffset>0x0000003C</addressOffset>
          <size>16</size>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>AUTOCMDERRSTS_NEXTERROR</name>
              <description> This bit is set to 0 when Auto CMD Error is generated by Auto CMD23.'0' No Error'1' Not Issued </description>
              <lsb>7</lsb>
              <msb>7</msb>
            </field>
            <field>
              <name>AUTOCMDERRSTS_INDEXERROR</name>
              <description> '0' No Error,'1' Error. </description>
              <lsb>4</lsb>
              <msb>4</msb>
            </field>
            <field>
              <name>AUTOCMDERRSTS_ENDBITERROR</name>
              <description> '0' No Error,'1' End Bit Error Generated </description>
              <lsb>3</lsb>
              <msb>3</msb>
            </field>
            <field>
              <name>AUTOCMDERRSTS_CRCERROR</name>
              <description> '0' No error'1' CRC Error Generated </description>
              <lsb>2</lsb>
              <msb>2</msb>
            </field>
            <field>
              <name>AUTOCMDERRSTS_TIMEOUTERROR</name>
              <description> If this bit is set to 1, the other error status bits (D04 - D02) are meaningless.'0' No error'1' Timeout </description>
              <lsb>1</lsb>
              <msb>1</msb>
            </field>
            <field>
              <name>AUTOCMDERRSTS_NOTEXECERROR</name>
              <description> Setting this bit to 1 means the HC cannot issue Auto CMD12 to stop memory multiple block transfer due to some error. If this bit is set to 1, other error status bits (D04 - D01) are meaningless. This bit is set to 0 when Auto CMD Error is generated by Auto CMD23'0' Executed, '1' Not Executed </description>
              <lsb>0</lsb>
              <msb>0</msb>
            </field>
          </fields>
        </register>
        <register>
          <name>REG_HOSTCONTROL2</name>
          <description>UHS Mode, I/O Drive, Tuning, Clocking, Intr, and Presets.</description>
          <addressOffset>0x0000003E</addressOffset>
          <size>16</size>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>HOSTCTRL2_PRESETVALUEENABLE</name>
              <description> 00 supports this bit. As the operating SDCLK frequency and I/O driver strength depend on the Host System implementation, it is difficult to determine these parameters in the Standard Host Driver. When Preset Value Enable is set to automatic. This bit enables the functions defined in the Preset Value registers.'0' SDCLK and Driver Strength are controlled by Host Driver.'1' Automatic Selection by Preset Value are Enabled. If this bit is set to 0, SDCLK Frequency Select, Clock Generator Select in the Clock Control register and Driver Strength Select in Host Control 2 register are set by Host Driver. If this bit is set to 1, SDCLK Frequency Select, Clock Generator Select in the Clock Control register and Driver Strength Select in Host Control 2 register are set by Host Controller as specified in the Preset Value registers. </description>
              <lsb>15</lsb>
              <msb>15</msb>
            </field>
            <field>
              <name>HOSTCTRL2_ASYNCHINTRENABLE</name>
              <description> Asynchronous interrupt is effective when DAT[1] interrupt is used in 4-bit SD mode (and zero is set to Interrupt Pin Select in the Shared Bus Control register). If this bit is set to 1, the Host Driver can stop the SDCLK during asynchronous interrupt period to save power. During this period, the Host Controller continues to deliver Card Interrupt to the host when it is asserted by the Card.'0' Disabled'1' Enabled </description>
              <lsb>14</lsb>
              <msb>14</msb>
            </field>
            <field>
              <name>HOSTCTRL2_SAMPLINGCLKSELECT</name>
              <description> Writing 1 to this bit is meaningless and ignored. Setting 1 means that tuning is completed successfully and setting 0 means that tuning is failed. Host Controller uses this bit to select sampling clock to receive CMD and DAT. This bit is cleared by writing 0. Change of this bit is not allowed while the Host Controller is receiving response or a read data block.'0' Fixed clock is used to sample data'1' Tuned clock is used to sample data </description>
              <lsb>7</lsb>
              <msb>7</msb>
            </field>
            <field>
              <name>HOSTCTRL2_EXECUTETUNING</name>
              <description> The result of tuning is indicated to Sampling Clock Select. Tuning procedure is aborted by writing 0 for more detail about tuning procedure.'0' Not Tuned or Tuning Completed'1' Execute Tuning </description>
              <lsb>6</lsb>
              <msb>6</msb>
            </field>
            <field>
              <name>HOSTCTRL2_DRIVERSTRENGTH</name>
              <description> 8V signaling. In 3.3V signaling, this field is not effective. This field can be set to driver type A, B, C, or D. This bit depends on setting of Preset Value Enable: If Preset Value Enable = 0, this field is set by Host Driver. If Preset Value Enable = 1, this field is automatically set by the hardware to a value specified in the selected Preset Value register. 00: Driver Type B (default) 01: Driver Type A 10: Driver Type C 11: Driver Type D </description>
              <lsb>4</lsb>
              <msb>5</msb>
            </field>
            <field>
              <name>HOSTCTRL2_1P8VSIGNALLINGENA</name>
              <description> 3.3V is supplied to the card regardless of signaling voltage. Setting this bit from 0 to 1 starts changing signal voltage from 3.3V to 1.8V. 1.8V regulator output shall be stable within 5ms. Host Controller clears this bit if switching to 1.8V signaling fails. Clearing this bit from 1 to 0 starts changing signal voltage from 1.8V to 3.3V. 3.3V regulator output shall be stable within 5ms. Host Driver can set this bit to 1 when Host Controller supports 1.8V signaling (One of support bits is set to 1: SDR50, SDR104 or DDR50 in the Capabilities register) and the card or device supports UHS-I.'0' 3.3V Signalling, '1' 1.8V Signalling </description>
              <lsb>3</lsb>
              <msb>3</msb>
            </field>
            <field>
              <name>HOSTCTRL2_UHSMODESELECT</name>
              <description> 8V Signaling Enable is set to 1.If Preset Value Enable in the Host Control 2 register is set to 1, Host Controller sets SDCLK Frequency Select, Clock Generator Select in the Clock Control register and Driver Strength Select according to Preset Value registers. In this case, one of preset value registers is selected by this field. Host Driver needs to reset SD Clock Enable before changing this field to avoid generating clock glitch. After setting this field, Host Driver sets SD Clock Enable again. 000: SDR12 001: SDR25 010: SDR50 011: SDR104 100: DDR50 101 - 111: Reserved. When SDR50, SDR104 or DDR50 is selected for SDIO card, interrupt detection at the block gap shall not be used. Read Wait timing is changed for these modes. Refer to the SDIO Specification Version 3.00 for more detail. </description>
              <lsb>0</lsb>
              <msb>2</msb>
            </field>
          </fields>
        </register>
        <register>
          <name>REG_CAPABILITIES</name>
          <description>Host controller implementation.</description>
          <addressOffset>0x00000040</addressOffset>
          <size>64</size>
          <resetValue>0x280737EC6481</resetValue>
          <fields>
            <field>
              <name>CORECFG_SPIBLKMODE</name>
              <description> </description>
              <lsb>57</lsb>
              <msb>57</msb>
            </field>
            <field>
              <name>CORECFG_SPISUPPORT</name>
              <description> </description>
              <lsb>56</lsb>
              <msb>56</msb>
            </field>
            <field>
              <name>CORECFG_CLOCKMULTIPLIER</name>
              <description> </description>
              <lsb>48</lsb>
              <msb>55</msb>
            </field>
            <field>
              <name>CORECFG_RETUNINGMODES</name>
              <description> 00: Mode 1 01: Mode 2 10: Mode 3 11: reserved. There are two re-tuning timings:Re-Tuning Request and expiration of a Re-Tuning Timer. By receiving either timing, the Host Driver executes the re-tuning procedure just before a next command issue. </description>
              <lsb>46</lsb>
              <msb>47</msb>
            </field>
            <field>
              <name>CORECFG_TUNINGFORSDR50</name>
              <description> </description>
              <lsb>45</lsb>
              <msb>45</msb>
            </field>
            <field>
              <name>CORECFG_RETUNINGTIMERCNT</name>
              <description> 0h: Get information via other source 1h: 1 seconds 2h: 2 seconds 3h: 4 seconds 4h: 8 seconds ------ nh: 2 (n-1) seconds ------ Bh: 1024 seconds Others: reserved </description>
              <lsb>40</lsb>
              <msb>43</msb>
            </field>
            <field>
              <name>CORECFG_DDRIVERSUPPORT</name>
              <description> 8 Signaling) is not supported. </description>
              <lsb>38</lsb>
              <msb>38</msb>
            </field>
            <field>
              <name>CORECFG_CDRIVERSUPPORT</name>
              <description> 8 Signaling) is not supported. </description>
              <lsb>37</lsb>
              <msb>37</msb>
            </field>
            <field>
              <name>CORECFG_ADRIVERSUPPORT</name>
              <description> 8 Signaling) is not supported. </description>
              <lsb>36</lsb>
              <msb>36</msb>
            </field>
            <field>
              <name>CORECFG_DDR50SUPPORT</name>
              <description> </description>
              <lsb>34</lsb>
              <msb>34</msb>
            </field>
            <field>
              <name>CORECFG_SDR104SUPPORT</name>
              <description> </description>
              <lsb>33</lsb>
              <msb>33</msb>
            </field>
            <field>
              <name>CORECFG_SDR50SUPPORT</name>
              <description> </description>
              <lsb>32</lsb>
              <msb>32</msb>
            </field>
            <field>
              <name>CORECFG_SLOTTYPE</name>
              <description> (A host controller register set is defined perslot.) Embedded slot for one device (01b) means that only one non-removable device is connected to a SD bus slot. Shared Bus Slot (10b) can be set if Host Controller supports Shared Bus Control register. The Standard Host Driver controls only a removable card or one embedded device is connected to a SD bus slot. If a slot is configured for shared bus (10b), the Standard Host Driver does not control embedded devices connected to a shared bus. Shared bus slot is controlled by a specific host driver developed by a Host System.'00' Removable Card Slot'01' Embedded Slot for One Device'10' Shared Bus Slot'11' Reserved </description>
              <lsb>30</lsb>
              <msb>31</msb>
            </field>
            <field>
              <name>CORECFG_ASYNCHINTRSUPPORT</name>
              <description> 00. </description>
              <lsb>29</lsb>
              <msb>29</msb>
            </field>
            <field>
              <name>CORECFG_64BITSUPPORT</name>
              <description> </description>
              <lsb>28</lsb>
              <msb>28</msb>
            </field>
            <field>
              <name>CORECFG_1P8VOLTSUPPORT</name>
              <description> 8V I/O. </description>
              <lsb>26</lsb>
              <msb>26</msb>
            </field>
            <field>
              <name>CORECFG_3P0VOLTSUPPORT</name>
              <description> 0V I/O. </description>
              <lsb>25</lsb>
              <msb>25</msb>
            </field>
            <field>
              <name>CORECFG_3P3VOLTSUPPORT</name>
              <description> 3V I/O. </description>
              <lsb>24</lsb>
              <msb>24</msb>
            </field>
            <field>
              <name>CORECFG_SUSPRESSUPPORT</name>
              <description> </description>
              <lsb>23</lsb>
              <msb>23</msb>
            </field>
            <field>
              <name>CORECFG_SDMASUPPORT</name>
              <description> </description>
              <lsb>22</lsb>
              <msb>22</msb>
            </field>
            <field>
              <name>CORECFG_HIGHSPEEDSUPPORT</name>
              <description> '0' High Speed Not Supported'1' High Speed Supported </description>
              <lsb>21</lsb>
              <msb>21</msb>
            </field>
            <field>
              <name>CORECFG_ADMA2SUPPORT</name>
              <description> </description>
              <lsb>19</lsb>
              <msb>19</msb>
            </field>
            <field>
              <name>CORECFG_8BITSUPPORT</name>
              <description> This bit is not effective when Slot Type is set to 10b. In this case, refer to Bus Width Preset in the Shared Bus resister.'0' Extended Media Bus Not Supported'1' Extended Media Bus Supported </description>
              <lsb>18</lsb>
              <msb>18</msb>
            </field>
            <field>
              <name>CORECFG_MAXBLKLENGTH</name>
              <description> The buffer shall transfer this block size without wait cycles. Three sizes can be defined as indicated below.'00' 512byte'01' 1024byte'10' 2048byte'11' 4096byte </description>
              <lsb>16</lsb>
              <msb>17</msb>
            </field>
            <field>
              <name>CORECFG_BASECLKFREQ</name>
              <description> 00 and 2.00. Upper 2-bit is not effective and always 0. Unit values are 1MHz. The supported clock range is 10MHz to 63MHz. 11xx xxxxb' Not Supported'0011 1111b' 63MHz'0000 0010b' 2MHz'0000 0001b' 1MHz'0000 0000b'Get Information via another method (2)8-bit Base Clock Frequency: This mode is supported by the Host Controller Version 3.00.Unit values are 1MHz. The supported clock range is 10MHz to 255MHz.'FFh' 255MHz'02h' 2MHz'01h' 1MHz'00h' Get Information via another method. If the real frequency is 16.5MHz, the lager value shall be set 0001 0001b (17MHz) because the Host Driver use this value to calculate the clock divider value (Refer to the SDCLK Frequency Select in the Clock Control register.) and it shall not exceed upper limit of the SD Clock frequency. If these bits are all 0, the Host System has to get information via another method. </description>
              <lsb>8</lsb>
              <msb>15</msb>
            </field>
            <field>
              <name>CORECFG_TIMEOUTCLKUNIT</name>
              <description> </description>
              <lsb>7</lsb>
              <msb>7</msb>
            </field>
            <field>
              <name>CORECFG_TIMEOUTCLKFREQ</name>
              <description> </description>
              <lsb>0</lsb>
              <msb>5</msb>
            </field>
          </fields>
        </register>
        <register>
          <name>REG_MAXCURRENTCAP</name>
          <description>Maximum current capability for each voltage.</description>
          <addressOffset>0x00000048</addressOffset>
          <size>64</size>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>CORECFG_MAXCURRENT1P8V</name>
              <description> SD_MAXCUR1P8 register. </description>
              <lsb>16</lsb>
              <msb>23</msb>
            </field>
            <field>
              <name>CORECFG_MAXCURRENT3P0V</name>
              <description> SD_MAXCUR3P0 register. </description>
              <lsb>8</lsb>
              <msb>15</msb>
            </field>
            <field>
              <name>CORECFG_MAXCURRENT3P3V</name>
              <description> SD_MAXCUR3P3 register. </description>
              <lsb>0</lsb>
              <msb>7</msb>
            </field>
          </fields>
        </register>
        <register>
          <name>REG_FORCEEVENTFORAUTOCMDERRORSTATUS</name>
          <description>Generate Auto CMD Error Status Interrupts, write-only.</description>
          <addressOffset>0x00000050</addressOffset>
          <size>16</size>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>FORCECMDNOTISSUEDBYAUTOCMD12ERR</name>
              <description> </description>
              <lsb>7</lsb>
              <msb>7</msb>
            </field>
            <field>
              <name>FORCEAUTOCMDINDEXERR</name>
              <description> </description>
              <lsb>4</lsb>
              <msb>4</msb>
            </field>
            <field>
              <name>FORCEAUTOCMDENDBITERR</name>
              <description> </description>
              <lsb>3</lsb>
              <msb>3</msb>
            </field>
            <field>
              <name>FORCEAUTOCMDCRCERR</name>
              <description> </description>
              <lsb>2</lsb>
              <msb>2</msb>
            </field>
            <field>
              <name>FORCEAUTOCMDTIMEOUTERR</name>
              <description> </description>
              <lsb>1</lsb>
              <msb>1</msb>
            </field>
            <field>
              <name>FORCEAUTOCMDNOTEXEC</name>
              <description> </description>
              <lsb>0</lsb>
              <msb>0</msb>
            </field>
          </fields>
        </register>
        <register>
          <name>REG_FORCEEVENTFORERRINTSTS</name>
          <description>Generate Error Interrupt Status Interrupts.</description>
          <addressOffset>0x00000052</addressOffset>
          <size>16</size>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>FORCETUNINGERR</name>
              <description> </description>
              <lsb>10</lsb>
              <msb>10</msb>
            </field>
            <field>
              <name>FORCEADMAERR</name>
              <description> </description>
              <lsb>9</lsb>
              <msb>9</msb>
            </field>
            <field>
              <name>FORCEAUTOCMDERR</name>
              <description> </description>
              <lsb>8</lsb>
              <msb>8</msb>
            </field>
            <field>
              <name>FORCECURRLIMERR</name>
              <description> </description>
              <lsb>7</lsb>
              <msb>7</msb>
            </field>
            <field>
              <name>FORCEDATENDBITERR</name>
              <description> </description>
              <lsb>6</lsb>
              <msb>6</msb>
            </field>
            <field>
              <name>FORCEDATCRCERR</name>
              <description> </description>
              <lsb>5</lsb>
              <msb>5</msb>
            </field>
            <field>
              <name>FORCEDATTIMEOUTERR</name>
              <description> </description>
              <lsb>4</lsb>
              <msb>4</msb>
            </field>
            <field>
              <name>FORCECMDINDEXERR</name>
              <description> </description>
              <lsb>3</lsb>
              <msb>3</msb>
            </field>
            <field>
              <name>FORCECMDENDBITERR</name>
              <description> </description>
              <lsb>2</lsb>
              <msb>2</msb>
            </field>
            <field>
              <name>FORCECMDCRCERR</name>
              <description> </description>
              <lsb>1</lsb>
              <msb>1</msb>
            </field>
            <field>
              <name>FORCECMDTIMEOUTERR</name>
              <description> </description>
              <lsb>0</lsb>
              <msb>0</msb>
            </field>
          </fields>
        </register>
        <register>
          <name>REG_ADMAERRSTS</name>
          <description>SDIO ADMA Error State and Address.</description>
          <addressOffset>0x00000054</addressOffset>
          <size>8</size>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>ADMAERRSTS_ADMALENMISMATCHERR</name>
              <description> 1) While the Block Count Enable being set, the total data length specified by the Descriptor table is different from that specified by the Block Count and Block Length. 2) Total data length can not be divided evenly by the block length. 1: Error 0: No Error </description>
              <lsb>2</lsb>
              <msb>2</msb>
            </field>
            <field>
              <name>ADMAERRSTS_ADMAERRORSTATE</name>
              <description> D01 - D00: ADMA Error State when error occurred Contents of SYS_SDR register. 00: ST_STOP (Stop DMA) Points to next of the error descriptor. 01: ST_FDS (Fetch Descriptor)Points to the error descriptor. 10: reserved (ADMA never stops in this state). 11: ST_TFR (Transfer Data) Points to the next error descriptor. </description>
              <lsb>0</lsb>
              <msb>1</msb>
            </field>
          </fields>
        </register>
        <register>
          <name>REG_ADMASYSADDR0</name>
          <description>Lower physical address for ADMA data transfer.</description>
          <addressOffset>0x00000058</addressOffset>
          <size>16</size>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>ADMA_SYSADDRESS0</name>
              <description> </description>
              <lsb>0</lsb>
              <msb>15</msb>
            </field>
          </fields>
        </register>
        <register>
          <name>REG_ADMASYSADDR1</name>
          <description>ADMA Physical Address, 16 LSBs.</description>
          <addressOffset>0x0000005A</addressOffset>
          <size>16</size>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>ADMA_SYSADDRESS1</name>
              <description> </description>
              <lsb>0</lsb>
              <msb>15</msb>
            </field>
          </fields>
        </register>
        <register>
          <name>REG_ADMASYSADDR2</name>
          <description>ADMA Physical Address, 16 bits.</description>
          <addressOffset>0x0000005C</addressOffset>
          <size>16</size>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>ADMA_SYSADDRESS2</name>
              <description> </description>
              <lsb>0</lsb>
              <msb>15</msb>
            </field>
          </fields>
        </register>
        <register>
          <name>REG_ADMASYSADDR3</name>
          <description>ADMA Physical Address, 16 MSBs.</description>
          <addressOffset>0x0000005E</addressOffset>
          <size>16</size>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>ADMA_SYSADDRESS3</name>
              <description> </description>
              <lsb>0</lsb>
              <msb>15</msb>
            </field>
          </fields>
        </register>
        <register>
          <name>REG_PRESETVALUE0</name>
          <description>This register is used to read the SDCLK Frequency Select Value,Clock Generator Select Value,Driver Strength Select Value</description>
          <addressOffset>0x00000060</addressOffset>
          <size>16</size>
          <resetValue>0x00000100</resetValue>
          <fields>
            <field>
              <name>DRIVERSTRENGTHSELECTVALUE</name>
              <description> 8V signaling bus speed modes. This field is meaningless for 3.3V signaling.'00' Driver Type B is Selected'01' Driver Type A is Selected'10' Driver Type C is Selected'11' Driver Type D is Selected </description>
              <lsb>14</lsb>
              <msb>15</msb>
            </field>
            <field>
              <name>CLOCKGENERATORSELECTVALUE</name>
              <description> 00 Compatible Clock Generator'1' Programmable Clock Generator </description>
              <lsb>10</lsb>
              <msb>10</msb>
            </field>
            <field>
              <name>SDCLKFREQUENCYSELECTVALUE</name>
              <description> </description>
              <lsb>0</lsb>
              <msb>9</msb>
            </field>
          </fields>
        </register>
        <register>
          <name>REG_PRESETVALUE1</name>
          <description>Default Clock and I/O Drive Preset Values. Read clock select values and I/O drive.</description>
          <addressOffset>0x00000062</addressOffset>
          <size>16</size>
          <resetValue>0x00000004</resetValue>
          <fields>
            <field>
              <name>DRIVERSTRENGTHSELECTVALUE</name>
              <description> 8V signaling bus speed modes. 00: Driver Type B is selected. (default) 01: Driver Type A is selected. 10: Driver Type C is selected. 11: Driver Type D is selected. This field is meaningless for 3.3V signaling. </description>
              <lsb>14</lsb>
              <msb>15</msb>
            </field>
            <field>
              <name>CLOCKGENERATORSELECTVALUE</name>
              <description> 0: Host Controller Ver2.00 Clock Model. 1: Programmable Clock Generator. </description>
              <lsb>10</lsb>
              <msb>10</msb>
            </field>
            <field>
              <name>SDCLKFREQUENCYSELECTVALUE</name>
              <description> </description>
              <lsb>0</lsb>
              <msb>9</msb>
            </field>
          </fields>
        </register>
        <register>
          <name>REG_PRESETVALUE2</name>
          <description>High-Speed Clock and I/O Drive Preset Values. Read clock select values and I/O drive.</description>
          <addressOffset>0x00000064</addressOffset>
          <size>16</size>
          <resetValue>0x00000002</resetValue>
          <fields>
            <field>
              <name>DRIVERSTRENGTHSELECTVALUE</name>
              <description> 8V signaling bus speed modes. This field is meaningless for 3.3V signaling.'00' Driver Type B is Selected'01' Driver Type A is Selected'10' Driver Type C is Selected'11' Driver Type D is Selected </description>
              <lsb>14</lsb>
              <msb>15</msb>
            </field>
            <field>
              <name>CLOCKGENERATORSELECTVALUE</name>
              <description> 00 Compatible Clock Generator'1' Programmable Clock Generator </description>
              <lsb>10</lsb>
              <msb>10</msb>
            </field>
            <field>
              <name>SDCLKFREQUENCYSELECTVALUE</name>
              <description> </description>
              <lsb>0</lsb>
              <msb>9</msb>
            </field>
          </fields>
        </register>
        <register>
          <name>REG_PRESETVALUE3</name>
          <description>SDR12 Clock and I/O Drive Preset Values.</description>
          <addressOffset>0x00000066</addressOffset>
          <size>16</size>
          <resetValue>0x00000004</resetValue>
          <fields>
            <field>
              <name>DRIVERSTRENGTHSELECTVALUE</name>
              <description> 8V signaling bus speed modes. This field is meaningless for 3.3V signaling.'00' Driver Type B is Selected'01' Driver Type A is Selected'10' Driver Type C is Selected'11' Driver Type D is Selected </description>
              <lsb>14</lsb>
              <msb>15</msb>
            </field>
            <field>
              <name>CLOCKGENERATORSELECTVALUE</name>
              <description> 00 Compatible Clock Generator'1' Programmable Clock Generator </description>
              <lsb>10</lsb>
              <msb>10</msb>
            </field>
            <field>
              <name>SDCLKFREQUENCYSELECTVALUE</name>
              <description> </description>
              <lsb>0</lsb>
              <msb>9</msb>
            </field>
          </fields>
        </register>
        <register>
          <name>REG_PRESETVALUE4</name>
          <description>SDR25 Clock and I/O Drive Preset Values.</description>
          <addressOffset>0x00000068</addressOffset>
          <size>16</size>
          <resetValue>0x00000002</resetValue>
          <fields>
            <field>
              <name>DRIVERSTRENGTHSELECTVALUE</name>
              <description> 8V signaling bus speed modes. This field is meaningless for 3.3V signaling.'00' Driver Type B is Selected'01' Driver Type A is Selected'10' Driver Type C is Selected'11' Driver Type D is Selected </description>
              <lsb>14</lsb>
              <msb>15</msb>
            </field>
            <field>
              <name>CLOCKGENERATORSELECTVALUE</name>
              <description> 00 Compatible Clock Generator'1' Programmable Clock Generator </description>
              <lsb>10</lsb>
              <msb>10</msb>
            </field>
            <field>
              <name>SDCLKFREQUENCYSELECTVALUE</name>
              <description> </description>
              <lsb>0</lsb>
              <msb>9</msb>
            </field>
          </fields>
        </register>
        <register>
          <name>REG_PRESETVALUE5</name>
          <description>SDR50 Clock and I/O Drive Preset Values.</description>
          <addressOffset>0x0000006A</addressOffset>
          <size>16</size>
          <resetValue>0x00000001</resetValue>
          <fields>
            <field>
              <name>DRIVERSTRENGTHSELECTVALUE</name>
              <description> 8V signaling bus speed modes. This field is meaningless for 3.3V signaling.'00' Driver Type B is Selected'01' Driver Type A is Selected'10' Driver Type C is Selected'11' Driver Type D is Selected </description>
              <lsb>14</lsb>
              <msb>15</msb>
            </field>
            <field>
              <name>CLOCKGENERATORSELECTVALUE</name>
              <description> 00 Compatible Clock Generator'1' Programmable Clock Generator </description>
              <lsb>10</lsb>
              <msb>10</msb>
            </field>
            <field>
              <name>SDCLKFREQUENCYSELECTVALUE</name>
              <description> </description>
              <lsb>0</lsb>
              <msb>9</msb>
            </field>
          </fields>
        </register>
        <register>
          <name>REG_PRESETVALUE6</name>
          <description>SDR 104 Mode Clock and I/O Drive Preset Values.</description>
          <addressOffset>0x0000006C</addressOffset>
          <size>16</size>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>DRIVERSTRENGTHSELECTVALUE</name>
              <description> 8V signaling bus speed modes. This field is meaningless for 3.3V signaling.'00' Driver Type B is Selected'01' Driver Type A is Selected'10' Driver Type C is Selected'11' Driver Type D is Selected </description>
              <lsb>14</lsb>
              <msb>15</msb>
            </field>
            <field>
              <name>CLOCKGENERATORSELECTVALUE</name>
              <description> 00 Compatible Clock Generator'1' Programmable Clock Generator </description>
              <lsb>10</lsb>
              <msb>10</msb>
            </field>
            <field>
              <name>SDCLKFREQUENCYSELECTVALUE</name>
              <description> </description>
              <lsb>0</lsb>
              <msb>9</msb>
            </field>
          </fields>
        </register>
        <register>
          <name>REG_PRESETVALUE7</name>
          <description>DDR50 Clock and I/O Drive Preset Values.</description>
          <addressOffset>0x0000006E</addressOffset>
          <size>16</size>
          <resetValue>0x00000002</resetValue>
          <fields>
            <field>
              <name>DRIVERSTRENGTHSELECTVALUE</name>
              <description> 8V signaling bus speed modes. This field is meaningless for 3.3V signaling.'00' Driver Type B is Selected'01' Driver Type A is Selected'10' Driver Type C is Selected'11' Driver Type D is Selected </description>
              <lsb>14</lsb>
              <msb>15</msb>
            </field>
            <field>
              <name>CLOCKGENERATORSELECTVALUE</name>
              <description> 00 Compatible Clock Generator'1' Programmable Clock Generator </description>
              <lsb>10</lsb>
              <msb>10</msb>
            </field>
            <field>
              <name>SDCLKFREQUENCYSELECTVALUE</name>
              <description> </description>
              <lsb>0</lsb>
              <msb>9</msb>
            </field>
          </fields>
        </register>
        <register>
          <name>REG_BOOTTIMEOUTCNT</name>
          <description>Program the boot timeout value counter.</description>
          <addressOffset>0x00000070</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>BOOT_TIMEOUTCNT</name>
              <description> The value is in number of SD_CLK clocks. </description>
              <lsb>0</lsb>
              <msb>31</msb>
            </field>
          </fields>
        </register>
        <register>
          <name>REG_SLOTINTRSTS</name>
          <description>Read the interrupt signal for each slot.</description>
          <addressOffset>0x000000FC</addressOffset>
          <size>16</size>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>SDHCHOSTIF_SLOTINTRSTS</name>
              <description> A maximum of 8 slots can be defined. </description>
              <lsb>0</lsb>
              <msb>7</msb>
            </field>
          </fields>
        </register>
        <register>
          <name>REG_HOSTCONTROLLERVER</name>
          <description>Controller version and specification numbers.</description>
          <addressOffset>0x000000FE</addressOffset>
          <size>16</size>
          <resetValue>0x00001002</resetValue>
          <fields>
            <field>
              <name>SDHC_VENVERNUM</name>
              <description> 0). </description>
              <lsb>8</lsb>
              <msb>15</msb>
            </field>
            <field>
              <name>SPECIFICATIONVERSIONNUMBER</name>
              <description> 00. </description>
              <lsb>0</lsb>
              <msb>7</msb>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral derivedFrom="SD0">
      <name>SD1</name>
      <version>1.0</version>
      <description>SDIO 0 Controller</description>
      <baseAddress>0xff170000</baseAddress>
    </peripheral>
    <peripheral>
      <name>QSPI</name>
      <version>1.0</version>
      <description>Quad SPI Controller</description>
      <baseAddress>0xff0f0000</baseAddress>
      <addressBlock>
        <offset>0x0</offset>
        <size>0x00000828</size>
        <usage>registers</usage>
        <protection>s</protection>
      </addressBlock>
      <registers>
        <register>
          <name>CONFIG</name>
          <description>QSPI configuration register</description>
          <addressOffset>0x00000000</addressOffset>
          <size>32</size>
          <resetValue>0x80000000</resetValue>
          <fields>
            <field>
              <name>LEG_FLSH</name>
              <description> If this mode is disabled, the core will operate in standard SPI mode, with no dual- or quad-bit input or output capability; the extended bits will be configured as inputs to prevent any driver contention on these pins. If enabled, flash memory interface instructions are automatically recognized and the I/O configured accordingly. </description>
              <lsb>31</lsb>
              <msb>31</msb>
            </field>
            <field>
              <name>RESERVED</name>
              <description> </description>
              <lsb>27</lsb>
              <msb>30</msb>
            </field>
            <field>
              <name>ENDIAN</name>
              <description> 1: big endian format when writing to the transmit data register 0x1C or reading from the receive data register 0x20. </description>
              <lsb>26</lsb>
              <msb>26</msb>
            </field>
            <field>
              <name>RESERVED</name>
              <description> </description>
              <lsb>20</lsb>
              <msb>25</msb>
            </field>
            <field>
              <name>HOLDB_DR</name>
              <description> If not set, then external pull up is required on HOLDb and WPn pins. Note that this bit doesn't affect the quad (4-bit) mode as Controller always drives these pins in quad mode. It is highly recommended to set this bit always(irrespective of mode of operation) while using QSPI. </description>
              <lsb>19</lsb>
              <msb>19</msb>
            </field>
            <field>
              <name>RESERVED</name>
              <description> </description>
              <lsb>17</lsb>
              <msb>18</msb>
            </field>
            <field>
              <name>MAN_START_COM</name>
              <description> </description>
              <lsb>16</lsb>
              <msb>16</msb>
            </field>
            <field>
              <name>MAN_START_EN</name>
              <description> </description>
              <lsb>15</lsb>
              <msb>15</msb>
            </field>
            <field>
              <name>MANUAL_CS</name>
              <description> </description>
              <lsb>14</lsb>
              <msb>14</msb>
            </field>
            <field>
              <name>RESERVED</name>
              <description> </description>
              <lsb>11</lsb>
              <msb>13</msb>
            </field>
            <field>
              <name>PCS</name>
              <description> In manual CS mode, this bit should be programmed before writing Transmit Data Registers (TXDx). </description>
              <lsb>10</lsb>
              <msb>10</msb>
            </field>
            <field>
              <name>RESERVED</name>
              <description> </description>
              <lsb>9</lsb>
              <msb>9</msb>
            </field>
            <field>
              <name>REF_CLK</name>
              <description> Must be 0 </description>
              <lsb>8</lsb>
              <msb>8</msb>
            </field>
            <field>
              <name>FIFO_WIDTH</name>
              <description> All other settings are not supported. </description>
              <lsb>6</lsb>
              <msb>7</msb>
            </field>
            <field>
              <name>BAUD_RATE_DIV</name>
              <description> This is the only baud rate setting that can be used if the loopback clock is enabled [USE_LPBK]. 001: divide by 4 010: divide by 8 011: divide by 16 100: divide by 32 101: divide by 64 110: divide by 128 111: divide by 256 </description>
              <lsb>3</lsb>
              <msb>5</msb>
            </field>
            <field>
              <name>CLK_PH</name>
              <description> </description>
              <lsb>2</lsb>
              <msb>2</msb>
            </field>
            <field>
              <name>CLK_POL</name>
              <description> </description>
              <lsb>1</lsb>
              <msb>1</msb>
            </field>
            <field>
              <name>MODE_SEL</name>
              <description> In other boot modes, this bit must be set before using QSPI. </description>
              <lsb>0</lsb>
              <msb>0</msb>
            </field>
          </fields>
        </register>
        <register>
          <name>ISR</name>
          <description>Interrupt Status</description>
          <addressOffset>0x00000004</addressOffset>
          <size>32</size>
          <resetValue>0x00000104</resetValue>
          <fields>
            <field>
              <name>RESERVED</name>
              <description> </description>
              <lsb>9</lsb>
              <msb>31</msb>
            </field>
            <field>
              <name>TXFIFO_EMPTY</name>
              <description> 1: TX FIFO is empty. </description>
              <lsb>8</lsb>
              <msb>8</msb>
            </field>
            <field>
              <name>RESERVED</name>
              <description> </description>
              <lsb>7</lsb>
              <msb>7</msb>
            </field>
            <field>
              <name>TX_FIFO_UNDERFLOW</name>
              <description> 1: underflow is detected. Write 1 to this bit location to clear </description>
              <lsb>6</lsb>
              <msb>6</msb>
            </field>
            <field>
              <name>RX_FIFO_FULL</name>
              <description> 1: FIFO is full. </description>
              <lsb>5</lsb>
              <msb>5</msb>
            </field>
            <field>
              <name>RX_FIFO_NOT_EMPTY</name>
              <description> 1: FIFO has more than or equal to RX THRESHOLD entries. </description>
              <lsb>4</lsb>
              <msb>4</msb>
            </field>
            <field>
              <name>TX_FIFO_FULL</name>
              <description> </description>
              <lsb>3</lsb>
              <msb>3</msb>
            </field>
            <field>
              <name>TX_FIFO_NOT_FULL</name>
              <description> 1: FIFO has less than TX THRESHOLD entries. </description>
              <lsb>2</lsb>
              <msb>2</msb>
            </field>
            <field>
              <name>RESERVED</name>
              <description> </description>
              <lsb>1</lsb>
              <msb>1</msb>
            </field>
            <field>
              <name>RX_OVERFLOW</name>
              <description> 1: overflow occurred. Write 1 to this bit location to clear. </description>
              <lsb>0</lsb>
              <msb>0</msb>
            </field>
          </fields>
        </register>
        <register>
          <name>IER</name>
          <description>Interrupt Enable</description>
          <addressOffset>0x00000008</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RESERVED</name>
              <description> </description>
              <lsb>9</lsb>
              <msb>31</msb>
            </field>
            <field>
              <name>TXFIFO_EMPTY</name>
              <description> </description>
              <lsb>8</lsb>
              <msb>8</msb>
            </field>
            <field>
              <name>RESERVED</name>
              <description> </description>
              <lsb>7</lsb>
              <msb>7</msb>
            </field>
            <field>
              <name>TX_FIFO_UNDERFLOW</name>
              <description> </description>
              <lsb>6</lsb>
              <msb>6</msb>
            </field>
            <field>
              <name>RX_FIFO_FULL</name>
              <description> </description>
              <lsb>5</lsb>
              <msb>5</msb>
            </field>
            <field>
              <name>RX_FIFO_NOT_EMPTY</name>
              <description> </description>
              <lsb>4</lsb>
              <msb>4</msb>
            </field>
            <field>
              <name>TX_FIFO_FULL</name>
              <description> </description>
              <lsb>3</lsb>
              <msb>3</msb>
            </field>
            <field>
              <name>TX_FIFO_NOT_FULL</name>
              <description> </description>
              <lsb>2</lsb>
              <msb>2</msb>
            </field>
            <field>
              <name>RESERVED</name>
              <description> </description>
              <lsb>1</lsb>
              <msb>1</msb>
            </field>
            <field>
              <name>RX_OVERFLOW</name>
              <description> </description>
              <lsb>0</lsb>
              <msb>0</msb>
            </field>
          </fields>
        </register>
        <register>
          <name>IDR</name>
          <description>Interrupt Disable</description>
          <addressOffset>0x0000000C</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RESERVED</name>
              <description> </description>
              <lsb>9</lsb>
              <msb>31</msb>
            </field>
            <field>
              <name>TXFIFO_EMPTY</name>
              <description> </description>
              <lsb>8</lsb>
              <msb>8</msb>
            </field>
            <field>
              <name>RESERVED</name>
              <description> </description>
              <lsb>7</lsb>
              <msb>7</msb>
            </field>
            <field>
              <name>TX_FIFO_UNDERFLOW</name>
              <description> </description>
              <lsb>6</lsb>
              <msb>6</msb>
            </field>
            <field>
              <name>RX_FIFO_FULL</name>
              <description> </description>
              <lsb>5</lsb>
              <msb>5</msb>
            </field>
            <field>
              <name>RX_FIFO_NOT_EMPTY</name>
              <description> </description>
              <lsb>4</lsb>
              <msb>4</msb>
            </field>
            <field>
              <name>TX_FIFO_FULL</name>
              <description> </description>
              <lsb>3</lsb>
              <msb>3</msb>
            </field>
            <field>
              <name>TX_FIFO_NOT_FULL</name>
              <description> </description>
              <lsb>2</lsb>
              <msb>2</msb>
            </field>
            <field>
              <name>RESERVED</name>
              <description> </description>
              <lsb>1</lsb>
              <msb>1</msb>
            </field>
            <field>
              <name>RX_OVERFLOW</name>
              <description> </description>
              <lsb>0</lsb>
              <msb>0</msb>
            </field>
          </fields>
        </register>
        <register>
          <name>IMR</name>
          <description>Interrupt Un-Mask (enabled)</description>
          <addressOffset>0x00000010</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RESERVED</name>
              <description> </description>
              <lsb>9</lsb>
              <msb>31</msb>
            </field>
            <field>
              <name>TXFIFO_EMPTY</name>
              <description> </description>
              <lsb>8</lsb>
              <msb>8</msb>
            </field>
            <field>
              <name>RESERVED</name>
              <description> </description>
              <lsb>7</lsb>
              <msb>7</msb>
            </field>
            <field>
              <name>TX_FIFO_UNDERFLOW</name>
              <description> </description>
              <lsb>6</lsb>
              <msb>6</msb>
            </field>
            <field>
              <name>RX_FIFO_FULL</name>
              <description> </description>
              <lsb>5</lsb>
              <msb>5</msb>
            </field>
            <field>
              <name>RX_FIFO_NOT_EMPTY</name>
              <description> </description>
              <lsb>4</lsb>
              <msb>4</msb>
            </field>
            <field>
              <name>TX_FIFO_FULL</name>
              <description> </description>
              <lsb>3</lsb>
              <msb>3</msb>
            </field>
            <field>
              <name>TX_FIFO_NOT_FULL</name>
              <description> </description>
              <lsb>2</lsb>
              <msb>2</msb>
            </field>
            <field>
              <name>RESERVED</name>
              <description> </description>
              <lsb>1</lsb>
              <msb>1</msb>
            </field>
            <field>
              <name>RX_OVERFLOW</name>
              <description> </description>
              <lsb>0</lsb>
              <msb>0</msb>
            </field>
          </fields>
        </register>
        <register>
          <name>LQSPI_EN</name>
          <description>LQSPI Enable</description>
          <addressOffset>0x00000014</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RESERVED</name>
              <description> </description>
              <lsb>1</lsb>
              <msb>31</msb>
            </field>
            <field>
              <name>SPI_EN</name>
              <description> 1: enable the SPI. Note: Change this value only when controller is not communicating with the memory device. </description>
              <lsb>0</lsb>
              <msb>0</msb>
            </field>
          </fields>
        </register>
        <register>
          <name>DELAY</name>
          <description>Timing Control Delay</description>
          <addressOffset>0x00000018</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>D_NSS</name>
              <description> </description>
              <lsb>24</lsb>
              <msb>31</msb>
            </field>
            <field>
              <name>D_BTWN</name>
              <description> </description>
              <lsb>16</lsb>
              <msb>23</msb>
            </field>
            <field>
              <name>D_AFTER</name>
              <description> </description>
              <lsb>8</lsb>
              <msb>15</msb>
            </field>
            <field>
              <name>D_INT</name>
              <description> </description>
              <lsb>0</lsb>
              <msb>7</msb>
            </field>
          </fields>
        </register>
        <register>
          <name>TXD0</name>
          <description>Transmit Data, 4 Bytes</description>
          <addressOffset>0x0000001C</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>TXD</name>
              <description> </description>
              <lsb>0</lsb>
              <msb>31</msb>
            </field>
          </fields>
        </register>
        <register>
          <name>RX_DATA</name>
          <description>Receive Data in RX FIFO</description>
          <addressOffset>0x00000020</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RX_FIFO_DATA</name>
              <description> </description>
              <lsb>0</lsb>
              <msb>31</msb>
            </field>
          </fields>
        </register>
        <register>
          <name>SLAVE_IDLE_COUNT</name>
          <description>Slave Idle Count</description>
          <addressOffset>0x00000024</addressOffset>
          <size>32</size>
          <resetValue>0x000000FF</resetValue>
          <fields>
            <field>
              <name>RESERVED</name>
              <description> </description>
              <lsb>8</lsb>
              <msb>31</msb>
            </field>
          </fields>
        </register>
        <register>
          <name>TX_THRES</name>
          <description>TX FIFO Threshold</description>
          <addressOffset>0x00000028</addressOffset>
          <size>32</size>
          <resetValue>0x00000001</resetValue>
          <fields>
            <field>
              <name>THRESHOLD_OF_TX_FIFO</name>
              <description> </description>
              <lsb>0</lsb>
              <msb>31</msb>
            </field>
          </fields>
        </register>
        <register>
          <name>RX_THRES</name>
          <description>RX FIFO Threshold</description>
          <addressOffset>0x0000002C</addressOffset>
          <size>32</size>
          <resetValue>0x00000001</resetValue>
          <fields>
            <field>
              <name>THRESHOLD_OF_RX_FIFO</name>
              <description> </description>
              <lsb>0</lsb>
              <msb>31</msb>
            </field>
          </fields>
        </register>
        <register>
          <name>GPIO</name>
          <description>Write Protection Output</description>
          <addressOffset>0x00000030</addressOffset>
          <size>32</size>
          <resetValue>0x00000001</resetValue>
          <fields>
            <field>
              <name>WP_N</name>
              <description> 0: output low. 1: output high (reset default). The active low function may be inverted externally for devices requiring an active high write protect signal. Note: Change this value only when controller is not communicating with the memory device. </description>
              <lsb>0</lsb>
              <msb>0</msb>
            </field>
          </fields>
        </register>
        <register>
          <name>LPBK_DLY_ADJ</name>
          <description>Loopback Master Clock Delay Adjustment</description>
          <addressOffset>0x00000038</addressOffset>
          <size>32</size>
          <resetValue>0x00000033</resetValue>
          <fields>
            <field>
              <name>RESERVED</name>
              <description> </description>
              <lsb>7</lsb>
              <msb>31</msb>
            </field>
            <field>
              <name>RESERVED</name>
              <description> </description>
              <lsb>6</lsb>
              <msb>6</msb>
            </field>
            <field>
              <name>USE_LPBK</name>
              <description> Note: Change this value only when controller is not communicating with the memory device. </description>
              <lsb>5</lsb>
              <msb>5</msb>
            </field>
            <field>
              <name>DLY1</name>
              <description> Note: Change this value only when controller is not communicating with the memory device. </description>
              <lsb>3</lsb>
              <msb>4</msb>
            </field>
            <field>
              <name>DLY0</name>
              <description> Note: Change this value only when controller is not communicating with the memory device. </description>
              <lsb>0</lsb>
              <msb>2</msb>
            </field>
          </fields>
        </register>
        <register>
          <name>TXD1</name>
          <description>Transmit Data, 1 Byte</description>
          <addressOffset>0x00000080</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>TXD</name>
              <description> In little endian mode (default), only bits 7:0 are valid, bits 31:8 are ignored. In big endian mode, only the 8 MSB bits are valid. </description>
              <lsb>0</lsb>
              <msb>31</msb>
            </field>
          </fields>
        </register>
        <register>
          <name>TXD2</name>
          <description>Transmit Data, 2 Byte</description>
          <addressOffset>0x00000084</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>TXD</name>
              <description> In little endian mode (default), only bits 15:0 are valid, bits 31:16 are ignored. In big endian mode, only the 16 MSB bits are valid. </description>
              <lsb>0</lsb>
              <msb>31</msb>
            </field>
          </fields>
        </register>
        <register>
          <name>TXD3</name>
          <description>Transmit Data, 3 Bytes</description>
          <addressOffset>0x00000088</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>TXD</name>
              <description> In little endian mode (default), only bits 23:0 are valid, bits 31:24 are ignored. In big endian mode, only the 24 MSB bits are valid. </description>
              <lsb>0</lsb>
              <msb>31</msb>
            </field>
          </fields>
        </register>
        <register>
          <name>LQSPI_CFG</name>
          <description>Configuration</description>
          <addressOffset>0x000000A0</addressOffset>
          <size>32</size>
          <resetValue>0x000002EB</resetValue>
          <fields>
            <field>
              <name>LQ_MODE</name>
              <description> 1: Legacy LQSPI, Linear Quad-SPI. Note: Change this value only when controller is not communicating with the memory device. </description>
              <lsb>31</lsb>
              <msb>31</msb>
            </field>
            <field>
              <name>TWO_MEM</name>
              <description> 1: Two memory devices. Note: Change this value only when controller is not communicating with the memory device. </description>
              <lsb>30</lsb>
              <msb>30</msb>
            </field>
            <field>
              <name>SEP_BUS</name>
              <description> 1: Separate memory intefaces. This bit only has meaning if [TWO_MEM] = 1. Note: Change this value only when controller is not communicating with the memory device. </description>
              <lsb>29</lsb>
              <msb>29</msb>
            </field>
            <field>
              <name>U_PAGE</name>
              <description> 1: Upper memory page. This bit only has meaning if: [TWO_MEM] = 1 (two devices) [SEP_BUS] = 0 (one interface) IO mode is not supported in LQSPI; [U_PAGE] selects the lower or upper memory for configuration or read/write operations. Note: Change this value only when controller is not communicating with the memory device. </description>
              <lsb>28</lsb>
              <msb>28</msb>
            </field>
            <field>
              <name>ADDR_32BIT</name>
              <description> 1: Five zero bits &amp; lower 27 bits of AXI address. Note: Change this value only when controller is not communicating with the memory device. </description>
              <lsb>27</lsb>
              <msb>27</msb>
            </field>
            <field>
              <name>RESERVED</name>
              <description> </description>
              <lsb>26</lsb>
              <msb>26</msb>
            </field>
            <field>
              <name>MODE_EN</name>
              <description> 1: Send MODE_BITS[23:16]. Must be set = 1 for dual or quad I/O read (specified through [7:0]). Must be clear = 0 for all other read modes as they do not have mode bits. If this bit is 0, [MODE_ON, 24] and [MODE_BITS] are ignored. Relationship of bits [25], [24] and [23:16] are related: if ( [ Bit25 == 0 ] &amp;&amp; [ Bit24 == x ] ) then [ Bits23:16 = x ] if ( [ Bit25 == 1 ] &amp;&amp; [ Bit24 == 0 ] ) then [ Bits23:16 = ~(8'bxx10xxxx) ] if ( [ Bit25 == 1 ] &amp;&amp; [ Bit24 == 1 ] ) then [ Bits23:16 = 8'bxx10xxxx ]. Note: Change this value only when controller is not communicating with the memory device. </description>
              <lsb>25</lsb>
              <msb>25</msb>
            </field>
            <field>
              <name>MODE_ON</name>
              <description> 0: Instruction code is sent for all read transfers. 1: Instruction code is sent only for first read transfer. This bit applies when [MODE_EN, 25] is set = 1. This bit is configured in association with [MODE_BITS]. For Winbond devices, this bit must be set = 1 if the [MODE_BITS] = 8'bxx10xxxx, else clear = 0. Note: Change this value only when the controller is not communicating with the memory device. </description>
              <lsb>24</lsb>
              <msb>24</msb>
            </field>
            <field>
              <name>MODE_BITS</name>
              <description> These bits apply when [MODE_EN, 25] = 1. Required for both dual I/O read and quad I/O read. See Flash memory vendor's datasheet for more information on the mode bits. For the Winbond device, the continuous read mode value is 8'bxx10xxxx to skip the instruction code for the next read transfer, else instruction code is sent for all read transfers. Bit 24 has to be configured accordingly with this value. Note: Change this value only when controller is not communicating with the memory device. </description>
              <lsb>16</lsb>
              <msb>23</msb>
            </field>
            <field>
              <name>RESERVED</name>
              <description> </description>
              <lsb>11</lsb>
              <msb>15</msb>
            </field>
            <field>
              <name>INST_CODE</name>
              <description> The known read instruction codes are: 8'h03 - Read 8'h0B - Fast read 8'h3B - Fast read dual output 8'h6B - Fast read quad output 8'hBB - Fast read dual I/O 8'hEB - Fast read quad I/O 8'h13 - Four Byte Address Read 8'h0C - Four Byte Address Fast read 8'h3C - Four Byte Address Fast read dual output 8'h6C - Four Byte Address Fast read quad output 8'hBC - Four Byte Address Fast read dual I/O 8'hEC - Four Byte Address Fast read quad I/O This is a static signal - should not be changed while controller is actively transmitting/receiving data to/from Flash device </description>
              <lsb>0</lsb>
              <msb>7</msb>
            </field>
          </fields>
        </register>
        <register>
          <name>LQSPI_STS</name>
          <description>Status</description>
          <addressOffset>0x000000A4</addressOffset>
          <size>9</size>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RESERVED</name>
              <description> </description>
              <lsb>3</lsb>
              <msb>8</msb>
            </field>
            <field>
              <name>D_FSM_ERR</name>
              <description> </description>
              <lsb>2</lsb>
              <msb>2</msb>
            </field>
            <field>
              <name>WR_RECVD</name>
              <description> </description>
              <lsb>1</lsb>
              <msb>1</msb>
            </field>
            <field>
              <name>RESERVED</name>
              <description> </description>
              <lsb>0</lsb>
              <msb>0</msb>
            </field>
          </fields>
        </register>
        <register>
          <name>COMMAND</name>
          <description>Command control</description>
          <addressOffset>0x000000C0</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RESERVED</name>
              <description> Return 0 when read. Writes ignored. </description>
              <lsb>21</lsb>
              <msb>31</msb>
            </field>
            <field>
              <name>RXFIFO_DRAIN</name>
              <description> This bit can be set for any write transfer to the Flash so that the HW will discard the data captured while transmitting the write data. 0: Do not discard the data in RXFIFO. 1: Discard the data in RXFIFO. Note: Change this value only when controller is not communicating with the memory device. </description>
              <lsb>20</lsb>
              <msb>20</msb>
            </field>
            <field>
              <name>RXFIFO_DRAIN_STATUS</name>
              <description> 0: RXFIFO_DRAIN is reset. 1: RXFIFO_DRAIN is set. </description>
              <lsb>19</lsb>
              <msb>19</msb>
            </field>
            <field>
              <name>PARTIAL_BYTE_LEN</name>
              <description> (TXDx length - PARTIAL_BYTE_LEN) is the number of bits to be transmitted For example, if only 4 bits to be transmitted, program PARTIAL_BYTE_LEN with a value of 4 and then configure TXD1 register. Similar way to transmit 12 bits, program PARTIAL_BYTE_LEN a value of 4 and then configure TXD2 register. Value in this files is cleared by HW soon after completing transmission of partial byte. SW need to write into this register again if need to transfer partial byte. This is a static signal - should not be changed while controller is actively transmitting/receiving data to/from Flash device </description>
              <lsb>16</lsb>
              <msb>18</msb>
            </field>
            <field>
              <name>RX_DISCARD_REG</name>
              <description> In general value in this field should be equal to QSPI clocks required to transmit Command+Address+Dummy cycles. This is a static signal - should not be changed while controller is actively transmitting/receiving data to/from Flash device </description>
              <lsb>8</lsb>
              <msb>14</msb>
            </field>
            <field>
              <name>DUMMY_CYCLES</name>
              <description> This is a static signal - should not be changed while controller is actively transmitting/receiving data to/from Flash device </description>
              <lsb>2</lsb>
              <msb>7</msb>
            </field>
            <field>
              <name>DMA_EN</name>
              <description> And the encoding is as mentioned below {DMA_EN, LQSPI_CFG[31]}: 01: Linear Mode. 10: DMA Mode. Others: reserved. Never set both the [DMA_EN] and LQSPI_SFG [31] bits to 1 as it is not a valid condition. This is a static signal - should not be changed while controller is actively transmitting/receiving data to/from Flash device </description>
              <lsb>1</lsb>
              <msb>1</msb>
            </field>
          </fields>
        </register>
        <register>
          <name>TRANSFER_SIZE</name>
          <description>Transfer Size</description>
          <addressOffset>0x000000C4</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RESERVED</name>
              <description> Return 0 when read. Writes ignored. </description>
              <lsb>29</lsb>
              <msb>31</msb>
            </field>
            <field>
              <name>SIZE</name>
              <description> (2 lsb's are 0) The value in this register signifies the number of words to be read from memory. This is a static signal - should not be changed while controller is actively transmitting/receiving data to/from Flash device </description>
              <lsb>2</lsb>
              <msb>28</msb>
            </field>
            <field>
              <name>RESERVED</name>
              <description> Return 0 when read. Writes ignored. </description>
              <lsb>0</lsb>
              <msb>1</msb>
            </field>
          </fields>
        </register>
        <register>
          <name>DUMMY_CYCLE_EN</name>
          <description>Dummy Cycles Enable</description>
          <addressOffset>0x000000C8</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RESERVED</name>
              <description> Return 0 when read. Writes ignored. </description>
              <lsb>1</lsb>
              <msb>31</msb>
            </field>
            <field>
              <name>DUMMY_CYCLE_EN</name>
              <description> This bit is applicable only in Linear mode. This bit should not be used in DMA mode. 0: Disable using dummy cycle value. 1: Enable using dummy cycle value. This is a static signal - should not be changed while controller is actively transmitting/receiving data to/from Flash device </description>
              <lsb>0</lsb>
              <msb>0</msb>
            </field>
          </fields>
        </register>
        <register>
          <name>MOD_ID</name>
          <description>Module Identification</description>
          <addressOffset>0x000000FC</addressOffset>
          <size>32</size>
          <resetValue>0x01090101</resetValue>
          <fields> </fields>
        </register>
        <register>
          <name>GQSPI_CFG</name>
          <description>GQSPI Configuration</description>
          <addressOffset>0x00000100</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>MODE_EN</name>
              <description> </description>
              <lsb>30</lsb>
              <msb>31</msb>
            </field>
            <field>
              <name>GEN_FIFO_START_MODE</name>
              <description> 1: Manual Start Mode. Note: Change this value only when controller is not communicating with the memory device. </description>
              <lsb>29</lsb>
              <msb>29</msb>
            </field>
            <field>
              <name>START_GEN_FIFO</name>
              <description> 0:disable executing requests. 1: enable executing requests. Note: Change this value only when controller is not communicating with the memory device. </description>
              <lsb>28</lsb>
              <msb>28</msb>
            </field>
            <field>
              <name>RESERVED</name>
              <description> </description>
              <lsb>27</lsb>
              <msb>27</msb>
            </field>
            <field>
              <name>ENDIAN</name>
              <description> 1: big endian. Note: Change this value only when controller is not communicating with the memory device. </description>
              <lsb>26</lsb>
              <msb>26</msb>
            </field>
            <field>
              <name>RESERVED</name>
              <description> </description>
              <lsb>21</lsb>
              <msb>25</msb>
            </field>
            <field>
              <name>EN_POLL_TIMEOUT</name>
              <description> 1: enable. Note: Change this value only when controller is not communicating with the memory device. </description>
              <lsb>20</lsb>
              <msb>20</msb>
            </field>
            <field>
              <name>WP_HOLD</name>
              <description> If not set, then external pull up is required on HOLDb and WPn pins. Note that this bit doesn't affect the quad(4-bit) mode as Controller always drives these pins in quad mode. It is highly recommended to set this bit always(irrespective of mode of operation) while using GQSPI Note: Change this value only when controller is not communicating with the memory device. </description>
              <lsb>19</lsb>
              <msb>19</msb>
            </field>
            <field>
              <name>RESERVED</name>
              <description> </description>
              <lsb>6</lsb>
              <msb>18</msb>
            </field>
            <field>
              <name>BAUD_RATE_DIV</name>
              <description> 001: divide by 4. 010: divide by 8. 011: divide by 16. 100: divide by 32. 101: divide by 64. 110: divide by 128. 111: divide by 256. Note: 000 is requried for loopback, [USE_LPBK]. Note: Change this value only when controller is not communicating with the memory device. </description>
              <lsb>3</lsb>
              <msb>5</msb>
            </field>
            <field>
              <name>CLK_PH</name>
              <description> Note: Change this value only when controller is not communicating with the memory device. </description>
              <lsb>2</lsb>
              <msb>2</msb>
            </field>
            <field>
              <name>CLK_POL</name>
              <description> 0: QSPI clock is quiescent low. 1: QSPI clock is quiescent high. Note: For [CLK_PH, CLK_POL], only 2'b11 and 2'b00 are supported. Note: Change this value only when controller is not communicating with the memory device. </description>
              <lsb>1</lsb>
              <msb>1</msb>
            </field>
            <field>
              <name>RESERVED</name>
              <description> </description>
              <lsb>0</lsb>
              <msb>0</msb>
            </field>
          </fields>
        </register>
        <register>
          <name>GQSPI_ISR</name>
          <description>Generic QSPI interrupt status</description>
          <addressOffset>0x00000104</addressOffset>
          <size>32</size>
          <resetValue>0x00000B84</resetValue>
          <fields>
            <field>
              <name>RESERVED</name>
              <description> </description>
              <lsb>12</lsb>
              <msb>31</msb>
            </field>
            <field>
              <name>RX_FIFO_EMPTY</name>
              <description> </description>
              <lsb>11</lsb>
              <msb>11</msb>
            </field>
            <field>
              <name>GEN_FIFO_FULL</name>
              <description> </description>
              <lsb>10</lsb>
              <msb>10</msb>
            </field>
            <field>
              <name>GEN_FIFO_NOT_FULL</name>
              <description> </description>
              <lsb>9</lsb>
              <msb>9</msb>
            </field>
            <field>
              <name>TX_FIFO_EMPTY</name>
              <description> </description>
              <lsb>8</lsb>
              <msb>8</msb>
            </field>
            <field>
              <name>GEN_FIFO_EMPTY</name>
              <description> </description>
              <lsb>7</lsb>
              <msb>7</msb>
            </field>
            <field>
              <name>RESERVED</name>
              <description> </description>
              <lsb>6</lsb>
              <msb>6</msb>
            </field>
            <field>
              <name>RX_FIFO_FULL</name>
              <description> </description>
              <lsb>5</lsb>
              <msb>5</msb>
            </field>
            <field>
              <name>RX_FIFO_NOT_EMPTY</name>
              <description> </description>
              <lsb>4</lsb>
              <msb>4</msb>
            </field>
            <field>
              <name>TX_FIFO_FULL</name>
              <description> </description>
              <lsb>3</lsb>
              <msb>3</msb>
            </field>
            <field>
              <name>TX_FIFO_NOT_FULL</name>
              <description> </description>
              <lsb>2</lsb>
              <msb>2</msb>
            </field>
            <field>
              <name>POLL_TIME_EXPIRE</name>
              <description> </description>
              <lsb>1</lsb>
              <msb>1</msb>
            </field>
            <field>
              <name>RESERVED</name>
              <description> </description>
              <lsb>0</lsb>
              <msb>0</msb>
            </field>
          </fields>
        </register>
        <register>
          <name>GQSPI_IER</name>
          <description>GQSPI Interrupt Enable</description>
          <addressOffset>0x00000108</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RESERVED</name>
              <description> </description>
              <lsb>12</lsb>
              <msb>31</msb>
            </field>
            <field>
              <name>RX_FIFO_EMPTY</name>
              <description> </description>
              <lsb>11</lsb>
              <msb>11</msb>
            </field>
            <field>
              <name>GEN_FIFO_FULL</name>
              <description> </description>
              <lsb>10</lsb>
              <msb>10</msb>
            </field>
            <field>
              <name>GEN_FIFO_NOT_FULL</name>
              <description> </description>
              <lsb>9</lsb>
              <msb>9</msb>
            </field>
            <field>
              <name>TX_FIFO_EMPTY</name>
              <description> </description>
              <lsb>8</lsb>
              <msb>8</msb>
            </field>
            <field>
              <name>GEN_FIFO_EMPTY</name>
              <description> </description>
              <lsb>7</lsb>
              <msb>7</msb>
            </field>
            <field>
              <name>RESERVED</name>
              <description> </description>
              <lsb>6</lsb>
              <msb>6</msb>
            </field>
            <field>
              <name>RX_FIFO_FULL</name>
              <description> </description>
              <lsb>5</lsb>
              <msb>5</msb>
            </field>
            <field>
              <name>RX_FIFO_NOT_EMPTY</name>
              <description> </description>
              <lsb>4</lsb>
              <msb>4</msb>
            </field>
            <field>
              <name>TX_FIFO_FULL</name>
              <description> </description>
              <lsb>3</lsb>
              <msb>3</msb>
            </field>
            <field>
              <name>TX_FIFO_NOT_FULL</name>
              <description> </description>
              <lsb>2</lsb>
              <msb>2</msb>
            </field>
            <field>
              <name>POLL_TIME_EXPIRE</name>
              <description> </description>
              <lsb>1</lsb>
              <msb>1</msb>
            </field>
            <field>
              <name>RESERVED</name>
              <description> </description>
              <lsb>0</lsb>
              <msb>0</msb>
            </field>
          </fields>
        </register>
        <register>
          <name>GQSPI_IDR</name>
          <description>GQSPI Interrupt disable</description>
          <addressOffset>0x0000010C</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RESERVED</name>
              <description> </description>
              <lsb>12</lsb>
              <msb>31</msb>
            </field>
            <field>
              <name>RX_FIFO_EMPTY</name>
              <description> </description>
              <lsb>11</lsb>
              <msb>11</msb>
            </field>
            <field>
              <name>GEN_FIFO_FULL</name>
              <description> </description>
              <lsb>10</lsb>
              <msb>10</msb>
            </field>
            <field>
              <name>GEN_FIFO_NOT_FULL</name>
              <description> </description>
              <lsb>9</lsb>
              <msb>9</msb>
            </field>
            <field>
              <name>TX_FIFO_EMPTY</name>
              <description> </description>
              <lsb>8</lsb>
              <msb>8</msb>
            </field>
            <field>
              <name>GEN_FIFO_EMPTY</name>
              <description> </description>
              <lsb>7</lsb>
              <msb>7</msb>
            </field>
            <field>
              <name>RESERVED</name>
              <description> </description>
              <lsb>6</lsb>
              <msb>6</msb>
            </field>
            <field>
              <name>RX_FIFO_FULL</name>
              <description> </description>
              <lsb>5</lsb>
              <msb>5</msb>
            </field>
            <field>
              <name>RX_FIFO_NOT_EMPTY</name>
              <description> </description>
              <lsb>4</lsb>
              <msb>4</msb>
            </field>
            <field>
              <name>TX_FIFO_FULL</name>
              <description> </description>
              <lsb>3</lsb>
              <msb>3</msb>
            </field>
            <field>
              <name>TX_FIFO_NOT_FULL</name>
              <description> </description>
              <lsb>2</lsb>
              <msb>2</msb>
            </field>
            <field>
              <name>POLL_TIME_EXPIRE</name>
              <description> </description>
              <lsb>1</lsb>
              <msb>1</msb>
            </field>
            <field>
              <name>RESERVED</name>
              <description> </description>
              <lsb>0</lsb>
              <msb>0</msb>
            </field>
          </fields>
        </register>
        <register>
          <name>GQSPI_IMR</name>
          <description>GQSPI Interrupt Mask</description>
          <addressOffset>0x00000110</addressOffset>
          <size>32</size>
          <resetValue>0x00000FBE</resetValue>
          <fields>
            <field>
              <name>RESERVED</name>
              <description> </description>
              <lsb>12</lsb>
              <msb>31</msb>
            </field>
            <field>
              <name>RX_FIFO_EMPTY</name>
              <description> </description>
              <lsb>11</lsb>
              <msb>11</msb>
            </field>
            <field>
              <name>GEN_FIFO_FULL</name>
              <description> </description>
              <lsb>10</lsb>
              <msb>10</msb>
            </field>
            <field>
              <name>GEN_FIFO_NOT_FULL</name>
              <description> </description>
              <lsb>9</lsb>
              <msb>9</msb>
            </field>
            <field>
              <name>TX_FIFO_EMPTY</name>
              <description> </description>
              <lsb>8</lsb>
              <msb>8</msb>
            </field>
            <field>
              <name>GEN_FIFO_EMPTY</name>
              <description> </description>
              <lsb>7</lsb>
              <msb>7</msb>
            </field>
            <field>
              <name>RESERVED</name>
              <description> </description>
              <lsb>6</lsb>
              <msb>6</msb>
            </field>
            <field>
              <name>RX_FIFO_FULL</name>
              <description> </description>
              <lsb>5</lsb>
              <msb>5</msb>
            </field>
            <field>
              <name>RX_FIFO_NOT_EMPTY</name>
              <description> </description>
              <lsb>4</lsb>
              <msb>4</msb>
            </field>
            <field>
              <name>TX_FIFO_FULL</name>
              <description> </description>
              <lsb>3</lsb>
              <msb>3</msb>
            </field>
            <field>
              <name>TX_FIFO_NOT_FULL</name>
              <description> </description>
              <lsb>2</lsb>
              <msb>2</msb>
            </field>
            <field>
              <name>POLL_TIME_EXPIRE</name>
              <description> </description>
              <lsb>1</lsb>
              <msb>1</msb>
            </field>
            <field>
              <name>RESERVED</name>
              <description> </description>
              <lsb>0</lsb>
              <msb>0</msb>
            </field>
          </fields>
        </register>
        <register>
          <name>GQSPI_EN</name>
          <description>GQSPI_Enable</description>
          <addressOffset>0x00000114</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RESERVED</name>
              <description> </description>
              <lsb>1</lsb>
              <msb>31</msb>
            </field>
            <field>
              <name>GQSPI_EN</name>
              <description> </description>
              <lsb>0</lsb>
              <msb>0</msb>
            </field>
          </fields>
        </register>
        <register>
          <name>GQSPI_TXD</name>
          <description>GQSPI Transmit Data</description>
          <addressOffset>0x0000011C</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>TX_DATA</name>
              <description> </description>
              <lsb>0</lsb>
              <msb>31</msb>
            </field>
          </fields>
        </register>
        <register>
          <name>GQSPI_RXD</name>
          <description>GQSPI Receive Data</description>
          <addressOffset>0x00000120</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RX_DATA</name>
              <description> </description>
              <lsb>0</lsb>
              <msb>31</msb>
            </field>
          </fields>
        </register>
        <register>
          <name>GQSPI_TX_THRESH</name>
          <description>GQSPI TX FIFO Threshold Level</description>
          <addressOffset>0x00000128</addressOffset>
          <size>32</size>
          <resetValue>0x00000001</resetValue>
          <fields>
            <field>
              <name>RESERVED</name>
              <description> </description>
              <lsb>6</lsb>
              <msb>31</msb>
            </field>
            <field>
              <name>LEVEL_TX_FIFO</name>
              <description> Note: Change this value only when controller is not communicating with the memory device. </description>
              <lsb>0</lsb>
              <msb>5</msb>
            </field>
          </fields>
        </register>
        <register>
          <name>GQSPI_RX_THRESH</name>
          <description>GQSPI RX FIFO Threshold Level</description>
          <addressOffset>0x0000012C</addressOffset>
          <size>32</size>
          <resetValue>0x00000001</resetValue>
          <fields>
            <field>
              <name>RESERVED</name>
              <description> </description>
              <lsb>6</lsb>
              <msb>31</msb>
            </field>
            <field>
              <name>LEVEL_RX_FIFO</name>
              <description> </description>
              <lsb>0</lsb>
              <msb>5</msb>
            </field>
          </fields>
        </register>
        <register>
          <name>GQSPI_GPIO</name>
          <description>GQSPI GPIO for Write Protect</description>
          <addressOffset>0x00000130</addressOffset>
          <size>32</size>
          <resetValue>0x00000001</resetValue>
          <fields>
            <field>
              <name>WP_N</name>
              <description> Write Protect output for flash devices supporting this function. Active low (may be inverted externally to the core if required for flash devices requiring active high write protect signal.) Note: Change this value only when controller is not communicating with the memory device. </description>
              <lsb>0</lsb>
              <msb>0</msb>
            </field>
          </fields>
        </register>
        <register>
          <name>GQSPI_LPBK_DLY_ADJ</name>
          <description>GQSPI Loopback clock delay adjustment Register</description>
          <addressOffset>0x00000138</addressOffset>
          <size>32</size>
          <resetValue>0x00000033</resetValue>
          <fields>
            <field>
              <name>RESERVED</name>
              <description> </description>
              <lsb>6</lsb>
              <msb>31</msb>
            </field>
            <field>
              <name>USE_LPBK</name>
              <description> Note: Change this value only when controller is not communicating with the memory device. </description>
              <lsb>5</lsb>
              <msb>5</msb>
            </field>
            <field>
              <name>DLY1</name>
              <description> Note: Change this value only when controller is not communicating with the memory device. </description>
              <lsb>3</lsb>
              <msb>4</msb>
            </field>
            <field>
              <name>DLY0</name>
              <description> Note: Change this value only when controller is not communicating with the memory device. </description>
              <lsb>0</lsb>
              <msb>2</msb>
            </field>
          </fields>
        </register>
        <register>
          <name>GQSPI_GEN_FIFO</name>
          <description>GQSPI Generic FIFO Configuration</description>
          <addressOffset>0x00000140</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RESERVED</name>
              <description> </description>
              <lsb>20</lsb>
              <msb>31</msb>
            </field>
            <field>
              <name>GEN_DATA</name>
              <description> </description>
              <lsb>0</lsb>
              <msb>19</msb>
            </field>
          </fields>
        </register>
        <register>
          <name>GQSPI_SEL</name>
          <description>GQSPI Select</description>
          <addressOffset>0x00000144</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RESERVED</name>
              <description> </description>
              <lsb>1</lsb>
              <msb>31</msb>
            </field>
            <field>
              <name>GENERIC_QSPI_SEL</name>
              <description> Note: Change this value only when controller is not communicating with the memory device. </description>
              <lsb>0</lsb>
              <msb>0</msb>
            </field>
          </fields>
        </register>
        <register>
          <name>GQSPI_FIFO_CTRL</name>
          <description>GQSPI FIFO Control</description>
          <addressOffset>0x0000014C</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RESERVED</name>
              <description> </description>
              <lsb>3</lsb>
              <msb>31</msb>
            </field>
            <field>
              <name>RST_RX_FIFO</name>
              <description> This bit should be used only when GQSPI is in IO mode (GQSPI_CFG.MODE_EN=0x0). Switch to IO mode if operating in DMA Mode. After RST_RX_FIFO bit is written, Controller takes few clock cycles to update the RX_FIFO_Empty status bit. Software can read the RX_FIFO_empty bit twice to allow enough time for the controller to update the status bit. </description>
              <lsb>2</lsb>
              <msb>2</msb>
            </field>
            <field>
              <name>RST_TX_FIFO</name>
              <description> After RST_TX_FIFO bit is written, Controller takes few clock cycles to update the TX_FIFO_Empty status bit. Software can read the TX_FIFO_empty bit twice to allow enough time for the controller to update the status bit. </description>
              <lsb>1</lsb>
              <msb>1</msb>
            </field>
            <field>
              <name>RST_GEN_FIFO</name>
              <description> After RST_GEN_FIFO bit is written, Controller takes few clock cycles to update the Gen_FIFO_Empty status bit. Software can read the Gen_FIFO_empty bit twice to allow enough time for the controller to update the status bit. </description>
              <lsb>0</lsb>
              <msb>0</msb>
            </field>
          </fields>
        </register>
        <register>
          <name>GQSPI_GF_THRESH</name>
          <description>GQSPI Generic FIFO Threshold Level</description>
          <addressOffset>0x00000150</addressOffset>
          <size>32</size>
          <resetValue>0x00000010</resetValue>
          <fields>
            <field>
              <name>RESERVED</name>
              <description> </description>
              <lsb>5</lsb>
              <msb>31</msb>
            </field>
            <field>
              <name>LEVEL_GF_FIFO</name>
              <description> Note: Change this value only when controller is not communicating with the memory device. </description>
              <lsb>0</lsb>
              <msb>4</msb>
            </field>
          </fields>
        </register>
        <register>
          <name>GQSPI_POLL_CFG</name>
          <description>GQSPI Poll Configuration Register</description>
          <addressOffset>0x00000154</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>EN_MASK_UPPER</name>
              <description> 1: Enable. Note: Change this value only when controller is not polling. </description>
              <lsb>31</lsb>
              <msb>31</msb>
            </field>
            <field>
              <name>EN_MASK_LOWER</name>
              <description> 1: Enable. This is a static signal - should not be changed while polling operation is in progress. </description>
              <lsb>30</lsb>
              <msb>30</msb>
            </field>
            <field>
              <name>RESERVED</name>
              <description> </description>
              <lsb>16</lsb>
              <msb>29</msb>
            </field>
            <field>
              <name>MASK_EN</name>
              <description> When all the bits are zero, no masking is used and all the 8 bits of POLL_DATA field will be used for comparison during Poll. Note: Change this value only when controller is not polling. </description>
              <lsb>8</lsb>
              <msb>15</msb>
            </field>
            <field>
              <name>DATA_VALUE</name>
              <description> When Poll bit of Generic FIFO is set, Generic QSPI Controller continuously reads the data and checks with the POLL_DATA value. When the received data matches with the POLL_DATA filed, Generic QSPI Controller continues executing the next entry in the Generic FIFO. If the value is not matched and EN_POLL_TIMEOUT is set, poll operation will be terminated after POLL_TIMEOUT clock cycles. This is a static signal - should not be changed while polling operation is in progress. </description>
              <lsb>0</lsb>
              <msb>7</msb>
            </field>
          </fields>
        </register>
        <register>
          <name>GQSPI_P_TIMEOUT</name>
          <description>GQSPI Poll Time out</description>
          <addressOffset>0x00000158</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>VALUE</name>
              <description> Interrupt will be provided to indicate that the timer is expired. Note: Change this value only when controller is not polling. </description>
              <lsb>0</lsb>
              <msb>31</msb>
            </field>
          </fields>
        </register>
        <register>
          <name>QSPI_DATA_DLY_ADJ</name>
          <description>QSPI RX Data Delay</description>
          <addressOffset>0x000001F8</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>USE_DATA_DLY</name>
              <description> </description>
              <lsb>31</lsb>
              <msb>31</msb>
            </field>
            <field>
              <name>DATA_DLY_ADJ</name>
              <description> </description>
              <lsb>28</lsb>
              <msb>30</msb>
            </field>
            <field>
              <name>RESERVED</name>
              <description> </description>
              <lsb>0</lsb>
              <msb>27</msb>
            </field>
          </fields>
        </register>
        <register>
          <name>GQSPI_MOD_ID</name>
          <description>GQSPI Module Identification register</description>
          <addressOffset>0x000001FC</addressOffset>
          <size>32</size>
          <resetValue>0x010A0000</resetValue>
          <fields>
            <field>
              <name>MOD_ID</name>
              <description> </description>
              <lsb>0</lsb>
              <msb>31</msb>
            </field>
          </fields>
        </register>
        <register>
          <name>QSPIDMA_DST_ADDR</name>
          <description>DMA destination memory address</description>
          <addressOffset>0x00000800</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>ADDR</name>
              <description> (2 lsb's are 0) This field must be written initially before a DMA operation is started. In this case, it indicates the memory destination address the DMA will begin writing to. Note: Change this value only when controller is not communicating with the memory device. </description>
              <lsb>2</lsb>
              <msb>31</msb>
            </field>
            <field>
              <name>RESERVED</name>
              <description> Return 0 when read. Writes ignored. </description>
              <lsb>0</lsb>
              <msb>1</msb>
            </field>
          </fields>
        </register>
        <register>
          <name>QSPIDMA_DST_SIZE</name>
          <description>DMA transfer payload</description>
          <addressOffset>0x00000804</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RESERVED</name>
              <description> Return 0 when read. Writes ignored. </description>
              <lsb>29</lsb>
              <msb>31</msb>
            </field>
            <field>
              <name>SIZE</name>
              <description> (2 lsb's are 0) The action of writing to this register starts a DMA transfer of length SIZE, moving data from the stream interface to ADDR. In this case, it indicates the total payload that the DMA will move from stream to memory. Note: Change this value only when controller is not communicating with the memory device. </description>
              <lsb>2</lsb>
              <msb>28</msb>
            </field>
            <field>
              <name>RESERVED</name>
              <description> Return 0 when read. Writes ignored. </description>
              <lsb>0</lsb>
              <msb>1</msb>
            </field>
          </fields>
        </register>
        <register>
          <name>QSPIDMA_DST_STS</name>
          <description>General DST DMA Status</description>
          <addressOffset>0x00000808</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RESERVED</name>
              <description> Return 0 when read. Writes ignored. </description>
              <lsb>16</lsb>
              <msb>31</msb>
            </field>
            <field>
              <name>DONE_CNT</name>
              <description> A finished transfer is acknowledged by clearing the interrupt status flag 'DONE&quot;. This count is cleared by an explicit write of 3'b111 to this field. </description>
              <lsb>13</lsb>
              <msb>15</msb>
            </field>
            <field>
              <name>BUSY</name>
              <description> BUSY=0: implies DMA is DONE with the transfer, the DST FIFO and any associated pipeline registers are empty. DMA may accept a new command. Note that, BUSY essentially indicates that the DMA still has remaining work to do. BUSY will reflect this status irrespective of whether the PAUSE_* is asserted or not. </description>
              <lsb>0</lsb>
              <msb>0</msb>
            </field>
          </fields>
        </register>
        <register>
          <name>QSPIDMA_DST_CTRL</name>
          <description>General DST DMA Control</description>
          <addressOffset>0x0000080C</addressOffset>
          <size>32</size>
          <resetValue>0x803FFA00</resetValue>
          <fields>
            <field>
              <name>FIFO_LVL_HIT_THRESH</name>
              <description> 7'h00: Reserved etc 7'h0F: Reserved 7'h10: Threshold is 17 entries etc 7'h7A: Threshold is 123 entries 7'h7B: Reserved etc 7'h7F: Reserved Note that &quot;7'h10&quot; is the minimum and &quot;7'h7A&quot; is the max value that should be programmed This is a static signal - should not be changed while block is actively processing commands </description>
              <lsb>25</lsb>
              <msb>31</msb>
            </field>
            <field>
              <name>APB_ERR_RESP</name>
              <description> </description>
              <lsb>24</lsb>
              <msb>24</msb>
            </field>
            <field>
              <name>ENDIANNESS</name>
              <description> </description>
              <lsb>23</lsb>
              <msb>23</msb>
            </field>
            <field>
              <name>AXI_BRST_TYPE</name>
              <description> </description>
              <lsb>22</lsb>
              <msb>22</msb>
            </field>
            <field>
              <name>TIMEOUT_VAL</name>
              <description> There are 2 physical timers, qualified with TIMEOUT_EN, that will compare against this value: 1. Timeout counter starts to run when data is provided to the AXI write channel (memory) interface and backpressure is observed. As soon as backpressure is removed, the timer is reset. When timer expires, it stops running. 2. Timeout counter runs whenever the DMA is active. Whenever a data beat is provided by the SSS, the timer is reset. When timer expires, it stops running. TIMEOUT_VAL field is interpreted as follows: Final timeout value = TIMEOUT_VAL * timeout_prescale_period where &quot;timeout_prescale_period&quot; is the period of the enable that is generated by the TIMEOUT_PRE. Examples (prescaler set to maximum of 4096 clk (~2.5ns) cycles) 12'h000: Final Timeout after 1 * (4096 * 2.5ns)] =&gt; 10.244 us 12'h001: Final Timeout after 2 * (4096 * 2.5ns)] =&gt; 20.48 us etc 12'hFFF: Final Timeout after 4096 * (4096 * 2.5ns)] =&gt; 41.94 ms Note that if PAUSE_MEM is asserted, timeout counter #1 will be paused and if PAUSE_STRM is asserted, timeout counter #2 will be paused. When either of the 2 timers expire, this register requires an explicit write of 12'hFFF to clear them - both will be cleared. Note: Change this value only when controller is not processing commands. </description>
              <lsb>10</lsb>
              <msb>21</msb>
            </field>
            <field>
              <name>FIFO_THRESH</name>
              <description> This is the FIFO threshold used to trigger the FIFO_THRESHOLD_HIT interrupt. 8'h00: Threshold is 0 entries 8'h01: Threshold is 1 entry etc 8'h80: Threshold is 128 entries Note that the interrupt will be triggered when the FIFO hits this threshold, irrespective of whether it is on the way up or down. Note: Change this value only when controller is not processing commands. </description>
              <lsb>2</lsb>
              <msb>9</msb>
            </field>
            <field>
              <name>PAUSE_STRM</name>
              <description> This in effect will lead to the emptying of the DST FIFO. 0: DMA operates as usual. If previously PAUSED, it will continue on where it left off. Note. H/W has no means to apply backpressure to the stream interface. If PAUSE_STRM is asserted, the DMA will drop the stream data. This makes PAUSE mode functionally equivalent to as if the fifo were full. The value of PAUSE_STRM may therefore be limited to debug/verification only. </description>
              <lsb>1</lsb>
              <msb>1</msb>
            </field>
            <field>
              <name>PAUSE_MEM</name>
              <description> This in effect will eventually lead to the filling of the DST FIFO. Write memory commands that are already outstanding will continue to be processed, but no new write commands will be issued to memory while PAUSE_MEM is asserted. 0: DMA operates as usual. If previously PAUSED, it will continue on where it left off. </description>
              <lsb>0</lsb>
              <msb>0</msb>
            </field>
          </fields>
        </register>
        <register>
          <name>QSPIDMA_DST_I_STS</name>
          <description>DST DMA Interrupt Status</description>
          <addressOffset>0x00000814</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RESERVED</name>
              <description> </description>
              <lsb>8</lsb>
              <msb>31</msb>
            </field>
            <field>
              <name>FIFO_OVERFLOW</name>
              <description> No backpressure mechanism exists on the stream interface in this direction. If the FIFO is full and 1 more data beat is produced by the stream interface, this bit will be set and the data beat will be discarded. If [PAUSE_STRM] is asserted and the stream interface produces a beat of data, the beat will be discarded and [FIFO_OVERFLOW] will be set. </description>
              <lsb>7</lsb>
              <msb>7</msb>
            </field>
            <field>
              <name>INVALID_APB</name>
              <description> The access request did not reach a register. </description>
              <lsb>6</lsb>
              <msb>6</msb>
            </field>
            <field>
              <name>THRESH_HIT</name>
              <description> The watermark value is set via the [FIFO_THRESH] bitfield. </description>
              <lsb>5</lsb>
              <msb>5</msb>
            </field>
            <field>
              <name>TIMEOUT_MEM</name>
              <description> DST DMA sees backpressure on AXI write data interface. Refer to [TIMEOUT_VAL] description for exact timeout duration and conditions. </description>
              <lsb>4</lsb>
              <msb>4</msb>
            </field>
            <field>
              <name>TIMEOUT_STRM</name>
              <description> DST DMA sees delay on SSS DST interface. Refer to [TIMEOUT_VAL] description for exact timeout duration and conditions. </description>
              <lsb>3</lsb>
              <msb>3</msb>
            </field>
            <field>
              <name>AXI_BRESP_ERR</name>
              <description> BRESP=DECERR/SLVERR. </description>
              <lsb>2</lsb>
              <msb>2</msb>
            </field>
            <field>
              <name>DONE</name>
              <description> The last associated AXI memory write command has been issued and processed (SIZE=0), all data has been sent (DST FIFO is empty) and all outstanding BRESP's have been received. </description>
              <lsb>1</lsb>
              <msb>1</msb>
            </field>
            <field>
              <name>RESERVED</name>
              <description> </description>
              <lsb>0</lsb>
              <msb>0</msb>
            </field>
          </fields>
        </register>
        <register>
          <name>QSPIDMA_DST_I_EN</name>
          <description>DST DMA Interrupt Enable</description>
          <addressOffset>0x00000818</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RESERVED</name>
              <description> </description>
              <lsb>8</lsb>
              <msb>31</msb>
            </field>
            <field>
              <name>FIFO_OVERFLOW</name>
              <description> </description>
              <lsb>7</lsb>
              <msb>7</msb>
            </field>
            <field>
              <name>INVALID_APB</name>
              <description> </description>
              <lsb>6</lsb>
              <msb>6</msb>
            </field>
            <field>
              <name>THRESH_HIT</name>
              <description> </description>
              <lsb>5</lsb>
              <msb>5</msb>
            </field>
            <field>
              <name>TIMEOUT_MEM</name>
              <description> </description>
              <lsb>4</lsb>
              <msb>4</msb>
            </field>
            <field>
              <name>TIMEOUT_STRM</name>
              <description> </description>
              <lsb>3</lsb>
              <msb>3</msb>
            </field>
            <field>
              <name>AXI_BRESP_ERR</name>
              <description> </description>
              <lsb>2</lsb>
              <msb>2</msb>
            </field>
            <field>
              <name>DONE</name>
              <description> </description>
              <lsb>1</lsb>
              <msb>1</msb>
            </field>
            <field>
              <name>RESERVED</name>
              <description> </description>
              <lsb>0</lsb>
              <msb>0</msb>
            </field>
          </fields>
        </register>
        <register>
          <name>QSPIDMA_DST_I_DIS</name>
          <description>DST DMA Interrupt Disable</description>
          <addressOffset>0x0000081C</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RESERVED</name>
              <description> </description>
              <lsb>8</lsb>
              <msb>31</msb>
            </field>
            <field>
              <name>FIFO_OVERFLOW</name>
              <description> </description>
              <lsb>7</lsb>
              <msb>7</msb>
            </field>
            <field>
              <name>INVALID_APB</name>
              <description> </description>
              <lsb>6</lsb>
              <msb>6</msb>
            </field>
            <field>
              <name>THRESH_HIT</name>
              <description> </description>
              <lsb>5</lsb>
              <msb>5</msb>
            </field>
            <field>
              <name>TIMEOUT_MEM</name>
              <description> </description>
              <lsb>4</lsb>
              <msb>4</msb>
            </field>
            <field>
              <name>TIMEOUT_STRM</name>
              <description> </description>
              <lsb>3</lsb>
              <msb>3</msb>
            </field>
            <field>
              <name>AXI_BRESP_ERR</name>
              <description> </description>
              <lsb>2</lsb>
              <msb>2</msb>
            </field>
            <field>
              <name>DONE</name>
              <description> </description>
              <lsb>1</lsb>
              <msb>1</msb>
            </field>
            <field>
              <name>RESERVED</name>
              <description> </description>
              <lsb>0</lsb>
              <msb>0</msb>
            </field>
          </fields>
        </register>
        <register>
          <name>QSPIDMA_DST_I_MASK</name>
          <description>DST DMA Interrupt Mask</description>
          <addressOffset>0x00000820</addressOffset>
          <size>32</size>
          <resetValue>0x000000FE</resetValue>
          <fields>
            <field>
              <name>RESERVED</name>
              <description> </description>
              <lsb>8</lsb>
              <msb>31</msb>
            </field>
            <field>
              <name>FIFO_OVERFLOW</name>
              <description> </description>
              <lsb>7</lsb>
              <msb>7</msb>
            </field>
            <field>
              <name>INVALID_APB</name>
              <description> </description>
              <lsb>6</lsb>
              <msb>6</msb>
            </field>
            <field>
              <name>THRESH_HIT</name>
              <description> </description>
              <lsb>5</lsb>
              <msb>5</msb>
            </field>
            <field>
              <name>TIMEOUT_MEM</name>
              <description> </description>
              <lsb>4</lsb>
              <msb>4</msb>
            </field>
            <field>
              <name>TIMEOUT_STRM</name>
              <description> </description>
              <lsb>3</lsb>
              <msb>3</msb>
            </field>
            <field>
              <name>AXI_BRESP_ERR</name>
              <description> </description>
              <lsb>2</lsb>
              <msb>2</msb>
            </field>
            <field>
              <name>DONE</name>
              <description> </description>
              <lsb>1</lsb>
              <msb>1</msb>
            </field>
            <field>
              <name>RESERVED</name>
              <description> </description>
              <lsb>0</lsb>
              <msb>0</msb>
            </field>
          </fields>
        </register>
        <register>
          <name>QSPIDMA_DST_CTRL2</name>
          <description>General DST DMA Control Reg 2</description>
          <addressOffset>0x00000824</addressOffset>
          <size>32</size>
          <resetValue>0x081BFFF8</resetValue>
          <fields>
            <field>
              <name>RESERVED</name>
              <description> </description>
              <lsb>28</lsb>
              <msb>31</msb>
            </field>
            <field>
              <name>AWCACHE</name>
              <description> Bit[25]: AXI AwCache[2] signal. Bit[26]: AXI AwCache[3] signal. Note: AXI AwCache[1] signal is always driven to 1. Note: Change this value only when controller is not processing commands. </description>
              <lsb>24</lsb>
              <msb>26</msb>
            </field>
            <field>
              <name>RESERVED</name>
              <description> </description>
              <lsb>23</lsb>
              <msb>23</msb>
            </field>
            <field>
              <name>TIMEOUT_EN</name>
              <description> 1: enable. Note: Change this value only when controller is not processing commands. </description>
              <lsb>22</lsb>
              <msb>22</msb>
            </field>
            <field>
              <name>TIMEOUT_PRE</name>
              <description> 5ns) cycles (Refer to [TIMEOUT_VAL] description). The [TIMEOUT_PRE] field is interpreted as follows: 000: Prescaler enables timer every cycle. 001: Prescaler enables timer every 2 cycles. .. FFF: Prescaler enables timer every 4096 cycles. Note: Change this value only when controller is not processing commands. </description>
              <lsb>4</lsb>
              <msb>15</msb>
            </field>
            <field>
              <name>MAX_OUTS_CMDS</name>
              <description> The field is interpreted as follows: 0: Max of 1 Outstanding Write command allowed 1 to 8: Max of 2 to 9 Outstanding Write commands allowed Note: Change this value only when controller is not processing commands. </description>
              <lsb>0</lsb>
              <msb>3</msb>
            </field>
          </fields>
        </register>
        <register>
          <name>QSPIDMA_DST_ADDR_MSB</name>
          <description>DMA destination memory address (MSBs)</description>
          <addressOffset>0x00000828</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RESERVED</name>
              <description> </description>
              <lsb>12</lsb>
              <msb>31</msb>
            </field>
            <field>
              <name>ADDR_MSB</name>
              <description> Refer to the description for [QSPIDMA_DST_ADDR]. This field is the 12 msbs of the full 44-bit DST address. MSBs for 44-bit DMA Destination Address. The address is comprised of three fields: [ADDR_MSB] with 12 MSBs. QSPIDMA_DST_ADDR [ADDR] with 30 bits. 00 of two LSBs. Note: Change this value only when controller is not processing commands. </description>
              <lsb>0</lsb>
              <msb>11</msb>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
  </peripherals>
  <vendorExtensions>
    <cpus>
      <cpu>
        <name>a53.0</name>
        <endian>little</endian>
      </cpu>
      <cpu>
        <name>a53.1</name>
        <endian>little</endian>
      </cpu>
      <cpu>
        <name>a53.2</name>
        <endian>little</endian>
      </cpu>
      <cpu>
        <name>a53.3</name>
        <endian>little</endian>
      </cpu>
      <cpu>
        <name>r5f.0</name>
        <endian>little</endian>
      </cpu>
      <cpu>
        <name>r5f.1</name>
        <endian>little</endian>
      </cpu>
      <cpu>
        <name>pmu</name>
        <endian>little</endian>
      </cpu>
    </cpus>
  </vendorExtensions>
</device>